<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LeetCode 895. Maximum Frequency Stack]]></title>
      <url>http://lianghan.org/2019/11/22/2019-11-22-LeetCode895/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-frequency-stack/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FreqStack</span></span> &#123;</span><br><span class="line">    mx_freq: <span class="keyword">i32</span>,</span><br><span class="line">    freq: HashMap&lt;<span class="keyword">i32</span>, <span class="keyword">i32</span>&gt;,</span><br><span class="line">    m: HashMap&lt;<span class="keyword">i32</span>, <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FreqStack &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        FreqStack &#123;</span><br><span class="line">            mx_freq: <span class="number">0</span>,</span><br><span class="line">            freq: HashMap::new(),</span><br><span class="line">            m: HashMap::new()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="keyword">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.freq.entry(x).or_insert(<span class="number">0</span>);</span><br><span class="line">        *<span class="keyword">self</span>.freq.get_mut(&amp;x).unwrap() += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> val = *<span class="keyword">self</span>.freq.get(&amp;x).unwrap();</span><br><span class="line">        <span class="keyword">self</span>.mx_freq = cmp::max(<span class="keyword">self</span>.mx_freq, val);</span><br><span class="line">        <span class="keyword">self</span>.m.entry(val).or_insert(<span class="built_in">vec!</span>[]);</span><br><span class="line">        <span class="keyword">self</span>.m.get_mut(&amp;val).unwrap().push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;        </span><br><span class="line">        <span class="keyword">let</span> x = <span class="keyword">self</span>.m.get(&amp;<span class="keyword">self</span>.mx_freq).unwrap().last().unwrap().clone();</span><br><span class="line">        <span class="keyword">self</span>.m.get_mut(&amp;<span class="keyword">self</span>.mx_freq).unwrap().pop();</span><br><span class="line">        <span class="keyword">let</span> val = <span class="keyword">self</span>.freq.get(&amp;x).unwrap();</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.m.contains_key(val) || <span class="keyword">self</span>.m.get(val).unwrap().is_empty() &#123;</span><br><span class="line">            <span class="keyword">self</span>.mx_freq -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *<span class="keyword">self</span>.freq.get_mut(&amp;x).unwrap() -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 934. Shortest Bridge]]></title>
      <url>http://lianghan.org/2019/11/22/2019-11-22-LeetCode934/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/shortest-bridge/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(grid: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, x: <span class="keyword">i32</span>, y:<span class="keyword">i32</span>, q: &amp;<span class="keyword">mut</span> VecDeque&lt;(<span class="keyword">i32</span>, <span class="keyword">i32</span>)&gt;) &#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].len() <span class="keyword">as</span> <span class="keyword">i32</span> ||</span><br><span class="line">            x &gt;= grid.len() <span class="keyword">as</span> <span class="keyword">i32</span> || grid[x <span class="keyword">as</span> <span class="keyword">usize</span>][y <span class="keyword">as</span> <span class="keyword">usize</span>] != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x <span class="keyword">as</span> <span class="keyword">usize</span>][y <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">2</span>;</span><br><span class="line">        q.push_back((x, y));</span><br><span class="line">        Self::dfs(grid, x - <span class="number">1</span>, y, q);</span><br><span class="line">        Self::dfs(grid, x, y - <span class="number">1</span>, q);</span><br><span class="line">        Self::dfs(grid, x + <span class="number">1</span>, y, q);</span><br><span class="line">        Self::dfs(grid, x, y + <span class="number">1</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">shortest_bridge</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> grid = a.clone();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..a.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> find &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..grid[<span class="number">0</span>].len() &#123;</span><br><span class="line">                <span class="keyword">if</span> find &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Self::dfs(&amp;<span class="keyword">mut</span> grid, i <span class="keyword">as</span> <span class="keyword">i32</span>, j <span class="keyword">as</span> <span class="keyword">i32</span>, &amp;<span class="keyword">mut</span> q);</span><br><span class="line">                find = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> size = q.len();</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">                size -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> item = q.front().unwrap().clone();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                <span class="keyword">let</span> (x, y) = (item.<span class="number">0</span>, item.<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> (tx, ty) = (x + dx[i], y + dy[i]);</span><br><span class="line">                    <span class="keyword">if</span> tx &lt; <span class="number">0</span> || ty &lt; <span class="number">0</span> || ty &gt;= grid[<span class="number">0</span>].len() <span class="keyword">as</span> <span class="keyword">i32</span> ||</span><br><span class="line">                        tx &gt;= grid.len() <span class="keyword">as</span> <span class="keyword">i32</span> || grid[tx <span class="keyword">as</span> <span class="keyword">usize</span>][ty <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">2</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> grid[tx <span class="keyword">as</span> <span class="keyword">usize</span>][ty <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">1</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    &#125;</span><br><span class="line">                    grid[tx <span class="keyword">as</span> <span class="keyword">usize</span>][ty <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">2</span>;</span><br><span class="line">                    q.push_back((tx, ty));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1016. Binary String With Substrings Representing 1 To N]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1016/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Typical BFS.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">query_string</span></span>(s: <span class="built_in">String</span>, n: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> set = HashSet::new();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..s.len() &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i..s.len() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">str</span> = <span class="built_in">String</span>::from(&amp;s[i..j + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">let</span> num = i32::from_str_radix(&amp;<span class="keyword">str</span>, <span class="number">2</span>).unwrap();</span><br><span class="line">                <span class="keyword">if</span> num &gt; n &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..n + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !set.contains(&amp;i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1015. Smallest Integer Divisible by K]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1015/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/smallest-integer-divisible-by-k/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">smallest_repunit_div_by_k</span></span>(k: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> cur, <span class="keyword">mut</span> ans) = (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> || k  % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ans &lt;= k &#123;</span><br><span class="line">            <span class="keyword">if</span> cur % k == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = (cur * <span class="number">10</span> + <span class="number">1</span>) % k;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1020. Number of Enclaves]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1020/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-enclaves/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Typical DFS. Similar to <a href="https://leetcode.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">1254. Number of Closed Islands</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(a : &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, x : <span class="keyword">usize</span>, y : <span class="keyword">usize</span>) -&gt; () &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n) = (a.len(), a[<span class="number">0</span>].len());</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (xx, yy) : (<span class="keyword">i32</span>, <span class="keyword">i32</span>) = (x <span class="keyword">as</span> <span class="keyword">i32</span> + dx[i], y <span class="keyword">as</span> <span class="keyword">i32</span> + dy[i]);</span><br><span class="line">            <span class="keyword">if</span> xx &gt;= m <span class="keyword">as</span> <span class="keyword">i32</span> || xx &lt; <span class="number">0</span> || yy &gt;= n <span class="keyword">as</span> <span class="keyword">i32</span> || yy &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">            <span class="keyword">if</span> a[nx][ny] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">            Self::dfs(a, nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">num_enclaves</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> A = a;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> ans) = (A.len(), A[<span class="number">0</span>].len(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> A[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">                        A[i][j] = <span class="number">0</span>;</span><br><span class="line">                        Self::dfs(&amp;<span class="keyword">mut</span> A, i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> A[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1031 Maximum Sum of Two Non-Overlapping Subarrays]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1031/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Maintain a sliding window of two sub arrays with length L and M and slide through. For each slide check two cases:<br>L first, or M first. Use prefix sum to speed up calculation of sum of a given sub array.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">max_sum_two_no_overlap</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, l: <span class="keyword">i32</span>, m: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> A = a.iter().scan(<span class="number">0</span>, |sum, i| &#123;*sum += *i; <span class="literal">Some</span>(*sum)&#125;).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        <span class="keyword">let</span> (L, M) = (l <span class="keyword">as</span> <span class="keyword">usize</span>, m <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> lmax, <span class="keyword">mut</span> rmax) = (A[L + M - <span class="number">1</span>], A[L - <span class="number">1</span>], A[M - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> L + M..A.len() <span class="keyword">as</span> <span class="keyword">usize</span> &#123;</span><br><span class="line">            lmax = cmp::max(lmax, A[i - M] - A[i - M - L]);</span><br><span class="line">            rmax = cmp::max(rmax, A[i - L] - A[i - L - M]);</span><br><span class="line">            ans = cmp::max(ans, cmp::max(A[i] - A[i - L] + rmax, A[i] - A[i - M] + lmax));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1066. Campus Bikes II]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1066/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/campus-bikes-ii/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>DFS with memorization.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dist</span></span>(worker: &amp;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, bike: &amp;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">usize</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((worker[<span class="number">0</span>] - bike[<span class="number">0</span>]).abs() + (worker[<span class="number">1</span>] - bike[<span class="number">1</span>]).abs()) <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(workers: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, bikes: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, index: <span class="keyword">usize</span>, used: <span class="keyword">usize</span>,</span><br><span class="line">           memo: &amp;<span class="keyword">mut</span> HashMap&lt;<span class="built_in">String</span>, <span class="keyword">usize</span>&gt;) -&gt; <span class="keyword">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == workers.len() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> key = [index.to_string(), <span class="built_in">String</span>::from(<span class="string">"."</span>), used.to_string()].concat();</span><br><span class="line">        <span class="keyword">if</span> memo.contains_key(&amp;key) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(&amp;key).unwrap().clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> min_dist = std::usize::MAX;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> next_used = used;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..bikes.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> next_used &amp; (<span class="number">1</span> &lt;&lt; i) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next_used = used | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            min_dist = cmp::min(min_dist,</span><br><span class="line">                                Self::dfs(workers, bikes, index + <span class="number">1</span>, next_used, memo) + Self::dist(&amp;workers[index], &amp;bikes[i]));</span><br><span class="line">            next_used ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.insert(key, min_dist);</span><br><span class="line">        <span class="keyword">return</span> min_dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">assign_bikes</span></span>(workers: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, bikes: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> memo = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> w, <span class="keyword">mut</span> b) = (workers.clone(), bikes.clone());</span><br><span class="line">        <span class="keyword">return</span> Self::dfs(&amp;<span class="keyword">mut</span> w, &amp;<span class="keyword">mut</span> b, <span class="number">0</span>, <span class="number">0</span>, &amp;<span class="keyword">mut</span> memo) <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1121. Divide Array Into Increasing Sequences]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1121/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divide-array-into-increasing-sequences/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">can_divide_into_subsequences</span></span>(nums: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, k: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> max, <span class="keyword">mut</span> cur) = (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..nums.len() - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>] &#123;</span><br><span class="line">                cur += <span class="number">1</span>;</span><br><span class="line">                max = std::cmp::max(max, cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.len() &gt;= (k * max) <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1146. Snapshot Array]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1146/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/snapshot-array/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, BTreeMap&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnapshotArray</span></span> &#123;</span><br><span class="line">    map : HashMap&lt;<span class="keyword">i32</span>, BTreeMap&lt;<span class="keyword">i32</span>, <span class="keyword">i32</span>&gt;&gt;,</span><br><span class="line">    version: <span class="keyword">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> SnapshotArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(length: <span class="keyword">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        SnapshotArray &#123;</span><br><span class="line">            map: HashMap::new(),</span><br><span class="line">            version: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="keyword">i32</span>, val: <span class="keyword">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.map.entry(index).or_insert(BTreeMap::new());</span><br><span class="line">        <span class="keyword">self</span>.map.get_mut(&amp;index).unwrap().insert(<span class="keyword">self</span>.version, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">snap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="keyword">self</span>.version;</span><br><span class="line">        <span class="keyword">self</span>.version += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(&amp;<span class="keyword">self</span>, index: <span class="keyword">i32</span>, snap_id: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.map.contains_key(&amp;index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="keyword">self</span>.map.get(&amp;index).unwrap();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> vals &#123;</span><br><span class="line">            <span class="keyword">if</span> snap_id &gt;= *entry.<span class="number">0</span> &#123;</span><br><span class="line">                ans = *entry.<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1153. String Transforms Into Another String]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1153/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/string-transforms-into-another-string/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, HashSet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">can_convert</span></span>(str1: <span class="built_in">String</span>, str2: <span class="built_in">String</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> str1.len() != str2.len() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> str1 == str2 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> have = HashSet::new();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..str1.len() &#123;</span><br><span class="line">            <span class="keyword">let</span> (key, val) = (str1.chars().nth(i).unwrap(), str2.chars().nth(i).unwrap());</span><br><span class="line">            have.insert(val);</span><br><span class="line">            <span class="keyword">if</span> !map.contains_key(&amp;key) &#123;</span><br><span class="line">                map.insert(key, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> *map.get(&amp;key).unwrap() != val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.len() &gt;= have.len() &amp;&amp; (have.len() &lt; <span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1197. Minimum Knight Moves]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1197/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-knight-moves/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_knight_moves</span></span>(x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">8</span>], [<span class="keyword">i32</span>; <span class="number">8</span>]) = (</span><br><span class="line">            [-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">            [-<span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> grid = [[-<span class="number">1</span>; <span class="number">888</span>] ; <span class="number">888</span>];</span><br><span class="line">        <span class="keyword">let</span> (ax, ay) = (x.abs() <span class="keyword">as</span> <span class="keyword">usize</span>, y.abs() <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        grid[<span class="number">400</span>][<span class="number">400</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q : VecDeque&lt;(<span class="keyword">usize</span>, <span class="keyword">usize</span>)&gt; = VecDeque::new();</span><br><span class="line">        q.push_back((<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> (cx, cy) = q.pop_front().unwrap();</span><br><span class="line">            <span class="keyword">if</span> cx == ax &amp;&amp; cy == ay &#123;</span><br><span class="line">                <span class="keyword">return</span> grid[cx + <span class="number">400</span>][cy + <span class="number">400</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (xx, yy) = (cx <span class="keyword">as</span> <span class="keyword">i32</span> + dx[k] , cy <span class="keyword">as</span> <span class="keyword">i32</span> + dy[k]);</span><br><span class="line">                <span class="keyword">let</span> (nx, ny) = ((xx + <span class="number">400</span>) <span class="keyword">as</span> <span class="keyword">usize</span>, (yy + <span class="number">400</span>) <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                <span class="keyword">if</span> grid[nx][ny] != -<span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[nx][ny] = grid[cx + <span class="number">400</span>][cy + <span class="number">400</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> xx <span class="keyword">as</span> <span class="keyword">usize</span> == ax &amp;&amp; yy <span class="keyword">as</span> <span class="keyword">usize</span> == ay &#123;</span><br><span class="line">                    <span class="keyword">return</span> grid[nx][ny];</span><br><span class="line">                &#125;</span><br><span class="line">                q.push_back((xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1147. Longest Chunked Palindrome Decomposition]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1147/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">longest_decomposition</span></span>(text: <span class="built_in">String</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, n) = (<span class="number">0</span>, text.len());</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> l, <span class="keyword">mut</span> r) = (<span class="built_in">String</span>::from(<span class="string">""</span>), <span class="built_in">String</span>::from(<span class="string">""</span>));</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            l.push(text.chars().nth(i).unwrap());</span><br><span class="line">            r.insert(<span class="number">0</span>, text.chars().nth(n - i - <span class="number">1</span>).unwrap());</span><br><span class="line">            <span class="keyword">if</span> l == r &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                l.clear(); r.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1218. Longest Arithmetic Subsequence of Given Difference]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1218/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">longest_subsequence</span></span>(arr: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, difference: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> map) = (<span class="number">0</span>, HashMap::new());</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr &#123;</span><br><span class="line">            <span class="keyword">let</span> val = cmp::max(*map.entry(i).or_insert(<span class="number">0</span>),</span><br><span class="line">                               *map.entry(i - difference).or_insert(<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            map.insert(i, val);</span><br><span class="line">            ans = cmp::max(ans, *map.entry(i).or_insert(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1155. Number of Dice Rolls With Target Sum]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1155/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">num_rolls_to_target</span></span>(d: <span class="keyword">i32</span>, f: <span class="keyword">i32</span>, target: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> MOD : <span class="keyword">u64</span> = <span class="number">1e9</span> <span class="keyword">as</span> <span class="keyword">u64</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span>; target <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span>]; d <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..d <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..f <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> j..target <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span> &#123;</span><br><span class="line">                    dp[i][k] = (dp[i][k] + dp[i - <span class="number">1</span>][k - j]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[d <span class="keyword">as</span> <span class="keyword">usize</span>][target <span class="keyword">as</span> <span class="keyword">usize</span>] <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1219. Path with Maximum Gold]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1219/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/path-with-maximum-gold/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>BFS.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_maximum_gold</span></span>(grid: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> ans, <span class="keyword">mut</span> id) = (grid.len(), grid[<span class="number">0</span>].len(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> visited = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span>; n]; m];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                id += <span class="number">1</span>;</span><br><span class="line">                visited[i][j] = <span class="number">1</span> &lt;&lt; id;</span><br><span class="line">                q.push_back((i, j, grid[i][j], visited[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> cur = q.pop_front().unwrap();</span><br><span class="line">            <span class="keyword">let</span> (x, y, sum, state) = (cur.<span class="number">0</span> <span class="keyword">as</span> <span class="keyword">i32</span>, cur.<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">i32</span>, cur.<span class="number">2</span>, cur.<span class="number">3</span>);</span><br><span class="line">            ans = cmp::max(ans, sum);</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (xx, yy) = (x + dx[i], y + dy[i]);</span><br><span class="line">                <span class="keyword">if</span> xx &lt; <span class="number">0</span> || xx == m <span class="keyword">as</span> <span class="keyword">i32</span> || yy &lt; <span class="number">0</span> || yy == n <span class="keyword">as</span> <span class="keyword">i32</span> ||</span><br><span class="line">                    grid[xx <span class="keyword">as</span> <span class="keyword">usize</span>][yy <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">0</span> || (state &amp; visited[xx <span class="keyword">as</span> <span class="keyword">usize</span>][yy <span class="keyword">as</span> <span class="keyword">usize</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                q.push_back((nx, ny, sum + grid[nx][ny], state | visited[nx][ny]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1233. Remove Sub-Folders from the Filesystem]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1233/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_subfolders</span></span>(folder: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> f, <span class="keyword">mut</span> ans) = (folder, <span class="built_in">vec!</span>[]);</span><br><span class="line">        <span class="keyword">if</span> f.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vec!</span>[];</span><br><span class="line">        &#125;</span><br><span class="line">        f.sort();</span><br><span class="line">        ans.push(f[<span class="number">0</span>].clone());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..f.len() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> prefix = ans.last().unwrap().clone();</span><br><span class="line">            prefix.push(<span class="string">'/'</span>);</span><br><span class="line">            <span class="keyword">let</span> cur = f[i].clone();</span><br><span class="line">            <span class="keyword">if</span> cur.len() &lt; prefix.len() || cur[..prefix.len()].to_string() != prefix  &#123;</span><br><span class="line">                ans.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1245. Tree Diameter]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1245/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/tree-diameter/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(g: &amp;HashMap&lt;<span class="keyword">i32</span>, <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, ans: &amp;<span class="keyword">mut</span> <span class="keyword">i32</span>, cur: <span class="keyword">i32</span>, parent: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val = g.get(&amp;cur).unwrap();</span><br><span class="line">        <span class="keyword">if</span> val.len() == <span class="number">1</span> &amp;&amp; val[<span class="number">0</span>] == parent &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> a, <span class="keyword">mut</span> b) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> val &#123;</span><br><span class="line">            <span class="keyword">if</span> *item == parent &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> next = Self::dfs(g, ans, *item, cur);</span><br><span class="line">            <span class="keyword">if</span> next &gt; a &#123;</span><br><span class="line">                b = a;</span><br><span class="line">                a = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> next &gt; b &#123;</span><br><span class="line">                b = next;</span><br><span class="line">            &#125;</span><br><span class="line">            *ans = cmp::max(*ans, a + b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">tree_diameter</span></span>(edges: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> tree, <span class="keyword">mut</span> ans) : (HashMap&lt;<span class="keyword">i32</span>, <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, <span class="keyword">i32</span>) = (HashMap::new(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> &amp;edges &#123;</span><br><span class="line">            <span class="keyword">let</span> (k, v) = (edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            tree.entry(k).or_insert(<span class="built_in">vec!</span>[]);</span><br><span class="line">            tree.entry(v).or_insert(<span class="built_in">vec!</span>[]);</span><br><span class="line">            tree.get_mut(&amp;k).unwrap().push(v);</span><br><span class="line">            tree.get_mut(&amp;v).unwrap().push(k);</span><br><span class="line">        &#125;</span><br><span class="line">        Self::dfs(&amp;tree, &amp;<span class="keyword">mut</span> ans, edges[<span class="number">0</span>][<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1254. Number of Closed Islands]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1254/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-closed-islands/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Typical BFS.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">closed_island</span></span>(grid: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> ans) = (grid.len(), grid[<span class="number">0</span>].len(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> g = grid;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> g[i][j] == <span class="number">1</span> || g[i][j] == -<span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">                q.push_back((i, j));</span><br><span class="line">                g[i][j] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">                    <span class="keyword">let</span> (x, y) = q.pop_front().unwrap();</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> (xx, yy) = (x <span class="keyword">as</span> <span class="keyword">i32</span> + dx[k], y <span class="keyword">as</span> <span class="keyword">i32</span> + dy[k]);</span><br><span class="line">                        <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt;= m <span class="keyword">as</span> <span class="keyword">i32</span> || yy &gt;= n <span class="keyword">as</span> <span class="keyword">i32</span> &#123;</span><br><span class="line">                            valid = <span class="literal">false</span>; <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                        <span class="keyword">if</span> g[nx][ny] == <span class="number">1</span> || g[nx][ny] == -<span class="number">1</span> &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        q.push_back((nx, ny));</span><br><span class="line">                        g[nx][ny] = -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> valid &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1231. Divide Chocolate]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1231/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divide-chocolate/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Binary Search</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">maximize_sweetness</span></span>(sweetness: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, k: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> l = sweetness.clone().into_iter().fold(<span class="literal">None</span>, |min, x| <span class="keyword">match</span> min &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">Some</span>(x),</span><br><span class="line">            <span class="literal">Some</span>(y) =&gt; <span class="literal">Some</span>(<span class="keyword">if</span> x &lt; y &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;),</span><br><span class="line">        &#125;).unwrap();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> r = sweetness.clone().iter().fold(<span class="number">0</span>, |<span class="keyword">mut</span> r, &amp;val| &#123;r += val; r&#125;);</span><br><span class="line">        <span class="keyword">while</span> l &lt; r &#123;</span><br><span class="line">            <span class="keyword">let</span> (mid, <span class="keyword">mut</span> sum, <span class="keyword">mut</span> cut) = ((l + r + <span class="number">1</span>) / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> sweetness.clone() &#123;</span><br><span class="line">                sum += val;</span><br><span class="line">                <span class="keyword">if</span> sum &gt;= mid &#123;</span><br><span class="line">                    sum = <span class="number">0</span>; cut += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> cut &gt; k &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cut &gt; k &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 688. Knight Probability in Chessboard]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode688/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/knight-probability-in-chessboard/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>DP, be careful about pow overflow.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">knight_probability</span></span>(n: <span class="keyword">i32</span>, k: <span class="keyword">i32</span>, r: <span class="keyword">i32</span>, c: <span class="keyword">i32</span>) -&gt; <span class="keyword">f64</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">f64</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">8</span>], [<span class="keyword">i32</span>; <span class="number">8</span>]) = (</span><br><span class="line">            [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">            [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">f64</span>; n <span class="keyword">as</span> <span class="keyword">usize</span>]; n <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">        <span class="keyword">for</span> _m <span class="keyword">in</span> <span class="number">0</span>..k &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> tmp = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span> <span class="keyword">as</span> <span class="keyword">f64</span>; n <span class="keyword">as</span> <span class="keyword">usize</span>]; n <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> (xx, yy) = (i + dx[k], j + dy[k]);</span><br><span class="line">                        <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt;= n || yy &gt;= n &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp[i <span class="keyword">as</span> <span class="keyword">usize</span>][j <span class="keyword">as</span> <span class="keyword">usize</span>] += dp[xx <span class="keyword">as</span> <span class="keyword">usize</span>][yy <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.swap_with_slice(&amp;<span class="keyword">mut</span> tmp[<span class="number">0</span>..]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[r <span class="keyword">as</span> <span class="keyword">usize</span>][c <span class="keyword">as</span> <span class="keyword">usize</span>] / <span class="number">8_f64</span>.powf(k <span class="keyword">as</span> <span class="keyword">f64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 935. Knight Dialer]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode935/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/knight-dialer/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Dynamic Programming</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">knight_dialer</span></span>(n: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> MOD : <span class="keyword">u64</span> = <span class="number">1e9</span> <span class="keyword">as</span> <span class="keyword">u64</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">const</span> dirs: [(<span class="keyword">i32</span>, <span class="keyword">i32</span>); <span class="number">8</span>] = [(-<span class="number">2</span>, -<span class="number">1</span>), (-<span class="number">2</span>, <span class="number">1</span>), (-<span class="number">1</span>, -<span class="number">2</span>), (-<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            (<span class="number">1</span>, -<span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, -<span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = [[<span class="number">1</span>; <span class="number">3</span>] ; <span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>..n &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> tmp = [[<span class="number">0</span>; <span class="number">3</span>] ; <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">3</span> &amp;&amp; j != <span class="number">1</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> (xx, yy) = (j + dirs[d].<span class="number">0</span>, i + dirs[d].<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt;= <span class="number">3</span> || yy &gt;= <span class="number">4</span> &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp[i <span class="keyword">as</span> <span class="keyword">usize</span>][j <span class="keyword">as</span> <span class="keyword">usize</span>] = (tmp[i <span class="keyword">as</span> <span class="keyword">usize</span>][j <span class="keyword">as</span> <span class="keyword">usize</span>] +</span><br><span class="line">                            dp[yy <span class="keyword">as</span> <span class="keyword">usize</span>][xx <span class="keyword">as</span> <span class="keyword">usize</span>]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.swap_with_slice(&amp;<span class="keyword">mut</span> tmp[<span class="number">0</span>..]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans : <span class="keyword">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">                ans = ((ans <span class="keyword">as</span> <span class="keyword">u64</span> + dp[i][j]) % MOD) <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 924 Minimize Malware Spread]]></title>
      <url>http://lianghan.org/2019/11/11/2019-11-11-LeetCode924/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimize-malware-spread/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>For each initially infected node, try remove it and then count the total number of infected nodes through BFS.<br>Pick up the solution that if removing such a node will yield the minimum number of infected nodes.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::vec::<span class="built_in">Vec</span>;</span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_malware_spread</span></span>(graph: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, initial: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> min) = (-<span class="number">1</span>, <span class="number">400</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> input = initial;</span><br><span class="line">        input.sort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> &amp;input &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> bad = <span class="built_in">vec!</span>[<span class="number">0</span>; graph.len()];</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> &amp;input &#123;</span><br><span class="line">                <span class="keyword">if</span> *n == *t &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bad[*n <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">1</span>; q.push_back(*n <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> affected = input.len() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">                <span class="keyword">let</span> n = q.pop_front().unwrap();</span><br><span class="line">                <span class="keyword">for</span> (i, item) <span class="keyword">in</span> graph[n].iter().enumerate() &#123;</span><br><span class="line">                    <span class="keyword">if</span> bad[i <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">1</span> || *item == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    affected += <span class="number">1</span>; bad[i <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">1</span>; q.push_back(i <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> affected &lt; min &#123;</span><br><span class="line">                min = affected;</span><br><span class="line">                ans = *t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1023. Camelcase Matching]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1023/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/camelcase-matching/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">try_match</span></span>(q: &amp;<span class="built_in">String</span>, p: &amp;<span class="built_in">String</span>) -&gt;<span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> i, <span class="keyword">mut</span> j) = (p.len(), q.len(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> i &lt; n &#123;</span><br><span class="line">            <span class="keyword">if</span> j == m &amp;&amp; q.chars().nth(i).unwrap().is_uppercase() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m || p.chars().nth(j).unwrap().is_uppercase()) &amp;&amp; q.chars().nth(i).unwrap().is_lowercase() &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> qi = q.chars().nth(i).unwrap();</span><br><span class="line">            <span class="keyword">let</span> pj = p.chars().nth(j).unwrap();</span><br><span class="line">            <span class="keyword">if</span> pj.is_uppercase() &amp;&amp; qi.is_uppercase() &amp;&amp; pj != qi &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pj.is_lowercase() &amp;&amp; pj != qi &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i+= <span class="number">1</span>; j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n &amp;&amp; j == m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">camel_match</span></span>(queries: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;, pattern: <span class="built_in">String</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="built_in">Vec</span>::new();</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> &amp;queries &#123;</span><br><span class="line">            ans.push(Self::try_match(q, &amp;pattern));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1024. Video Stitching]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1024/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/video-stitching/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Greedy.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">video_stitching</span></span>(clips: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, t: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> input = clips;</span><br><span class="line">        input.sort_by_key(|x| x[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> cur_end, <span class="keyword">mut</span> max_end, <span class="keyword">mut</span> ans, <span class="keyword">mut</span> j) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..input.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> input[i][<span class="number">0</span>] &gt; cur_end &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max_end = cur_end;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span> j &lt; input.len() &#123;</span><br><span class="line">                <span class="keyword">if</span> input[j][<span class="number">0</span>] &gt; cur_end &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max_end = std::cmp::max(max_end, input[j][<span class="number">1</span>]);</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            cur_end = max_end;</span><br><span class="line">            <span class="keyword">if</span> max_end &gt;= t &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1047. Remove All Adjacent Duplicates In String]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1047/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_duplicates</span></span>(s: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> stack = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="string">""</span>.to_string();</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">            <span class="keyword">if</span> stack.is_empty() || c != *stack.get(stack.len() - <span class="number">1</span>).unwrap() &#123;</span><br><span class="line">                stack.push(c); <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> c == *stack.get(stack.len() - <span class="number">1</span>).unwrap() &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> !stack.is_empty() &#123;</span><br><span class="line">            ans.push(stack.pop().unwrap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.chars().rev().collect::&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1056. Confusing Number]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1056/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/confusing-number/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Backtrack.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">confusing_number</span></span>(n: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> s = n.to_string();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> map: HashMap&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; = [(<span class="string">'1'</span>, <span class="string">'1'</span>), (<span class="string">'6'</span>, <span class="string">'9'</span>), (<span class="string">'8'</span>, <span class="string">'8'</span>), (<span class="string">'9'</span>, <span class="string">'6'</span>), (<span class="string">'0'</span>,<span class="string">'0'</span>)]</span><br><span class="line">            .iter().cloned().collect();</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> changed, <span class="keyword">mut</span> i, <span class="keyword">mut</span> j) = (<span class="literal">false</span>, <span class="number">0</span>, s.len() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> i &lt;= j &#123;</span><br><span class="line">            <span class="keyword">if</span> !map.contains_key(&amp;s.chars().nth(i).unwrap())</span><br><span class="line">                || !map.contains_key(&amp;s.chars().nth(j).unwrap()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> map[&amp;s.chars().nth(i).unwrap()] != s.chars().nth(j).unwrap() &#123;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span> &#123;</span><br><span class="line">                j -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1036. Escape a Large Maze.]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1036/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/escape-a-large-maze/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;HashSet, VecDeque&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">search</span></span>(blocked: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, source: &amp;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, target: &amp;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt;<span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> M : <span class="keyword">i32</span> = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> block, <span class="keyword">mut</span> visited) =</span><br><span class="line">            (HashSet::new(), HashSet::new());</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> blocked &#123;</span><br><span class="line">            block.insert((i[<span class="number">0</span>], i[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">        q.push_back((source[<span class="number">0</span>], source[<span class="number">1</span>]));</span><br><span class="line">        visited.insert((source[<span class="number">0</span>], source[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">if</span> visited.len() &gt; block.len() * block.len() / <span class="number">2</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> cur = q.front().unwrap().clone(); q.pop_front();</span><br><span class="line">            <span class="keyword">let</span> (x, y) = (cur.<span class="number">0</span>, cur.<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> x == target[<span class="number">0</span>] &amp;&amp; y == target[<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (xx, yy) = (x + dx[i], y + dy[i]);</span><br><span class="line">                <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt;= M || yy &gt;= M || visited.contains(&amp;(xx, yy))</span><br><span class="line">                    || block.contains(&amp;(xx, yy)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.push_back((xx, yy));</span><br><span class="line">                visited.insert((xx, yy));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">is_escape_possible</span></span>(blocked: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, source: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, target: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Self::search(&amp;blocked, &amp;source, &amp;target) &amp;&amp;</span><br><span class="line">            Self::search(&amp;blocked, &amp;target, &amp;source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1059. All Paths from Source Lead to Destination]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1059/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/all-paths-from-source-lead-to-destination/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, HashSet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(g: &amp;HashMap&lt;<span class="keyword">i32</span>, HashSet&lt;<span class="keyword">i32</span>&gt;&gt;, i: <span class="keyword">i32</span>, des: <span class="keyword">i32</span>, visited: &amp;<span class="keyword">mut</span> HashMap&lt;<span class="keyword">i32</span>, <span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !g.contains_key(&amp;i) || g.get(&amp;i).unwrap().is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> i == des;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> visited.contains_key(&amp;i) &#123;</span><br><span class="line">            <span class="keyword">let</span> val = visited.get(&amp;i).unwrap();</span><br><span class="line">            <span class="keyword">if</span> *val == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> *val == -<span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visited.insert(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> neib <span class="keyword">in</span> g.get(&amp;i).unwrap() &#123;</span><br><span class="line">            <span class="keyword">if</span> !Self::dfs(g, *neib, des, visited) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.insert(i, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">leads_to_destination</span></span>(n: <span class="keyword">i32</span>, edges: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, source: <span class="keyword">i32</span>, destination: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> g, <span class="keyword">mut</span> visited) = (HashMap::new(), HashMap::new());</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges &#123;</span><br><span class="line">            <span class="keyword">if</span> !g.contains_key(&amp;e[<span class="number">0</span>]) &#123;</span><br><span class="line">                g.insert(e[<span class="number">0</span>], HashSet::new());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> val = g.get(&amp;e[<span class="number">0</span>]).unwrap().clone();</span><br><span class="line">            val.insert(e[<span class="number">1</span>]);</span><br><span class="line">            g.insert(e[<span class="number">0</span>], val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Self::dfs(&amp;g, source, destination, &amp;<span class="keyword">mut</span> visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1048. Longest String Chain]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1048/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-string-chain/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">longest_str_chain</span></span>(words: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> w) = (<span class="number">0</span>, words);</span><br><span class="line">        w.sort_by_key(|x| x.len());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> w &#123;</span><br><span class="line">            <span class="keyword">if</span> map.contains_key(&amp;word) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.insert(word.clone(), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..word.len() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> c = word.clone();</span><br><span class="line">                c.remove(i);</span><br><span class="line">                <span class="keyword">if</span> map.contains_key(&amp;c) &amp;&amp;</span><br><span class="line">                    (*map.get(&amp;c).unwrap() + <span class="number">1</span> &gt; *map.get(&amp;word).unwrap()) &#123;</span><br><span class="line">                    map.insert(word.clone(), map.get(&amp;c).unwrap() + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = std::cmp::max(ans, *map.get(&amp;word).unwrap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1055. Shortest Way to Form String]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1055/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/shortest-way-to-form-string/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">shortest_way</span></span>(source: <span class="built_in">String</span>, target: <span class="built_in">String</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (ss, st, <span class="keyword">mut</span> ans) = (source.len(), target.len(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> set = HashSet::new();</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> source.chars() &#123;</span><br><span class="line">            set.insert(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> i, <span class="keyword">mut</span> j) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> i &lt; st &#123;</span><br><span class="line">            <span class="keyword">if</span> !set.contains(&amp;target.chars().nth(i).unwrap()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> j &lt; ss &amp;&amp; source.chars().nth(j).unwrap()</span><br><span class="line">                != target.chars().nth(i).unwrap() &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j == ss &#123;</span><br><span class="line">                j = <span class="number">0</span>; i -= <span class="number">1</span>; ans += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1078. Occurrences After Bigram]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1078/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/occurrences-after-bigram/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find_ocurrences</span></span>(text: <span class="built_in">String</span>, first: <span class="built_in">String</span>, second: <span class="built_in">String</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> ss = text.split_whitespace().collect::&lt;<span class="built_in">Vec</span>&lt;&amp;<span class="keyword">str</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">let</span> (size, <span class="keyword">mut</span> i, <span class="keyword">mut</span> j) = (ss.len(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; size &amp;&amp; j &lt; size &#123;</span><br><span class="line">            <span class="keyword">if</span> *ss[i] == first &amp;&amp; *ss[j] == second &amp;&amp; j + <span class="number">1</span> &lt; size &#123;</span><br><span class="line">                ans.push(ss[j + <span class="number">1</span>].to_string());</span><br><span class="line">                i = j + <span class="number">1</span>; j = i + <span class="number">1</span>; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += <span class="number">1</span>; j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1087. Brace Expansion]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1087/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/brace-expansion/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">expand</span></span>(s: <span class="built_in">String</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> prev) : (<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;, <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) = (<span class="built_in">vec!</span>[], <span class="built_in">vec!</span>[]);</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> in_brace, <span class="keyword">mut</span> initialized) = (<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'&#123;'</span> &#123;</span><br><span class="line">                prev = ans.clone(); ans.clear();</span><br><span class="line">                in_brace = <span class="literal">true</span>; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> c == <span class="string">'&#125;'</span> &#123;</span><br><span class="line">                in_brace = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> !initialized &#123;</span><br><span class="line">                    initialized = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> c == <span class="string">','</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> in_brace &#123;</span><br><span class="line">                <span class="keyword">if</span> !initialized &#123;</span><br><span class="line">                    ans.push(c.to_string());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut</span> cur = prev.clone();</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..cur.len() &#123;</span><br><span class="line">                        cur[i].push(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> <span class="keyword">str</span> <span class="keyword">in</span> cur &#123;</span><br><span class="line">                        ans.push(<span class="keyword">str</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> !initialized &#123;</span><br><span class="line">                    ans.push(c.to_string());</span><br><span class="line">                    initialized = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..ans.len() &#123;</span><br><span class="line">                        ans[i].push(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.sort();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1089. Duplicate Zeros]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1089/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/duplicate-zeros/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">duplicate_zeros</span></span>(arr: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = arr.len();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> j = n;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[i] == <span class="number">0</span> &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> i : <span class="keyword">i32</span> = (n  - <span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> j &lt; n &#123;</span><br><span class="line">                arr[j] = arr[i <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> arr[i <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">0</span> &#123;</span><br><span class="line">                j-= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> j &lt; n &#123;</span><br><span class="line">                    arr[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1091. Shortest Path in Binary Matrix]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1091/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">shortest_path_binary_matrix</span></span>(grid: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> g = grid.clone();</span><br><span class="line">        <span class="keyword">let</span> n = g.len();</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> g[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || g[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">        q.push_back((<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">8</span>], [<span class="keyword">i32</span>; <span class="number">8</span>]) = ([<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">                                               [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> size = q.len();</span><br><span class="line">            level += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">                <span class="keyword">let</span> cur = q.front().unwrap().clone(); q.pop_front();</span><br><span class="line">                <span class="keyword">let</span> (x, y) = (cur.<span class="number">0</span>, cur.<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> (xx, yy) = (x + dx[j], y + dy[j]);</span><br><span class="line">                    <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx <span class="keyword">as</span> <span class="keyword">usize</span> &gt;= n || yy <span class="keyword">as</span> <span class="keyword">usize</span> &gt;= n &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                    <span class="keyword">if</span> nx == n - <span class="number">1</span> &amp;&amp; ny == n - <span class="number">1</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> g[nx][ny] == <span class="number">1</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    g[nx][ny] = <span class="number">1</span>;</span><br><span class="line">                    q.push_back((nx <span class="keyword">as</span> <span class="keyword">i32</span>, ny <span class="keyword">as</span> <span class="keyword">i32</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1088. Confusing Number II]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1088/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/confusing-number-ii/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Backtrack.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">rotate</span></span>(xx: <span class="keyword">i64</span>) -&gt;<span class="keyword">i64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> x, <span class="keyword">mut</span> y) = (xx, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> k = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">6</span> &#123;</span><br><span class="line">                k = <span class="number">9</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> k == <span class="number">9</span> &#123;</span><br><span class="line">                k = <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            y = y * <span class="number">10</span> + k;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">search</span></span>(num: <span class="keyword">i64</span>, n: <span class="keyword">i32</span>, ans: &amp;<span class="keyword">mut</span> <span class="keyword">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; n <span class="keyword">as</span> <span class="keyword">i64</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> num != Self::rotate(num) &#123;</span><br><span class="line">                *ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Self::search(num * <span class="number">10</span>, n, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        Self::search(num * <span class="number">10</span> + <span class="number">1</span>, n, ans);</span><br><span class="line">        Self::search(num * <span class="number">10</span> + <span class="number">6</span>, n, ans);</span><br><span class="line">        Self::search(num * <span class="number">10</span> + <span class="number">8</span>, n, ans);</span><br><span class="line">        Self::search(num * <span class="number">10</span> + <span class="number">9</span>, n, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">confusing_number_ii</span></span>(n: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">        Self::search(<span class="number">0</span>, n, &amp;<span class="keyword">mut</span> ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1105. Filling Bookcase Shelves]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1105/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/filling-bookcase-shelves/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_height_shelves</span></span>(books: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, shelf_width: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (n, <span class="keyword">mut</span> i, <span class="keyword">mut</span> j) = (books.len(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = <span class="built_in">vec!</span>[std::i32::MAX; n];</span><br><span class="line">        <span class="keyword">while</span> i &lt; n &#123;</span><br><span class="line">            <span class="keyword">let</span> (<span class="keyword">mut</span> w, <span class="keyword">mut</span> h) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span> j &lt; n &#123;</span><br><span class="line">                w += books[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> w &gt; shelf_width &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h = cmp::max(h, books[j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">let</span> val = <span class="keyword">match</span> i &#123;</span><br><span class="line">                    <span class="number">0</span> =&gt; <span class="number">0</span>,</span><br><span class="line">                    _ =&gt; dp[i - <span class="number">1</span>]</span><br><span class="line">                &#125;;</span><br><span class="line">                dp[j] = cmp::min(dp[j], val + h);</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1118. Number of Days in a Month]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1118/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-days-in-a-month/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_leap_year</span></span>(y: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || (y % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">number_of_days</span></span>(y: <span class="keyword">i32</span>, m: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> feb = <span class="keyword">match</span> Self::is_leap_year(y)  &#123;</span><br><span class="line">            <span class="literal">true</span> =&gt; <span class="number">29</span>,</span><br><span class="line">            <span class="literal">false</span> =&gt; <span class="number">28</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> ans = <span class="built_in">vec!</span>[<span class="number">31</span>,feb,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>];</span><br><span class="line">        <span class="keyword">return</span> ans[m <span class="keyword">as</span> <span class="keyword">usize</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1119. Remove Vowels from a String]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1119/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-vowels-from-a-string/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::iter::FromIterator;</span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_vowels</span></span>(s: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> j) = (<span class="string">""</span>.to_string(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> vowel_set : HashSet&lt;<span class="keyword">char</span>&gt; = HashSet::from_iter(<span class="built_in">vec!</span>[<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>]);</span><br><span class="line">        <span class="keyword">while</span> j &lt; s.len() &#123;</span><br><span class="line">            <span class="keyword">let</span> sj = s.chars().nth(j).unwrap();</span><br><span class="line">            <span class="keyword">if</span> !vowel_set.contains(&amp;sj) &#123;</span><br><span class="line">                ans.push(sj);</span><br><span class="line">            &#125;</span><br><span class="line">            j+= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1138. Alphabet Board Path]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1138/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/alphabet-board-path/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">alphabet_board_path</span></span>(target: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map: HashMap&lt;<span class="keyword">char</span>, (<span class="keyword">i32</span>, <span class="keyword">i32</span>)&gt; = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> alphabet: <span class="built_in">Vec</span>&lt;<span class="keyword">char</span>&gt; = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>.chars().collect();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">26</span> &#123;</span><br><span class="line">            map.insert(alphabet[i], (i <span class="keyword">as</span> <span class="keyword">i32</span> / <span class="number">5</span>, i <span class="keyword">as</span> <span class="keyword">i32</span> % <span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> t, <span class="keyword">mut</span> ans, <span class="keyword">mut</span> dx, <span class="keyword">mut</span> dy) : (<span class="built_in">String</span>, <span class="built_in">String</span>, <span class="keyword">i32</span>, <span class="keyword">i32</span>) = (</span><br><span class="line">            target.clone(), <span class="string">""</span>.to_string(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        t.insert(<span class="number">0</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..t.len() &#123;</span><br><span class="line">            <span class="keyword">let</span> (cur, prev) = (map.get(&amp;t.chars().nth(i).unwrap()).unwrap(),</span><br><span class="line">            map.get(&amp;t.chars().nth(i - <span class="number">1</span>).unwrap()).unwrap());</span><br><span class="line">            dx = cur.<span class="number">0</span> - prev.<span class="number">0</span>; dy = cur.<span class="number">1</span> - prev.<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> dy &lt; <span class="number">0</span> &#123;</span><br><span class="line">                ans.push_str(&amp;(<span class="number">0</span>..dy * -<span class="number">1</span>).map(|_| <span class="string">"L"</span>).collect::&lt;<span class="built_in">String</span>&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> dx &lt; <span class="number">0</span> &#123;</span><br><span class="line">                ans.push_str(&amp;(<span class="number">0</span>..dx * -<span class="number">1</span>).map(|_| <span class="string">"U"</span>).collect::&lt;<span class="built_in">String</span>&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> dy &gt; <span class="number">0</span> &#123;</span><br><span class="line">                ans.push_str(&amp;(<span class="number">0</span>..dy).map(|_| <span class="string">"R"</span>).collect::&lt;<span class="built_in">String</span>&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> dx &gt; <span class="number">0</span> &#123;</span><br><span class="line">                ans.push_str(&amp;(<span class="number">0</span>..dx).map(|_| <span class="string">"D"</span>).collect::&lt;<span class="built_in">String</span>&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push(<span class="string">'!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1143. Longest Common Subsequence]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1143/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-common-subsequence/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">longest_common_subsequence</span></span>(text1: <span class="built_in">String</span>, text2: <span class="built_in">String</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> i, <span class="keyword">mut</span> j) = (text1.len(), text2.len(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span>; n + <span class="number">1</span>]; m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> i &lt; m &#123;</span><br><span class="line">            <span class="keyword">while</span> j &lt; n &#123;</span><br><span class="line">                <span class="keyword">if</span> text1.chars().nth(i).unwrap() == text2.chars().nth(j).unwrap() &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = std::cmp::max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1144. Decrease Elements To Make Array Zigzag]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1144/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">moves_to_make_zigzag</span></span>(nums: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> std::cmp;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> moves = <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> l, <span class="keyword">mut</span> r) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..nums.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                l = std::i32::MAX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i == nums.len() - <span class="number">1</span> &#123;</span><br><span class="line">                r = std::i32::MAX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = nums[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            moves[i % <span class="number">2</span>] += cmp::max(<span class="number">0</span>, nums[i] - cmp::min(l, r) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::cmp::min(moves[<span class="number">0</span>], moves[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1161. Maximum Level Sum of a Binary Tree]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1161/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">max_level_sum</span></span>(root: <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> sum, <span class="keyword">mut</span> level) = (<span class="number">0</span>, std::i32::MIN, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> root.is_none() &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">        q.push_back(root.clone());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> (<span class="keyword">mut</span> size, <span class="keyword">mut</span> cur_sum) = (q.len(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> size != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(node) = q.pop_front() &#123;</span><br><span class="line">                    cur_sum += node.clone().unwrap().borrow().val;</span><br><span class="line">                    <span class="keyword">let</span> (left, right) = (</span><br><span class="line">                        node.clone().unwrap().borrow().left.clone(),</span><br><span class="line">                        node.clone().unwrap().borrow().right.clone()</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">if</span> !left.is_none() &#123;</span><br><span class="line">                        q.push_back(left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> !right.is_none() &#123;</span><br><span class="line">                        q.push_back(right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cur_sum &gt; sum &#123;</span><br><span class="line">                sum = cur_sum;</span><br><span class="line">                ans = level;</span><br><span class="line">            &#125;</span><br><span class="line">            level += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1165. Single-Row Keyboard]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1165/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/single-row-keyboard/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">calculate_time</span></span>(keyboard: <span class="built_in">String</span>, word: <span class="built_in">String</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">26</span> &#123;</span><br><span class="line">            map.insert(keyboard.chars().nth(i).unwrap(), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, size) = (<span class="number">0</span>, word.len());</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            <span class="keyword">let</span> ci = word.chars().nth(i).unwrap();</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                ans += *map.get(&amp;ci).unwrap() <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> cii = word.chars().nth(i - <span class="number">1</span>).unwrap();</span><br><span class="line">            ans += (*map.get(&amp;cii).unwrap() <span class="keyword">as</span> <span class="keyword">i32</span></span><br><span class="line">                - *map.get(&amp;ci).unwrap() <span class="keyword">as</span> <span class="keyword">i32</span>).abs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1168. Optimize Water Distribution in a Village]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1168/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/optimize-water-distribution-in-a-village/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Union Find on minimum spanning tree.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">find</span></span>(x : <span class="keyword">usize</span>, uf: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="keyword">usize</span>&gt;) -&gt;<span class="keyword">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x == uf[x <span class="keyword">as</span> <span class="keyword">usize</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uf[x] = Self::find(uf[x], uf);</span><br><span class="line">            <span class="keyword">return</span> uf[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_cost_to_supply_water</span></span>(n: <span class="keyword">i32</span>, wells: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, pipes: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> uf = <span class="built_in">vec!</span>[<span class="number">0</span>; n <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n + <span class="number">1</span> &#123;</span><br><span class="line">            uf[i <span class="keyword">as</span> <span class="keyword">usize</span>] = i <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> p = pipes;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            p.push(<span class="built_in">vec!</span>[<span class="number">0</span>, i + <span class="number">1</span>, wells[i <span class="keyword">as</span> <span class="keyword">usize</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        p.sort_by_key(|x| x[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> pipe <span class="keyword">in</span> p &#123;</span><br><span class="line">            <span class="keyword">let</span> (fx, fy) = (Self::find(pipe[<span class="number">0</span>] <span class="keyword">as</span> <span class="keyword">usize</span>, &amp;<span class="keyword">mut</span> uf),</span><br><span class="line">                                        Self::find(pipe[<span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">usize</span>, &amp;<span class="keyword">mut</span> uf));</span><br><span class="line">            <span class="keyword">if</span> fx == fy &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += pipe[<span class="number">2</span>];</span><br><span class="line">            uf[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1167. Minimum Cost to Connect Sticks]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1167/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-cost-to-connect-sticks/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::BinaryHeap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">connect_sticks</span></span>(sticks: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> heap, <span class="keyword">mut</span> ans) = (BinaryHeap::new(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> stick <span class="keyword">in</span> sticks &#123;</span><br><span class="line">            heap.push(stick * -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> heap.len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (a, b) = (heap.pop().unwrap() * -<span class="number">1</span>, heap.pop().unwrap() * -<span class="number">1</span>);</span><br><span class="line">            ans += a + b;</span><br><span class="line">            heap.push((a + b) * -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1170. Compare Strings by Frequency of the Smallest Character]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1170/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">compute_frequency</span></span>(s: &amp;<span class="built_in">String</span>) -&gt;<span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> min_char = std::i32::MAX;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">            <span class="keyword">if</span> (c <span class="keyword">as</span> <span class="keyword">i32</span>) &lt; min_char &#123;</span><br><span class="line">                min_char = c <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..s.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> s.bytes().nth(i).unwrap() <span class="keyword">as</span> <span class="keyword">i32</span> == min_char &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">num_smaller_by_frequency</span></span>(queries: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;, words: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> cnt) = (<span class="built_in">vec!</span>[], <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">11</span>]);</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> &amp;words &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> i = Self::compute_frequency(w) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                cnt[i <span class="keyword">as</span> <span class="keyword">usize</span>] += <span class="number">1</span>;</span><br><span class="line">                i -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> &amp;queries &#123;</span><br><span class="line">            <span class="keyword">let</span> val = Self::compute_frequency(q);</span><br><span class="line">            ans.push(cnt[val <span class="keyword">as</span> <span class="keyword">usize</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1182. Shortest Distance to target color]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1182/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/shortest-distance-to-target-color/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_pos</span></span>(indices: &amp;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, target: <span class="keyword">i32</span>) -&gt;<span class="keyword">usize</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> size = indices.len();</span><br><span class="line">        <span class="keyword">let</span> index = <span class="keyword">match</span> indices.binary_search(&amp;target) &#123;</span><br><span class="line">            <span class="literal">Ok</span>(i) =&gt; i,</span><br><span class="line">            <span class="literal">Err</span>(i) =&gt; i,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> indices[<span class="number">0</span>] <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == size &#123;</span><br><span class="line">            <span class="keyword">return</span> indices[size - <span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> indices[index] - target &lt; target - indices[index - <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> indices[index] <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> indices[index - <span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">shortest_distance_color</span></span>(colors: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, queries: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map : HashMap&lt;<span class="keyword">i32</span>, <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt; = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> res = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..colors.len() &#123;</span><br><span class="line">            <span class="keyword">let</span> color = colors[i];</span><br><span class="line">            <span class="keyword">if</span> !map.contains_key(&amp;color) &#123;</span><br><span class="line">                map.insert(color, <span class="built_in">vec!</span>[i <span class="keyword">as</span> <span class="keyword">i32</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> val = (*map.get(&amp;color).unwrap()).clone();</span><br><span class="line">                val.push(i <span class="keyword">as</span> <span class="keyword">i32</span>);</span><br><span class="line">                map.insert(color, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> queries &#123;</span><br><span class="line">            <span class="keyword">let</span> target = q[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> !map.contains_key(&amp;q[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.push(-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> pos = Self::get_pos(map.get(&amp;q[<span class="number">1</span>]).unwrap(), target);</span><br><span class="line">            res.push((pos <span class="keyword">as</span> <span class="keyword">i32</span> - target).abs());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1207. Unique Number of Occurrences]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1207/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/unique-number-of-occurrences/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unique_occurrences</span></span>(arr: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> std::collections::&#123;HashMap, HashSet&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> map, <span class="keyword">mut</span> set) = (HashMap::new(), HashSet::new());</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr &#123;</span><br><span class="line">            *(map.entry(i).or_insert(<span class="number">0</span>)) += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (_, val) <span class="keyword">in</span> map &#123;</span><br><span class="line">            <span class="keyword">if</span> set.contains(&amp;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.insert(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1184. Distance Between Bus Stops]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1184/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/distance-between-bus-stops/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::mem::swap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">distance_between_bus_stops</span></span>(distance: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, start: <span class="keyword">i32</span>, destination: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> val, n, <span class="keyword">mut</span> ans) = (<span class="number">0</span>, distance.len(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> s, <span class="keyword">mut</span> d) = (start, destination);</span><br><span class="line">        <span class="keyword">if</span> s &gt; d &#123;</span><br><span class="line">            swap(&amp;<span class="keyword">mut</span> s, &amp;<span class="keyword">mut</span> d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s..d &#123;</span><br><span class="line">            val += distance[i <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = val; val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> i = d;</span><br><span class="line">        <span class="keyword">while</span> i != s &#123;</span><br><span class="line">            val += distance[i <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">            i = (i + <span class="number">1</span>) % n <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::cmp::min(val, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1209. Remove All Adjacent Duplicates in String II]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode1209/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_duplicates</span></span>(s: <span class="built_in">String</span>, k: <span class="keyword">i32</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> stack = <span class="built_in">vec!</span>[(<span class="number">0</span>, <span class="string">'#'</span>)];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="string">""</span>.to_string();</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">            <span class="keyword">let</span> index = stack.len() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> stack[index].<span class="number">1</span> != c &#123;</span><br><span class="line">                stack.push((<span class="number">1</span>, c));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> stack[index].<span class="number">0</span> == k - <span class="number">1</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> val = stack[index];</span><br><span class="line">                val.<span class="number">0</span> += <span class="number">1</span>;</span><br><span class="line">                stack[index] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> stack &#123;</span><br><span class="line">            ans.push_str(&amp;(<span class="number">0</span>..item.<span class="number">0</span> <span class="keyword">as</span> <span class="keyword">usize</span>).map(|_| item.<span class="number">1</span>).collect::&lt;<span class="built_in">String</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 794. Valid Tic-Tac-Toe State]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode794/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/valid-tic-tac-toe-state/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">valid_tic_tac_toe</span></span>(board: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> turns, <span class="keyword">mut</span> x_win, <span class="keyword">mut</span> o_win, <span class="keyword">mut</span> diag, <span class="keyword">mut</span> antidiag)</span><br><span class="line">            = (<span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> rows, <span class="keyword">mut</span> cols) = (<span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">3</span>], <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> c = board[i].chars().nth(j).unwrap();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">'X'</span> &#123;</span><br><span class="line">                    turns += <span class="number">1</span>; rows[i] += <span class="number">1</span>; cols[j] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> i == j &#123;</span><br><span class="line">                        diag += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> i + j == <span class="number">2</span> &#123;</span><br><span class="line">                        antidiag += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> c == <span class="string">'O'</span> &#123;</span><br><span class="line">                    turns -= <span class="number">1</span>; rows[i] -= <span class="number">1</span>; cols[j] -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> i == j &#123;</span><br><span class="line">                        diag -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> i + j == <span class="number">2</span> &#123;</span><br><span class="line">                        antidiag -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x_win = (rows[<span class="number">0</span>] == <span class="number">3</span> || rows[<span class="number">1</span>] == <span class="number">3</span> || rows[<span class="number">2</span>] == <span class="number">3</span> ||</span><br><span class="line">            cols[<span class="number">0</span>] == <span class="number">3</span> || cols[<span class="number">1</span>] == <span class="number">3</span> || cols[<span class="number">2</span>] == <span class="number">3</span> ||</span><br><span class="line">            diag == <span class="number">3</span> || antidiag == <span class="number">3</span>);</span><br><span class="line">        o_win = (rows[<span class="number">0</span>] == -<span class="number">3</span> || rows[<span class="number">1</span>] == -<span class="number">3</span> || rows[<span class="number">2</span>] == -<span class="number">3</span> ||</span><br><span class="line">            cols[<span class="number">0</span>] == -<span class="number">3</span> || cols[<span class="number">1</span>] == -<span class="number">3</span> || cols[<span class="number">2</span>] == -<span class="number">3</span> ||</span><br><span class="line">            diag == -<span class="number">3</span> || antidiag == -<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x_win &amp;&amp; turns == <span class="number">0</span> || o_win &amp;&amp; turns == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (turns == <span class="number">0</span> || turns == <span class="number">1</span>) &amp;&amp; (!x_win || !o_win);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 797. All Paths From Source to Target]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode797/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/all-paths-from-source-to-target/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(graph: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, cur: <span class="keyword">i32</span>, p: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, ans: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> path = p.clone();</span><br><span class="line">        path.push(cur);</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">as</span> <span class="keyword">usize</span> == graph.len() - <span class="number">1</span> &#123;</span><br><span class="line">            ans.push(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> neigh <span class="keyword">in</span> &amp;graph[cur <span class="keyword">as</span> <span class="keyword">usize</span>] &#123;</span><br><span class="line">                Self::dfs(graph, *neigh, path.clone(), ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">all_paths_source_target</span></span>(graph: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> g = graph.clone();</span><br><span class="line">        <span class="keyword">let</span> path = <span class="built_in">vec!</span>[];</span><br><span class="line">        Self::dfs(&amp;<span class="keyword">mut</span> g, <span class="number">0</span>, path, &amp;<span class="keyword">mut</span> ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 950. Reveal Cards In Increasing Order]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode950/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">deck_revealed_increasing</span></span>(deck: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> d = deck;</span><br><span class="line">        d.sort();</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> q, n, <span class="keyword">mut</span> ans) = (VecDeque::new(), d.len(), <span class="built_in">vec!</span>[<span class="number">0</span>; d.len()]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> cur = q.front().unwrap().clone();</span><br><span class="line">            ans[cur] = d[i];</span><br><span class="line">            q.pop_front();</span><br><span class="line">            <span class="keyword">if</span> q.is_empty() &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur = q.front().unwrap().clone();            </span><br><span class="line">            q.push_back(cur);</span><br><span class="line">            q.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 982. Triples with Bitwise AND Equal To Zero]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode982/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">count_triplets</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..a.len() &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..a.len() &#123;</span><br><span class="line">                <span class="keyword">let</span> val = map.entry(a[i] &amp; a[j]).or_insert(<span class="number">0</span>);</span><br><span class="line">                *val += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a &#123;</span><br><span class="line">            <span class="keyword">for</span> (key, val) <span class="keyword">in</span> &amp;map &#123;</span><br><span class="line">                <span class="keyword">if</span> key &amp; i == <span class="number">0</span> &#123;</span><br><span class="line">                    ans += *val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 997. Find the Town Judge]]></title>
      <url>http://lianghan.org/2019/11/10/2019-11-10-LeetCode997/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-the-town-judge/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, HashSet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">find_judge</span></span>(n: <span class="keyword">i32</span>, trust: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map: HashMap&lt;<span class="keyword">i32</span>, HashSet&lt;<span class="keyword">i32</span>&gt;&gt; = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> trust &#123;</span><br><span class="line">            <span class="keyword">let</span> (k, v) = (p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">            map.entry(k).or_insert(HashSet::new());</span><br><span class="line">            map.get_mut(&amp;k).unwrap().insert(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..n + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ans == i &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> map.contains_key(&amp;ans) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..n + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ans == i &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> map.contains_key(&amp;ans) || map.get(&amp;i).is_none() ||</span><br><span class="line">                !map.get(&amp;i).unwrap().contains(&amp;ans) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1145 Binary Tree Coloring Game]]></title>
      <url>http://lianghan.org/2019/10/15/2019-10-15-LeetCode1145/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-tree-coloring-game/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::cmp::max;</span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">btree_game_winning_move</span></span>(root: <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, n: <span class="keyword">i32</span>, x: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">count_sub_tree_nodes</span></span>(node: <span class="built_in">Option</span>&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, x : <span class="keyword">i32</span>,</span><br><span class="line">                                left : &amp;<span class="keyword">mut</span> <span class="keyword">i32</span>, right : &amp;<span class="keyword">mut</span> <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(n) = node &#123;</span><br><span class="line">                <span class="keyword">let</span> l = count_sub_tree_nodes(n.borrow().left.as_ref(), x, left, right);</span><br><span class="line">                <span class="keyword">let</span> r = count_sub_tree_nodes(n.borrow().right.as_ref(), x, left, right);</span><br><span class="line">                <span class="keyword">if</span> x == n.borrow().val &#123;</span><br><span class="line">                    *left = l; *right = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> l + r + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> count = count_sub_tree_nodes(root.as_ref(), x, &amp;<span class="keyword">mut</span> left, &amp;<span class="keyword">mut</span> right);</span><br><span class="line">        <span class="keyword">return</span> max(max(left, right), n - left - right - <span class="number">1</span>) &gt; n / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 1123 Lowest Common Ancestor of Deepest Leaves]]></title>
      <url>http://lianghan.org/2019/09/23/2019-09-23-LeetCode1123/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::cmp::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compute_depth</span></span>(node : <span class="built_in">Option</span>&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; <span class="keyword">u32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(n) = node &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(Solution::compute_depth(n.borrow().left.as_ref()),</span><br><span class="line">                           Solution::compute_depth(n.borrow().right.as_ref()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lca_deepest_leaves</span></span>(root: <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(node) = root.clone() &#123;</span><br><span class="line">            <span class="keyword">let</span> (l, r) = (Solution::compute_depth(node.borrow().left.as_ref()),</span><br><span class="line">                          Solution::compute_depth(node.borrow().right.as_ref()));</span><br><span class="line">            <span class="keyword">if</span> l == r &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Some</span>(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">                <span class="keyword">return</span> Solution::lca_deepest_leaves(node.borrow().right.clone());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Solution::lca_deepest_leaves(node.borrow().left.clone());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 641 Design Circular Deque]]></title>
      <url>http://lianghan.org/2019/09/19/2019-09-19-LeetCode641/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/design-circular-deque/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec::<span class="built_in">Vec</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCircularDeque</span></span> &#123;</span><br><span class="line">    v: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;,</span><br><span class="line">    head : <span class="keyword">usize</span>,</span><br><span class="line">    tail : <span class="keyword">usize</span>,</span><br><span class="line">    count : <span class="keyword">usize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> MyCircularDeque &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(k: <span class="keyword">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::with_capacity(k.clone() <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        vec.resize(k.clone() <span class="keyword">as</span> <span class="keyword">usize</span>, <span class="number">0</span>);</span><br><span class="line">        MyCircularDeque &#123;</span><br><span class="line">            v : vec,</span><br><span class="line">            head : k <span class="keyword">as</span> <span class="keyword">usize</span> - <span class="number">1</span>, tail : <span class="number">0</span>, count : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert_front</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_full() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.head.clone()] = value;</span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="keyword">self</span>.v.len() - <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert_last</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_full() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.tail.clone()] = value;</span><br><span class="line">        <span class="keyword">self</span>.tail = (<span class="keyword">self</span>.tail + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete_front</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete_last</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.tail = (<span class="keyword">self</span>.tail + <span class="keyword">self</span>.v.len() - <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_front</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[(<span class="keyword">self</span>.head.clone() + <span class="number">1</span>) % <span class="keyword">self</span>.v.len()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_rear</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[(<span class="keyword">self</span>.tail - <span class="number">1</span> + <span class="keyword">self</span>.v.len()) % <span class="keyword">self</span>.v.len()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_empty</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_full</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="keyword">self</span>.v.len();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 622 Design Circular Queue]]></title>
      <url>http://lianghan.org/2019/09/15/2019-09-15-LeetCode622/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/design-circular-queue/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec::<span class="built_in">Vec</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCircularQueue</span></span> &#123;</span><br><span class="line">    v : <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;,</span><br><span class="line">    head : <span class="keyword">usize</span>,</span><br><span class="line">    tail : <span class="keyword">usize</span>,</span><br><span class="line">    count : <span class="keyword">usize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> MyCircularQueue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(k: <span class="keyword">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::with_capacity(k.clone() <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        vec.resize(k <span class="keyword">as</span> <span class="keyword">usize</span>, <span class="number">0</span>);</span><br><span class="line">        MyCircularQueue &#123;</span><br><span class="line">            v : vec,</span><br><span class="line">            head : <span class="number">0</span>, tail : <span class="number">0</span>, count : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">en_queue</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_full() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.tail.clone()] = value;</span><br><span class="line">        <span class="keyword">self</span>.tail = (<span class="keyword">self</span>.tail + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">de_queue</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.head.clone()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">front</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[<span class="keyword">self</span>.head.clone()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">rear</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[(<span class="keyword">self</span>.tail - <span class="number">1</span> + <span class="keyword">self</span>.v.len()) % <span class="keyword">self</span>.v.len()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_empty</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_full</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="keyword">self</span>.v.len();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 301 Remove Invalid Parentheses]]></title>
      <url>http://lianghan.org/2019/09/11/2019-09-11-LeetCode301/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-invalid-parentheses/description/" target="_blank" rel="noopener">Problem Statement</a></p>
<p>First attempt on implementing solutions for leetcode problems using Rust. For someone like me with a C++ background,<br>coding in Rust requires a paradigm change. Move semantics are everywhere, everything has to be explicit, and there are<br>really not so many similarities of standard libraries between Rust and C++. In any cases, it’s fun to code in Rust,<br>and I am sure this code can be more Rustified.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_invalid_parentheses</span></span>(s: <span class="built_in">String</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> result = <span class="built_in">Vec</span>::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> visited = HashSet::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> queue = VecDeque::new();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">isParenBalanced</span></span>(s : &amp;<span class="built_in">String</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (<span class="keyword">mut</span> left, <span class="keyword">mut</span> right) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">'('</span> &#123;</span><br><span class="line">                    left = left + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> c == <span class="string">')'</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> left == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left = left - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.insert(s.clone());</span><br><span class="line">        queue.push_back(s.clone());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> stop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> !queue.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">str</span> = queue.pop_front().unwrap();</span><br><span class="line">            <span class="keyword">if</span> isParenBalanced(&amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">                result.push(<span class="keyword">str</span>.clone());</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> stop &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> it <span class="keyword">in</span> <span class="keyword">str</span>.char_indices() &#123;</span><br><span class="line">                <span class="keyword">if</span> it.<span class="number">1</span> != <span class="string">'('</span> &amp;&amp; it.<span class="number">1</span> != <span class="string">')'</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> next = <span class="keyword">str</span>.clone();</span><br><span class="line">                next.remove(it.<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> visited.contains(&amp;next) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.push_back(next.clone());</span><br><span class="line">                visited.insert(next.clone());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> LeetCode in Rust </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Rust </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 748 DIV II 500]]></title>
      <url>http://lianghan.org/2019/01/27/2019-01-26-SRM748/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Yllion &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; getString(<span class="built_in">string</span> input) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(input)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">while</span>(s &gt;&gt; str) ans.push_back(str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPower</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; s2i;</span><br><span class="line">        s2i[<span class="string">"one"</span>] = <span class="number">0</span>; s2i[<span class="string">"ten"</span>] = <span class="number">1</span>;</span><br><span class="line">        s2i[<span class="string">"hundred"</span>] = <span class="number">2</span>;</span><br><span class="line">        s2i[<span class="string">"myriad"</span>] = <span class="number">4</span>; s2i[<span class="string">"myllion"</span>] = <span class="number">8</span>;</span><br><span class="line">        s2i[<span class="string">"byllion"</span>] = <span class="number">16</span>; s2i[<span class="string">"tryllion"</span>] = <span class="number">32</span>;</span><br><span class="line">        s2i[<span class="string">"quadryllion"</span>] = <span class="number">64</span>; s2i[<span class="string">"quintyllion"</span>] = <span class="number">128</span>;</span><br><span class="line">        s2i[<span class="string">"sextyllion"</span>] = <span class="number">256</span>; s2i[<span class="string">"septyllion"</span>] = <span class="number">512</span>;</span><br><span class="line">        s2i[<span class="string">"octyllion"</span>] = <span class="number">1024</span>; s2i[<span class="string">"nonyllion"</span>] = <span class="number">2048</span>;</span><br><span class="line">        s2i[<span class="string">"decyllion"</span>] = <span class="number">4096</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; i2s;</span><br><span class="line">        i2s[<span class="number">0</span>] = <span class="string">"one"</span>; i2s[<span class="number">1</span>] = <span class="string">"ten"</span>;</span><br><span class="line">        i2s[<span class="number">2</span>] = <span class="string">"hundred"</span>;</span><br><span class="line">        i2s[<span class="number">4</span>] = <span class="string">"myriad"</span>; i2s[<span class="number">8</span>] = <span class="string">"myllion"</span>;</span><br><span class="line">        i2s[<span class="number">16</span>] = <span class="string">"byllion"</span>; i2s[<span class="number">32</span>] = <span class="string">"tryllion"</span>;</span><br><span class="line">        i2s[<span class="number">64</span>] = <span class="string">"quadryllion"</span>; i2s[<span class="number">128</span>] = <span class="string">"quintyllion"</span>;</span><br><span class="line">        i2s[<span class="number">256</span>] = <span class="string">"sextyllion"</span>; i2s[<span class="number">512</span>] = <span class="string">"septyllion"</span>;</span><br><span class="line">        i2s[<span class="number">1024</span>] = <span class="string">"octyllion"</span>; i2s[<span class="number">2048</span>] = <span class="string">"nonyllion"</span>;</span><br><span class="line">        i2s[<span class="number">4096</span>] = <span class="string">"decyllion"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> va = getString(a), vb = getString(b);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : va) &#123;</span><br><span class="line">            c += s2i[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : vb) &#123;</span><br><span class="line">            c += s2i[s];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">12</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> base = <span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; base) <span class="keyword">continue</span>;</span><br><span class="line">            ans.push_back(i2s[base]);</span><br><span class="line">            <span class="keyword">if</span> (base == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            c = c % base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!c) ans.push_back(<span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i) &#123;</span><br><span class="line">            ret += ans[i];</span><br><span class="line">            <span class="keyword">if</span> (i != ans.size() - <span class="number">1</span>) ret += <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 740 DIV II 500]]></title>
      <url>http://lianghan.org/2018/10/20/2018-10-20-SRM740/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> LongJumpCompetition &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; recoverStandings(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; jumpLengths) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> N = jumpLengths.size() / <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; cur(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cur[i] = &#123; &#123;&#125; , i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> length = jumpLengths[i * N + j];</span><br><span class="line">                cur[N - <span class="number">1</span> - j].first.push_back(<span class="number">-1</span> * length);</span><br><span class="line">                sort(cur[N - <span class="number">1</span> - j].first.begin(),</span><br><span class="line">                     cur[N - <span class="number">1</span> - j].first.end());</span><br><span class="line">            &#125;</span><br><span class="line">            sort(cur.begin(), cur.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            ans.push_back(cur[i].second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Paxos Retrospective]]></title>
      <url>http://lianghan.org/2017/09/13/2017-09-13-Paxos/</url>
      <content type="html"><![CDATA[<p>Recently I looked through Lamport’s Paxos papers again and in retrospective, I feel Paxos as an algorithm is very elegant and easy to understand. In this post I’ll try to summary the core concepts and key steps of the single decree Paxos protocol. In future posts, I’ll write more about multi-paxos, and compare multi-paxos with similar protocols such as ZAB and Raft.</p>
<h1 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h1><p>This post will use the usual terminologies for the protocol entities from the Paxos Made Simple paper, such as Proposer, Acceptor, Learner, Leader, etc.</p>
<h1 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h1><p>Paxos is used to solve consensus problem. A consensus is about reaching agreement on a single value, among a set of values. Each value in the set is proposed by a proposer.</p>
<h1 id="Assumptions-Use-Case-Constraints"><a href="#Assumptions-Use-Case-Constraints" class="headerlink" title="Assumptions / Use Case Constraints"></a>Assumptions / Use Case Constraints</h1><p>Paxos can solve consensus problem under a set of constraints, and these constraints happen to reflect real world use case constraints for distributed systems, thus it’s very practical and applicable. In particular:</p>
<ul>
<li>Fail-Recovery: each participant can fail. Failed participants can recover.</li>
<li>Asynchronous: participants communicate with each other through async messages.</li>
<li>None Byzantine Faults: These messages can be delayed, or lost, but will never be forged.</li>
</ul>
<p>It’s also worth noting that to reach consensus, a set of additional protocol level constraints have to be exposed on participants. One example is each participant can’t just insist on the value from its own, because if everyone does that, it’s possible no consensus could ever be made. In other words, participants are more interested on reach consensus on something, but they are not interested on what exactly the value of that agreement is.</p>
<h1 id="Safety-and-Liveness"><a href="#Safety-and-Liveness" class="headerlink" title="Safety and Liveness"></a>Safety and Liveness</h1><p>Because of FLP impossibility, it’s not possible to reach consensus with the constraints Paxos protocol is exposed to, yet maintain both safety and liveness properties. Paxos chooses safety over liveness.</p>
<p>The safety properties Paxos guarantees:</p>
<ul>
<li>Only a value that has been proposed may be chosen,</li>
<li>Only a single value is chosen, and</li>
<li>A process never learns that a value has been chosen unless it actually has been.</li>
</ul>
<p>Paxos does not guarantee liveness, in other words it does not guarantee making progress, or terminate.<br>For making progress, it’s possible to have live lock (which can be fixed easily through backoffs and randomization).<br>For termination, it could never terminate if not enough number of participants (the quorum) are live.</p>
<h1 id="Protocol-Constraints"><a href="#Protocol-Constraints" class="headerlink" title="Protocol Constraints"></a>Protocol Constraints</h1><p>I feel it’s easier to understand the protocol by understanding the protocol constraints exposed to participants. There are two key constraints, one on the proposer, one on the acceptor.</p>
<p>Proposer: a proposer must be willing to change the value it proposes, by using the value it acquires from the prepare phase. A proposer can propose any value though, if in prepare phase the queries on a quorum of acceptors returns null value (meaning those acceptors haven’t accepted anything.).</p>
<p>Acceptor: an acceptor must be willing to reject the proposals it receives, unless the proposal it receives has a proposal number that’s equal or greater than the maximum of all proposal numbers that the acceptor ever see during the prepare phase. In other words, acceptor has to make a promise upon receiving a proposal with a bigger proposal number than it ever sees, and the promise is to not accept any future proposals with smaller proposal number.</p>
<h1 id="Phases"><a href="#Phases" class="headerlink" title="Phases"></a>Phases</h1><p>Paxos is a two phased protocol. There are prepare phase, and accept phase. Prepare phase is used for proposer to get an updated view of the quorum and decide what to propose (e.g. update the proposal value from the response of the acceptor in prepare request if the proposal was rejected due to a smaller proposer number). Accept phase is to finish the protocol by having acceptors record the consensus and responds to proposer.</p>
<p>To Be Continued…</p>
]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Consensus Protocol </tag>
            
            <tag> Paxos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.4 Character Recognition]]></title>
      <url>http://lianghan.org/2017/09/04/2017-09-03-USACO-CharacterRecognition/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ch[] = <span class="string">"* abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM_FONTS = <span class="number">28</span>, N = <span class="number">20</span>, MAX_LINES = <span class="number">1201</span>, INF = <span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">char</span> font[MAX_NUM_FONTS][N + <span class="number">1</span>][N + <span class="number">1</span>], line[MAX_LINES][N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// diff[i][j][k]: difference between the i-th line of the input image and</span></span><br><span class="line"><span class="comment">// the k-th line of the j-th font soure image.</span></span><br><span class="line"><span class="keyword">int</span> diff[MAX_LINES][MAX_NUM_FONTS][N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// cost[i][j]: minimum cost of match between the i-th line and the (j + 19)-th</span></span><br><span class="line"><span class="comment">// line of the input image.</span></span><br><span class="line"><span class="keyword">int</span> cost[MAX_LINES][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// index of the matching char.</span></span><br><span class="line"><span class="keyword">int</span> from[MAX_LINES][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_LINES], opt[MAX_LINES], ans[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fontin</span><span class="params">(<span class="string">"font.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"charrec.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"charrec.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFont</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    fontin &gt;&gt; tmp;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">27</span>;  ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            fontin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                font[i][j][k] = str[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readImages</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            line[i][j] = str[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= N; ++t) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(line[i][t] == font[j][k][t]) <span class="keyword">continue</span>;</span><br><span class="line">                    ++diff[i][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preprocess</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">18</span> &lt;= n; ++i) &#123;</span><br><span class="line">        cost[i][<span class="number">0</span>] = cost[i][<span class="number">1</span>] = cost[i][<span class="number">2</span>] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; N; ++k) &#123;</span><br><span class="line">                t += diff[i + k - <span class="number">1</span>][j][k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &lt; cost[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cost[i][<span class="number">0</span>] = t;</span><br><span class="line">                from[i][<span class="number">0</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">19</span>; k; --k) &#123;</span><br><span class="line">                t -= diff[i + k - <span class="number">1</span>][j][k], t += diff[i + k - <span class="number">1</span>][j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(t &lt; cost[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    cost[i][<span class="number">0</span>] = t;</span><br><span class="line">                    from[i][<span class="number">0</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">19</span> &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                    t += diff[i+k<span class="number">-1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; cost[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    cost[i][<span class="number">1</span>] = t;</span><br><span class="line">                    from[i][<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">20</span> &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                    t += diff[i + k - <span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; cost[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                    cost[i][<span class="number">2</span>] = t,</span><br><span class="line">                    from[i][<span class="number">2</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = N; k; --k) &#123;</span><br><span class="line">                    t -= diff[i + k - <span class="number">1</span>][j][k];</span><br><span class="line">                    t += diff[i + k][j][k];</span><br><span class="line">                    <span class="keyword">if</span> (t &lt; cost[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                        cost[i][<span class="number">2</span>] = t;</span><br><span class="line">                        from[i][<span class="number">2</span>] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = dp[i - <span class="number">19</span>] + cost[i - <span class="number">18</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; val) &#123;</span><br><span class="line">            dp[i] = val;</span><br><span class="line">            opt[i] = <span class="number">19</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            val = dp[i - <span class="number">20</span>] + cost[i - <span class="number">19</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; val) &#123;</span><br><span class="line">                dp[i] = val;</span><br><span class="line">                opt[i] = <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            val = dp[i - <span class="number">21</span>] + cost[i - <span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; val) &#123;</span><br><span class="line">                dp[i] = val;</span><br><span class="line">                opt[i] = <span class="number">21</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readFont();</span><br><span class="line">    fin &gt;&gt; n;</span><br><span class="line">    readImages(n);</span><br><span class="line">    preprocess(n);</span><br><span class="line">    calculate(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i -= opt[i]) &#123;</span><br><span class="line">        ans[++t] = from[i - opt[i] + <span class="number">1</span>][opt[i] - <span class="number">19</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i; --i) &#123;</span><br><span class="line">        fout &lt;&lt; ch[ans[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.4 Canada Tour]]></title>
      <url>http://lianghan.org/2017/08/14/2017-08-14-USACO-CanadaTour/</url>
      <content type="html"><![CDATA[<p>For every pair of cities (i,j) find maximum total length of two paths. One path starts at city 1 and ends in city i, the other path starts from city 1 and ends in city j. Both path have no common cities except the start city 1 and the end city N. First path will reach city N, and the result will be the maximum value of the other path ending at j where 1 &lt;= j &lt;= N.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, V;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; flight;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; cities;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"tour.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"tour.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>));</span><br><span class="line">    flight = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> city;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; city;</span><br><span class="line">        cities[city] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> from, to;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; from &gt;&gt; to;</span><br><span class="line">        flight[cities[from]][cities[to]] = <span class="literal">true</span>;</span><br><span class="line">        flight[cities[to]][cities[from]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][k] &amp;&amp; flight[k][j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">std</span>::max(dp[i][k] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j][i] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flight[i][N]) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">std</span>::max(ans, dp[i][N]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.3 Big Barn]]></title>
      <url>http://lianghan.org/2017/08/09/2017-08-09-USACO-BigBarn/</url>
      <content type="html"><![CDATA[<p>Similar dynamic programming problem as the previous <a href="http://lianghan.org/2016/12/07/2016-12-07-USACO-HomeOnRange/">Home On The Range</a>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, T;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"bigbrn.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"bigbrn.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    fin &gt;&gt; N &gt;&gt; T;</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        dp[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]),</span><br><span class="line">                                dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(dp[i][j], ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.3 Network of Schools]]></title>
      <url>http://lianghan.org/2017/08/04/2017-08-04-USACO-NetworkOfSchools/</url>
      <content type="html"><![CDATA[<p>Compute the minimum number of edges to add to make a directed graph strongly connected. Use Kosaraju’s algorithm to find out strongly connected components and for each SCC count its in degree and out degree and the maximum one is the answer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g, rg <span class="comment">/* reversed graph */</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vs; <span class="comment">// post order vertices</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cmp; <span class="comment">// topological order of strongly connected component.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    g[from].push_back(to);</span><br><span class="line">    rg[to].push_back(from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[g[v][i]]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(g[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vs.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    cmp[v] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rg[v].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[rg[v][i]]) <span class="keyword">continue</span>;</span><br><span class="line">        rdfs(rg[v][i], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">    vs.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)vs.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[vs[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        rdfs(vs[i], k++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"schlnet.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"schlnet.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N); rg = g;</span><br><span class="line">    vs = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N, <span class="literal">false</span>);</span><br><span class="line">    cmp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> ins = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> outs = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t; fin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            add_edge(i, t - <span class="number">1</span>);</span><br><span class="line">            fin &gt;&gt; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numOfScc = scc();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cout &lt;&lt; numOfScc &lt;&lt; endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(numOfScc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[i][j];</span><br><span class="line">            <span class="keyword">int</span> ii = cmp[i], vv = cmp[v];</span><br><span class="line">            <span class="keyword">if</span>(ii != vv) &#123;</span><br><span class="line">                ins[vv]++; outs[ii]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans0 = <span class="number">0</span>, ans1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfScc; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ins[i])  ++ans0; <span class="keyword">if</span>(!outs[i]) ++ans1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; max(ans0, ans1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; max(ans0, ans1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph Theory </tag>
            
            <tag> Strongly Connected Components </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.3 Window Area]]></title>
      <url>http://lianghan.org/2017/07/22/2017-07-22-USACO-WindowArea/</url>
      <content type="html"><![CDATA[<p>Maintain an array of windows and an array of levels maps to each window. Bring a window top / down is easy, just change the levels. Destroy a window is also easy. To draw the visible surface of window, consider the drawing process a series of culling with the windows with a higher level than it. At each step, there are several cases: not culling, partial culling, or completely culling. After each step we either get the end result or in case of partial culling, we repeat same step again until we hit the top level window. DFS is a natural fit here.</p>
<p>One note is the input data has to be normalized first (the corners of the window could be top-left/bottom-right or bottom-left/top-right).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">70</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> window &#123;</span><br><span class="line">    <span class="keyword">int</span> u, d, l, r;</span><br><span class="line">&#125; tWindow;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tWindow&gt; windows(M);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; order(N);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u <span class="comment">/*up*/</span>, <span class="keyword">int</span> l <span class="comment">/*left*/</span>, <span class="keyword">int</span> d <span class="comment">/*down*/</span>, <span class="keyword">int</span> r <span class="comment">/*right*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level &gt; total) &#123;</span><br><span class="line">        ans += (u - d) * (r - l);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = order[level];</span><br><span class="line">    tWindow w = windows[i];</span><br><span class="line">    <span class="keyword">if</span>(u &lt;= w.d || d &gt;= w.u || l &gt;= w.r || r &lt;= w.l ) &#123;</span><br><span class="line">        dfs(u, l, d , r, level + <span class="number">1</span>); <span class="comment">/* no intersection */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(u &lt;= w.u &amp;&amp; d &gt;= w.d &amp;&amp; l &gt;= w.l &amp;&amp; r &lt;= w.r ) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* absorbed */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; w.u &amp;&amp; w.u &lt; u) &#123;</span><br><span class="line">            dfs(u, l, w.u, r, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; w.d &amp;&amp; w.d &lt; u) &#123;</span><br><span class="line">            dfs(w.d, l, d, r, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// avoid duplicate compute</span></span><br><span class="line">        u = <span class="built_in">std</span>::min(u, w.u);</span><br><span class="line">        d = <span class="built_in">std</span>::max(d, w.d);</span><br><span class="line">        <span class="keyword">if</span>(w.l &gt; l &amp;&amp; w.l &lt; r) &#123;</span><br><span class="line">           dfs(u, l, d, w.l, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w.r &gt; l &amp;&amp; w.r &lt; r) &#123;</span><br><span class="line">           dfs(u, w.r, d, r, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"window.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"window.out"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> op, id, s;</span><br><span class="line">    <span class="keyword">int</span> i, u, d, l, r;</span><br><span class="line">    <span class="keyword">while</span>(fin &gt;&gt; op) &#123;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">'w'</span>) &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s &gt;&gt; l &gt;&gt; s &gt;&gt; u &gt;&gt; s &gt;&gt; r &gt;&gt; s &gt;&gt; d &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(d &gt; u) swap(d,u);</span><br><span class="line">            <span class="keyword">if</span>(l &gt; r) swap(l,r);</span><br><span class="line">            windows[id].u = u; windows[id].d=d;</span><br><span class="line">            windows[id].l=l; windows[id].r=r;</span><br><span class="line">            total++;</span><br><span class="line">            order[total] = id;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'t'</span>|| op == <span class="string">'d'</span>) &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; total; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(order[i] == id) swap(order[i],order[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">'d'</span>) total--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'b'</span>) &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(i = total; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(order[i] == id) swap(order[i],order[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= total; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(order[i] == id) &#123;</span><br><span class="line">                    ans = <span class="number">0</span>;</span><br><span class="line">                    tWindow w = windows[id];</span><br><span class="line">                    u = (w.u - w.d) * (w.r - w.l);</span><br><span class="line">                    dfs(w.u, w.l, w.d, w.r, i + <span class="number">1</span>);</span><br><span class="line">                    fout &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>)</span><br><span class="line">                         &lt;&lt; <span class="number">100.0</span> * ans / u &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DFS </tag>
            
            <tag> Simulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Paper Digest - Consensus in the Cloud - Paxos Systems Demystified]]></title>
      <url>http://lianghan.org/2017/07/03/2017-07-01-ConsensusInTheCloud/</url>
      <content type="html"><![CDATA[<p>Paper digest - <a href="https://www.cse.buffalo.edu/tech-reports/2016-02.pdf" target="_blank" rel="noopener">Consensus in the Cloud - Paxos Systems Demystified</a></p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul>
<li>Compared several popular Paxos protocols and Paxos systems and present advantages and disadvantages for each.</li>
<li>Categorized the coordination use-patterns in cloud, and examine Google and Facebook infrastructures, as well as use cases of Paxos in Apache projects.</li>
<li>Analyzed tradeoffs in the distributed coordination domain and identify promising future directions.</li>
</ul>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul>
<li>Coordination plays a major role in cloud computing systems:<ul>
<li>Leader election</li>
<li>Group membership</li>
<li>Cluster management</li>
<li>Service discovery</li>
<li>Resource/access management</li>
<li>Consistent replication of the master nodes in services</li>
<li>Barrier-orchestration when running large analytic tasks</li>
<li>And so on..</li>
</ul>
</li>
<li>The coordination problem has been studied extensively under the name “distributed consensus”.</li>
<li>Paxos rise to fame with Google Chubby (lock service for GFS).</li>
<li>Apache ZooKeeper as a coordination kernel<ul>
<li>File system abstraction easy to use.</li>
<li>Abused / misused, often constituted the bottleneck in performance of these applications and caused scalability problems.</li>
</ul>
</li>
<li>More choices nowadays (Raft, etc), with confusions still remained:<ul>
<li>Proper use cases.</li>
<li>Which systems are more suitable for which tasks:<ul>
<li>Paxos protocols (e.g. multi-paxos, Raft, ZAB) are useful for low-level components for server replication.</li>
<li>Paxos systems (e.g. ZK) are useful for highly-available/durable metadata management with constraints that all metadata fit in main-memory and are not subject to very frequent changes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Paxos-Protocols"><a href="#Paxos-Protocols" class="headerlink" title="Paxos Protocols"></a>Paxos Protocols</h1><ul>
<li>Protocols<ul>
<li>Paxos: fault-tolerant consensus for a single value.</li>
<li>Multi-Paxos: fault-tolerant consensus for multiple values.</li>
<li>ZAB: additional constraints on Paxos (primary global order).</li>
<li>Raft: very similar to ZAB with some implementation level difference.</li>
</ul>
</li>
<li>Differences<ul>
<li>Leader Election:<ul>
<li>Zab and Raft protocols differ from Paxos as they divide execution into phases (called epochs in Zab and terms in Raft).</li>
<li>Each epoch begins with a new election, goes into the broadcast phase and ends with a leader failure.</li>
<li>The phases are sequential because of the additional safety properties are provided by the isLeader predicate.</li>
<li>Zab and Raft there can be at most one leader at any time.</li>
<li>Paxos can have multiple leaders coexisting.</li>
</ul>
</li>
<li>Zab has discovery and sync phase, Raft does not which simplifies algorithm but makes recover longer, possibly.</li>
<li>Communication:<ul>
<li>ZAB is messaging model. Each update requires at least three messages:<ul>
<li>proposal, ack and commit</li>
</ul>
</li>
<li>Raft use RPC.</li>
</ul>
</li>
<li>Dynamic reconfiguration:<ul>
<li>Reconfig is just another command go through consensus process.</li>
<li>To ensure safety, new config cannot be activated immediately and the configuration changes must go through two phases.</li>
<li>A process can only propose commands for slots with known configuration, ∀ρ : ρ.slotin &lt; ρ.slotout+ WINDOW.</li>
<li>With primary order property provided by Zab and Raft, both protocols are able to implement their reconfiguration algorithms without limitations to normal operations or external services.</li>
<li>Both Zab and Raft include a pre-phase where the new processes join the cluster as a non-voting members so that the leader in Cold could initialize their states by transferring currently committed prefix of updates.</li>
<li>In Zab, the time between new config proposed and committed, any commands received after reconfig is only scheduled but will not commit.</li>
</ul>
</li>
</ul>
</li>
<li>Paxos Extensions<ul>
<li>Generalized Paxos: allows acceptors to vote for independent commands.</li>
<li>EPaxos:<ul>
<li>allows nodes to commit conflict free commands by checking the command dependency list.</li>
<li>adds significant complexity and extra effort to resolve the conflict if concurrent commands do not commute.</li>
<li><strong>from an engineer’s perspective, the sketch algorithm descriptions in the literature are often underspecified, and lead to divergent interpretations and implementations.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Paxos-Systems"><a href="#Paxos-Systems" class="headerlink" title="Paxos Systems"></a>Paxos Systems</h1><ul>
<li>Chubby, Apache ZooKeeper, etcd<ul>
<li>All three services hide the replicated state machine and log abstractions under a small data-store with filesystem-like API.</li>
<li>All three support watchers.</li>
<li>All three support ephemeral storage.</li>
<li>All three support observers (none voting quorum peer).</li>
</ul>
</li>
<li>Difference<ul>
<li>ZK provides client FIFO order.</li>
<li>etcd is stateless (<strong>note, not very true with etcd 3.0’s lease, which is ZK session kind things.</strong>)</li>
<li>etcd has TTL (<strong>note, ZK has ttl too after 3.5.3.</strong>)</li>
<li>etcd has hidden data (MVCC).</li>
<li>ZK has weighted quorum.</li>
</ul>
</li>
<li>Proper use criteria for Paxos systems<ul>
<li><strong>Paxos system should not be in the performance critical path of the application.</strong></li>
<li><strong>Frequency of write operations to the Paxos system should be kept low</strong></li>
<li><strong>Amount of data maintained in the Paxos system should be kept small</strong></li>
<li><strong>Application adopting the Paxos system should really require strong consistency</strong></li>
<li><strong>Application adopting the Paxos system should not be distributed over the Wide Area Network (WAN).</strong></li>
<li><strong> The API abstraction should be fit the goal.</strong></li>
</ul>
</li>
</ul>
<h1 id="Paxos-Usage-Patterns"><a href="#Paxos-Usage-Patterns" class="headerlink" title="Paxos Usage Patterns"></a>Paxos Usage Patterns</h1><ul>
<li>Server Replication (SR)</li>
<li>Log Replication (LR)</li>
<li>Synchronization Service (SS).</li>
<li>Barrier Orchestration (BO).</li>
<li>Configuration Management.</li>
<li>Message Queues (Q).</li>
</ul>
<h1 id="Paxos-Uasage-in-Production"><a href="#Paxos-Uasage-in-Production" class="headerlink" title="Paxos Uasage in Production"></a>Paxos Uasage in Production</h1>]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Paper Digest </tag>
            
            <tag> Consensus Protocol </tag>
            
            <tag> Paxos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 716 DIV II]]></title>
      <url>http://lianghan.org/2017/07/03/2017-07-01-TopCoder-SRM716DivI/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Permutiple &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> xx = <span class="built_in">std</span>::to_string(x);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="built_in">std</span>::stoi(xx);</span><br><span class="line">            <span class="keyword">if</span> (val &lt;= x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (val % x == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Possible"</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">std</span>::next_permutation(xx.begin(), xx.end()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Impossible"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ConstructLCSEasy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">construct</span><span class="params">(<span class="keyword">int</span> ab, <span class="keyword">int</span> bc, <span class="keyword">int</span> ca)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">AB</span><span class="params">(ab, <span class="string">'1'</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> BC = AB, CA = AB;</span><br><span class="line">        <span class="keyword">int</span> diff2 = bc - ab;</span><br><span class="line">        <span class="keyword">while</span> (diff2--) &#123;</span><br><span class="line">            BC += <span class="string">"0"</span>; CA += <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff3 = ca - ab;</span><br><span class="line">        <span class="keyword">while</span> (diff3--) &#123;</span><br><span class="line">            AB += <span class="string">"1"</span>; CA += <span class="string">"1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AB + <span class="string">" "</span> + BC + <span class="string">" "</span> + CA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.3 Milk Measuring]]></title>
      <url>http://lianghan.org/2017/06/25/2017-06-24-USACO-MilkMeasuring/</url>
      <content type="html"><![CDATA[<p>Brutal force DFS search with a lot of pruning. The search has N passes, and it starts from 1 pail, then 2 pails, etc and up to N pails. For each pass, use memorization and pruning to avoid hitting unnecessary search space. The passes are deepened via DFS, and we return once we gets a hit in a given pass as the question was asking the smallest set of pails.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Q, N, total;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pails, ans, cur;</span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, <span class="keyword">int</span> index, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == total) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// dfs does not guarantee smallest order, so</span></span><br><span class="line">            <span class="comment">// keep this and compare with a future solution.</span></span><br><span class="line">            ans = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current = pails[index];</span><br><span class="line">    <span class="comment">// not feasible.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= N || left &lt; current) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// current search is no smaller than existing solution.</span></span><br><span class="line">    <span class="keyword">if</span> (found &amp;&amp; current &gt; ans[depth]) <span class="keyword">return</span>;</span><br><span class="line">    cur[depth] = current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= left / current; i++) &#123;</span><br><span class="line">        dfs(depth + <span class="number">1</span>, index + <span class="number">1</span>, left - i * current);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(depth, index + <span class="number">1</span>, left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"milk4.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"milk4.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; Q &gt;&gt; N;</span><br><span class="line">    </span><br><span class="line">    pails = cur = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        fin &gt;&gt; pails[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(pails.begin(), pails.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (total = <span class="number">1</span>; total &lt;= N; ++total) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, Q);</span><br><span class="line">        <span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; total; <span class="built_in">cout</span> &lt;&lt; total;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i]; <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>;<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DFS </tag>
            
            <tag> MEMORIZED SEARCH </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Paper Digest - Megastore, Providing Scalable, Highly Available Storage for Interactive Services]]></title>
      <url>http://lianghan.org/2017/05/08/2017-05-08-MegaStore/</url>
      <content type="html"><![CDATA[<p>Paper digest - <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36971.pdf" target="_blank" rel="noopener">Megastore: Providing Scalable, Highly Available Storage for Interactive Services</a></p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul>
<li>Blends the scalability of a NoSQL datastore with the convenience of a traditional RDBMS.</li>
<li>Provides both strong consistency guarantees and high availability.</li>
<li>Provides fully serializable ACID semantics within fine-grained partitions of data.</li>
</ul>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>Online services are forcing the storage community to meet new demands. <ul>
<li>Highly scalable.</li>
<li>Rapid development.</li>
<li>Low latency.</li>
<li>Consistent view of data.</li>
<li>Highly available.</li>
</ul>
</li>
</ul>
<h1 id="Design-Highlights"><a href="#Design-Highlights" class="headerlink" title="Design Highlights"></a>Design Highlights</h1><ul>
<li>Partition data. Replicate unit is a partition.</li>
<li>Full ACID semantics within partitions only.</li>
<li>Across partitions, limited consistency guarantees (later spanner improves this)</li>
<li>Provide database features (2nd indexes), but does not provide scalability guarantees (can only scale within user-tolerable latency limits.)</li>
<li>Innovative usage of Paxos: use it for replication instead of traditional usage (locking, leader election, replicate config data - e.g. ZooKeeper/ZAB)</li>
</ul>
<h1 id="Availability-with-Scalability"><a href="#Availability-with-Scalability" class="headerlink" title="Availability with Scalability"></a>Availability with Scalability</h1><ul>
<li>Replication<ul>
<li>Replicate a write-ahead log over a group of symmetric peers.</li>
<li>Any node can initiate reads and writes.</li>
<li>Each log append blocks on acknowledgments from a majority of replicas.</li>
<li>Optimizations on Paxos<ul>
<li>Allow local reads.</li>
<li>Single roundtrip writes.</li>
</ul>
</li>
<li>Multiple replicated logs instead of single log for better availability.</li>
</ul>
</li>
<li>Key Concept - <strong>Entity Groups</strong><ul>
<li>Entity group is a collection of data and unit of replication.</li>
<li>Within a single entity group: ACID semantic.</li>
<li>Across entity groups:<ul>
<li>Two phased commit (strong consistency)</li>
<li>Or async communications through message queues.</li>
</ul>
</li>
</ul>
</li>
<li>Physical Layout of data<ul>
<li>Use BigTable for data storage.</li>
<li>Letting applications control the placement of data.<ul>
<li>Applications try to keep data near users and replicas near each other.</li>
<li>The data for an entity group are held in contiguous ranges of Bigtable rows.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h1><ul>
<li><strong>Cost-transparent APIs</strong>: runtime costs that match application developers’ intuitions.</li>
<li>Eliminate needs for joins:  offer fine-grained control over physical locality.</li>
<li>Joins when required is implemented in application code.</li>
</ul>
<h1 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h1><ul>
<li>Lies between the abstract tuples of an RDBMS and the concrete row-column storage of NoSQL.</li>
<li>Data model is declared in a schema and is strongly typed.</li>
</ul>
<h1 id="Transactions-and-Concurrency-Control"><a href="#Transactions-and-Concurrency-Control" class="headerlink" title="Transactions and Concurrency Control"></a>Transactions and Concurrency Control</h1><ul>
<li>Use MVCC. Readers and writers don’t block each other, and reads are isolated from writes for the duration of a transaction.</li>
<li>Read semantics<ul>
<li>current (single entity group)</li>
<li>snapshot (single entity group)</li>
<li>inconsistent (ignore state of log)</li>
</ul>
</li>
<li>Queues<ul>
<li>Cross group batch operation deliver.</li>
</ul>
</li>
<li>2 Phased Commit for atomic update across entity groups.</li>
</ul>
<h1 id="Paxos-based-Replication-key-innovations"><a href="#Paxos-based-Replication-key-innovations" class="headerlink" title="Paxos based Replication (key innovations)"></a>Paxos based Replication <strong>(key innovations)</strong></h1><ul>
<li>Pitfall of master-slave based Paxos<ul>
<li>Master failover can require a complicated state machine.</li>
<li>A series of timers must elapse before service is restored. </li>
<li>It is difficult to avoid user-visible outages.</li>
</ul>
</li>
<li>Fast Reads<ul>
<li>Local read.</li>
<li>Coordinator tracks if a specific replica has observed the full state of writes so it can serve local reads.</li>
</ul>
</li>
<li>Fast Writes<ul>
<li>Single round trip writes.</li>
<li>Pre-preparing optimization: each successful write includes an implied prepare message granting the master the right to issue accept messages for the next log position.</li>
<li>If the write succeeds, the prepares are honored, and the next write skips directly to the accept phase. </li>
<li>Multi-Paxos: independent instance of the Paxos algorithm for each log position. T</li>
</ul>
</li>
<li>Replica Types<ul>
<li>Full Replica: contain all entity and index and able to serve current reads.</li>
<li>Witness Replica: vote and store WAL, but does not apply the WAL (kind like observer in ZooKeeper but not strictly the same - observer in ZK does not vote.)</li>
<li>Read Only Replica: does not vote but contain full data of a point of time in the past (more like ZK observer but ZK observer is more up to date WRT its state.)</li>
</ul>
</li>
</ul>
<h1 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h1><ul>
<li>The coordinator is a simple process with no external dependencies and no persistent storage.</li>
<li>Failure Detection<ul>
<li>Use an out of band protocol to identify when other coordinators are up, healthy, and generally reachable.</li>
<li>Coordinators obtain specific Chubby locks in remote datacenters at startup.</li>
<li>Revert its state to a conservative default when loses majority of locks and / or parititons.</li>
<li>Brief and rare outage risk..</li>
<li>Liveness protocol is vulnerable to asymmetric network partitions.</li>
</ul>
</li>
</ul>
<h1 id="Operation-Metrics-Experience-ommitted"><a href="#Operation-Metrics-Experience-ommitted" class="headerlink" title="Operation / Metrics / Experience - ommitted."></a>Operation / Metrics / Experience - ommitted.</h1>]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Paper Digest </tag>
            
            <tag> NewSQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Paper Digest - Paxos Made Simple]]></title>
      <url>http://lianghan.org/2017/05/01/2017-05-01-Paxos/</url>
      <content type="html"><![CDATA[<p>Paper digest - <a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf" target="_blank" rel="noopener">Paxos Made Simple </a></p>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>Solve consensus problem on a single value (basic Paxos).</li>
<li>Consensus problem for a series of values that forming a log is solved using Multi-Paxos.</li>
</ul>
<h1 id="Consensus-Problem"><a href="#Consensus-Problem" class="headerlink" title="Consensus Problem"></a>Consensus Problem</h1><ul>
<li>A consensus algorithm ensures that a single one among the proposed value is choose.</li>
<li>Chosen: meaning a consensus has been reached.</li>
<li>Safety properties of consensus:<ul>
<li>Only a value that has been proposed may be chosen.</li>
<li>Only a single value can be chosen.</li>
<li>A process never learns that a value has been chosen unless it actually has been.</li>
</ul>
</li>
<li>Liveness properties of consensus:<ul>
<li>One of many proposed values is eventually chosen.</li>
<li>If a value is chosen, processes eventually learn about it.</li>
</ul>
</li>
</ul>
<h1 id="Failure-Models"><a href="#Failure-Models" class="headerlink" title="Failure Models"></a>Failure Models</h1><ul>
<li>Fail Stop: servers may crash, and stop forever.</li>
<li>Fail Recovery: servers may crash, but finally will restart and recover.</li>
<li>No Byzantine failures: messages can be delayed but they can’t be corrupted; servers can fail but they can’t behave maliciously.</li>
</ul>
<h1 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h1><ul>
<li>Proposer: propose value. A proposer propose value by sending a proposal, which contains the value (among other things), to acceptors.</li>
<li>Acceptor: accept value proposed by proposer. Accept means acknowledge to proposer that the proposed value is accepted, by sending response to proposer.</li>
<li>Chosen: a value is chosen when majority of acceptors accept the value.</li>
<li>A process can be both a proposer and an acceptor.</li>
</ul>
<h1 id="Choose-a-Value"><a href="#Choose-a-Value" class="headerlink" title="Choose a Value"></a>Choose a Value</h1><ul>
<li>Single acceptor:<ul>
<li>Easiest and most intuitive approach :)</li>
<li>However, it is not fault tolerant. If the single acceptor crashes, the system will not be able to make progress.</li>
</ul>
</li>
<li>Multiple acceptors:<ul>
<li>Solve the SPOF problem for single acceptor case.</li>
<li>A value is chosen when this value is accepted by a majority of acceptors.</li>
<li>This majority of acceptors is called a quorum.</li>
<li>Why majority? We need ensure that any two sets of quorum overlap. With drawer principle, if a quorum is majority, then any two majorities will have at least one acceptor in common.</li>
<li>Now why we need ensure any two sets of quorum overlap? This is for fault tolerance / recovery purpose - so that we can have at least one acceptor that has complete history of the states (of the Paxos state machine.)</li>
<li>Now why we need complete history? We need this so only a single value is chosen (important safety property). Why? Elaboration next.</li>
</ul>
</li>
<li>How to choose a value<ul>
<li>Case 1: single proposed value - only a single value is proposed from proposers.<ul>
<li>If there is only a single value proposed ever, then this value has to be chosen.</li>
<li>This implies that an acceptor must accept the first proposal that it receives.</li>
<li>Conclusion: <strong>An acceptor must accept the first proposal that it receives. [P1]</strong></li>
</ul>
</li>
<li>Case 2: multiple proposed value - multiple values are proposed from proposers.<ul>
<li>This raises a problem. With multiple proposed value, it is possible no single value is accepted by the quorum. So it’s possible consensus will never be reached, without additional constraints.<ul>
<li>A sample case that consensus never reached:<ul>
<li>2 processes P1 and P2. P1 proposes V1 and P2 proposes V2.</li>
<li>V1 is accepted by P1 (or P2), V2 is accepted by P2 (or P1), because an acceptor must accept the first value it receives.</li>
<li>No proposal would ever get majority in such case.</li>
</ul>
</li>
</ul>
</li>
<li>To address the problem, where P1 must be true and yet a consensus has to be reached somehow, one additional constraint should be added:<ul>
<li><strong>An acceptor must be allowed to accept more than one proposal.</strong></li>
<li>Since there are multiple proposals now, there is a need to distinguish between different proposals. The mechanism that serves this purpose is to use <strong>proposal number</strong></li>
<li>A proposal number is a number attach to each proposal. How this is implemented depends on actual implementation.</li>
</ul>
</li>
<li>With the new constraint that an accept can accept more than one proposal, there is a <strong>new problem: we may end up with multiple values chosen</strong>; this violates the safety property.<ul>
<li>A sample case multiple values are chosen:<ul>
<li>5 processes, P1 through P5.</li>
<li>P1 proposes V1, P5 proposes V5.</li>
<li>V1 is accepted by P1, P2, and P3.</li>
<li>Assume there is a delay, and then V5 arrives to acceptor P3.</li>
<li>Since an acceptor can accept multiple values, P3 is happily accepting V5.</li>
<li>Meanwhile, V5 is accepted by P4, and P5. (It could also be accepted by P1 and P2 of course.)</li>
<li>The end result is no consensus reached: V1 and V5 are both gaining a majority.</li>
</ul>
</li>
<li>To satisfy safety property of only a single value is chosen, an additional constraint should be added.</li>
</ul>
</li>
<li><strong>If a proposal with value v is chosen, then every higher numbered proposal that is chosen has value v. [P2]</strong><ul>
<li>Because proposals are ordered (use a proposal number), this ensures only a single value is chosen.</li>
<li>To be chosen a proposal must be accepted by at least one acceptor. So, we can satisfy P2 by satisfying:</li>
<li><strong>If a proposal with value v is chosen, then every higher numbered proposal accepted by any acceptor has value v.</strong></li>
</ul>
</li>
<li>Constraint of P2 introduces a new problem that requires a strengthened constraint:<ul>
<li>Now assume a value V is chosen already. Because chosen a value only requires a majority of acceptors, it is possible that the proposal WRT the chosen value never reached one or more acceptors.</li>
<li>Because an acceptor can be a proposer, from one of those unreached acceptors, one acceptor (now a proposer) may propose a new value with a higher proposal number.</li>
<li>Because of P1, an acceptor must accept the first proposal it receives. So an acceptor that receives this new proposal which contains a different value than the chosen value must be accepted.</li>
<li>This violates P2a, so we need add more constraints.</li>
</ul>
</li>
<li><strong>Maintaining both P1 and P2a requires strengthening P2a to P2b: If a proposal with value v is chosen, then every higher numbered proposal issued by any proposer has value v. </strong><ul>
<li>This means before a proposer proposes a value, it has to look around and see if there is any exiting chosen value.</li>
<li>But how to satisfy this new constraint P2b?</li>
</ul>
</li>
<li>We can satisfy P2b by maintaining invariance of P2c.</li>
<li><strong>For any v and n, if a proposal with value v and number n is issued,<br>  then there is a set S consisting of a majority of acceptors such that<br>  either (a) no acceptor in S has accepted any proposal numbered less<br>  than n, or (b) v is the value of the highest-numbered proposal among<br>  all proposals numbered less than n accepted by the acceptors in S. [P2c]</strong></li>
<li>To satisfy P2c, now comes to my favorite part of the paper:<ul>
<li><strong>To maintain the invariance of P2c<br>  , a proposer that wants to issue a proposal<br>  numbered n must learn the highest-numbered proposal with number<br>  less than n, if any, that has been or will be accepted by each acceptor in<br>  some majority of acceptors. Learning about proposals already accepted is<br>  easy enough; predicting future acceptances is hard. Instead of trying to predict<br>  the future, the proposer controls it by extracting a promise that there<br>  won’t be any such acceptances. In other words, the proposer requests that<br>  the acceptors not accept any more proposals numbered less than n.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Proposer-Algorithm"><a href="#Proposer-Algorithm" class="headerlink" title="Proposer Algorithm"></a>Proposer Algorithm</h1><ul>
<li>Two phases: prepare and propose.</li>
<li>Prepare: A proposer chooses a new proposal number n and sends a request to each member of some set of acceptors, asking it to respond with:<ul>
<li>a. A promise never again to accept a proposal numbered less than n, and</li>
<li>b. The proposal with the highest number less than n that it has accepted, if any.</li>
</ul>
</li>
<li>Propose: If the proposer receives the requested responses from a majority of the acceptors, then it can issue a proposal with number n and value v, where v is the value of the highest-numbered proposal among the responses, or is any value selected by the proposer if the responders reported no proposals.</li>
</ul>
<h1 id="Acceptor-Algorithm"><a href="#Acceptor-Algorithm" class="headerlink" title="Acceptor Algorithm"></a>Acceptor Algorithm</h1><ul>
<li>An acceptor can ignore any request without compromising safety.</li>
<li>We need to say only when it is allowed to respond to a request.</li>
<li>It can always respond to a prepare request.</li>
<li>It can respond to an accept request, accepting the proposal, iff it has not promised not to.</li>
<li>Optimization: acceptor can ignore prepare requests which have lower proposal number, and also proposals that it already accepted.</li>
</ul>
<h1 id="Learning-a-Chosen-Value"><a href="#Learning-a-Chosen-Value" class="headerlink" title="Learning a Chosen Value"></a>Learning a Chosen Value</h1><ul>
<li>Use distinguished learners to optimize from product of number of learners and acceptors, to the sum of number of acceptors and learners.</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><ul>
<li>Single Paxos not so useful, as it only reaches consensus on a single value.</li>
<li>Multiple instances of Paxos - called multi-paxos allows consensus on a set of values. Very useful for building RSM (replicated state machine) systems. </li>
</ul>
]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Paper Digest </tag>
            
            <tag> Consensus Protocol </tag>
            
            <tag> Paxos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.2 Snail Trail]]></title>
      <url>http://lianghan.org/2017/04/21/2017-04-21-USACO-SnailTrail/</url>
      <content type="html"><![CDATA[<p>The problem is to find out the longest possible move path under certain constraints. Not sure if there are better methods, but a brutal force DFS just works with the given test data.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, B, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; grid;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_grid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= N &amp;&amp; y &lt;= N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next_dir(<span class="keyword">int</span> d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span> || d == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    ans = <span class="built_in">std</span>::max(ans, step);</span><br><span class="line">    <span class="keyword">int</span> xx = x + dx[d], yy = y + dy[d];</span><br><span class="line">    <span class="keyword">if</span> (on_grid(xx, yy) &amp;&amp; grid[xx][yy] != <span class="string">'#'</span>) &#123;</span><br><span class="line">        move(xx, yy, d, step + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> dirs = next_dir(d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">            xx = x + dx[dir]; yy = y + dy[dir];</span><br><span class="line">            <span class="keyword">if</span> (on_grid(xx, yy) &amp;&amp; grid[xx][yy] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                move(xx, yy, dir, step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"snail.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"snail.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; B;</span><br><span class="line">    grid = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(N + <span class="number">1</span>, <span class="string">'.'</span>));</span><br><span class="line">    visited = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> col; <span class="keyword">int</span> row;</span><br><span class="line">        fin &gt;&gt; col &gt;&gt; row;</span><br><span class="line">        grid[row][col - <span class="string">'A'</span> + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    move(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    move(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Existential Consistency - Measuring and Understanding Consistency at Facebook]]></title>
      <url>http://lianghan.org/2017/03/27/2017-03-27-Existential%20Consistency/</url>
      <content type="html"><![CDATA[<p>Paper digest - <a href="http://sigops.org/sosp/sosp15/current/2015-Monterey/240-lu-online.pdf" target="_blank" rel="noopener">Existential Consistency: Measuring and Understanding Consistency at Facebook </a></p>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>Provides real world insights on how to quantify trade offs between performance and consistency wrt replicated storage systems.</li>
<li>Describes a practical consistency monitoring system that tracks a new consistency metric ideally suited for health monitoring.</li>
</ul>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul>
<li>Stronger consistency implementation increases latency and/or decrease throughput.</li>
<li>Eventual consistency (usually) provides good latency and/or throughput at larger scale. However there are drawbacks:<ul>
<li>User visible anomalies: e.g. out order comments on social network post.</li>
<li>Programming complexity: complicated cases to reason about on weaker consistency model.</li>
</ul>
</li>
<li>So lots of recent work focus on providing stronger consistency models to overcome drawbacks of a weaker consistency model.</li>
<li>But, not much work is done to quantify the trade offs, which this paper addresses.</li>
<li>Within a cluster, per-object sequential and read-afterwrite consistency are provided. </li>
<li>Across the entire system, eventual consistency is provided.</li>
<li>Consistency is measured by running offline consistency checker (that checks various consistency models) on a logs that gathers random samples of social graph system.</li>
</ul>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><ul>
<li>Facebook’s replicated storage<ul>
<li>Data model is directed graph.</li>
<li>User data is persistent in relational database, which is sharded, geo-replicated.</li>
<li>Each shard has a single maser region. Replication to slave region is async.</li>
<li>Database is cached (two-level) for the full replica per region. Root / leaf caches. Reads served by leaf cache.</li>
<li>Write path to cache: invalidation is async.</li>
</ul>
</li>
<li>Consistency models:<ul>
<li>The usual ones, mentioned again (linearizability, sequential, per object sequential, read-after-write, eventual.)</li>
<li>Facebook’s consistency: per-object sequential consistency and read-after-write consistency within a cache, and eventual consistency across caches.</li>
<li>When user session spreads across multiple leaf caches (e.g. load balanced, or leaf cache failed): eventual consistency.</li>
</ul>
</li>
</ul>
<h1 id="Principled-Consistency-Analysis"><a href="#Principled-Consistency-Analysis" class="headerlink" title="Principled Consistency Analysis"></a>Principled Consistency Analysis</h1><ul>
<li>Trace<ul>
<li>Collect trace to identify violation of consistency models.</li>
<li>Trace only requests to a subset of vertices / edges stored in system for practical feasibility / avoid overhead.</li>
<li>Requests are logged on the web server that issuing the requests.</li>
</ul>
</li>
<li>Deal with clock skew<ul>
<li>Solved by adding offsets (We account for this clock skew by expanding the invocation time and response time, i.e., we subtract 35 ms from all invocation times and add 35 ms to all response times.)</li>
</ul>
</li>
<li>Deal with losing logs<ul>
<li>Use a secondary trace from Wormhole system which is lossy as well but combined with the writes from both trace has good coverage.</li>
</ul>
</li>
<li>The checker<ul>
<li>Anomaly Checkers<ul>
<li>Maintaining a directed graph.</li>
<li>Vertices represent the state of an object.</li>
<li>Edges represent the constraints on the ordering.</li>
<li>Check state transition order observed by reads is consistent with these constraints.</li>
</ul>
</li>
<li>Linearizability Checker<ul>
<li>Model operation as vertices, edges as constraints.</li>
<li>Check cycles.</li>
<li>Linearizability requires that there exists a total order that is legal.</li>
<li>Merging read vertices into the write vertices they observe requires matching reads to write.</li>
</ul>
</li>
<li>Per-Object Sequential and Read-After-Write Checkers<ul>
<li>As an add on of linearlizability checker which is superset of sequential / RAW consistency.</li>
</ul>
</li>
</ul>
</li>
<li>Directions on future research into systems with stronger consistency<ul>
<li>Build system were non-anomalous types have negligible overhead or</li>
<li>Provide stronger consistency for a small subset of a larger system. </li>
<li>While the latter would not prevent all anomalies, it would allow incremental deployment of these systems and significantly reduce the rate of anomalies. </li>
<li>Interestingly, such a subsystem that does provide linearizability is used within Facebook for a small set of object types, e.g., passwords.</li>
</ul>
</li>
</ul>
<h1 id="Practical-Consistency-Analysis"><a href="#Practical-Consistency-Analysis" class="headerlink" title="Practical Consistency Analysis"></a>Practical Consistency Analysis</h1><ul>
<li>Why - need real time (for monitoring) instead of principal analysis (can be only done offline).</li>
<li>φ-consistency</li>
</ul>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul>
<li>TAO is highly consistent.</li>
<li>There were anomalies under all of the consistency models we studied. </li>
</ul>
]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Distributed System </tag>
            
            <tag> Paper Digest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.1 Musical Theme]]></title>
      <url>http://lianghan.org/2017/03/25/2017-03-25-USACO-MusicalTheme/</url>
      <content type="html"><![CDATA[<p>If there is no constraint of the “transpose” (Transposed means that a constant positive or negative value is added to every note value in the theme subsequence), then the problem is obviously a string search problem. How to deal with transpose when doing string search?</p>
<ul>
<li>The property of transpose imply that if sequence A is a transpose of sequence B, then there must be that for every Ai, we have Ai + Diff = Bi. Similarly, Ai+1 + Diff = Bi+1.</li>
<li>Now we have Ai+1 - Ai = Bi+1 - Bi. </li>
<li>So the problem can be reduced again to plain sub string search problem: we just need to transform the input to a diff sequence by having each element a diff between two adjacent elements.</li>
<li>For string search, use KMP so the time is linear.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; str, table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"theme.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"theme.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    str = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    table = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; cur;</span><br><span class="line">        str[i] = cur - prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    str[N] = prev * <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> from = N - <span class="number">5</span>; from &gt;= <span class="number">5</span>; --from) &#123;</span><br><span class="line">        <span class="built_in">std</span>::fill(table.begin(), table.end(), <span class="number">0</span>);</span><br><span class="line">        table[<span class="number">0</span>] = table[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from + <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = table[i - from];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[from + j]) &#123;</span><br><span class="line">               j = table[j];</span><br><span class="line">            &#125;</span><br><span class="line">            table[i - from + <span class="number">1</span>] = (str[i] == str[from + j]) ? j + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; from - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[from + j]) &#123;</span><br><span class="line">                j = table[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == str[from + j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans &lt; <span class="number">5</span> ? <span class="number">0</span> : ans) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; (ans &lt; <span class="number">5</span> ? <span class="number">0</span> : ans) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> KMP </tag>
            
            <tag> String Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.1 Starry Night]]></title>
      <url>http://lianghan.org/2017/03/17/2017-03-17-USACO-StarryNight/</url>
      <content type="html"><![CDATA[<p>The basic idea is to find each cluster, and then compare each cluster pair by pair. There are several sub problems to solve in this case:</p>
<ul>
<li><p>How to represent a cluster?<br>A cluster can be represented by the rectangle that covers the cluster together with the source grid (the sky). Each cluster has two key properties: the number of stars, and the covering rectangle, which can be represented by left/bottom and right/upper points.</p>
</li>
<li><p>How to find a cluster?<br>A cluster can be found by using flood fill algorithm against the sky.</p>
</li>
<li><p>How to compare two clusters?<br>Two clusters are obviously different if they contain different number of stars. For clusters contain same number of stars, a set of transforms need to be performed on one cluster then compare the transformed cluster with another cluster:</p>
<ul>
<li>Rotate clockwise 90 degree.</li>
<li>Rotate clockwise 180 degree.</li>
<li>Rotate clockwise 270 degree.</li>
<li>Rotate clockwise 360 degree.</li>
<li>Mirror the cluster then repeat.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R, C;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Cluster &#123;</span><br><span class="line">    <span class="keyword">int</span> min_x, min_y, max_x, max_y;</span><br><span class="line">    <span class="keyword">int</span> num_of_stars;</span><br><span class="line">    Cluster() : min_x(<span class="number">-1</span>), min_y(<span class="number">-1</span>), max_x(<span class="number">-1</span>), max_y(<span class="number">-1</span>), num_of_stars(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; Cluster;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Point &#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125; Point;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; sky;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt;&gt; mark;</span><br><span class="line"><span class="built_in">vector</span>&lt;Cluster&gt; clusters(<span class="number">505</span>);</span><br><span class="line"><span class="keyword">char</span> p[<span class="number">550</span>];</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate_bound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    clusters[idx].min_x = clusters[idx].min_x == <span class="number">-1</span> ? x : <span class="built_in">std</span>::min(x, clusters[idx].min_x);</span><br><span class="line">    clusters[idx].min_y = clusters[idx].min_y == <span class="number">-1</span> ? y : <span class="built_in">std</span>::min(y, clusters[idx].min_y);</span><br><span class="line">    clusters[idx].max_x = clusters[idx].max_x == <span class="number">-1</span> ? x : <span class="built_in">std</span>::max(x, clusters[idx].max_x);</span><br><span class="line">    clusters[idx].max_y = clusters[idx].max_y == <span class="number">-1</span> ? y : <span class="built_in">std</span>::max(y, clusters[idx].max_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flood_fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_of_stars = <span class="number">1</span>;</span><br><span class="line">    mark[x][y] = index;</span><br><span class="line">    calculate_bound(x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;Point&gt; q;</span><br><span class="line">    q.push(Point(x, y));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> xx = p.x + i, yy = p.y + j;</span><br><span class="line">                <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= R || yy &lt; <span class="number">0</span> || yy &gt;= C) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (sky[xx][yy] != <span class="string">'1'</span> || mark[xx][yy] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ++num_of_stars;</span><br><span class="line">                mark[xx][yy] = index;</span><br><span class="line">                calculate_bound(xx, yy);</span><br><span class="line">                q.push(Point(xx, yy));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num_of_stars;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rotate 90 degree clockwise.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;cluster, <span class="keyword">int</span> lx, <span class="keyword">int</span> ly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = (<span class="keyword">int</span>)cluster.size(), cols = (<span class="keyword">int</span>)cluster[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; t(rows, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(cols));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lx; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ly; ++j) &#123;</span><br><span class="line">            t[j][lx - i - <span class="number">1</span>] = cluster[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ly; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lx; ++j) &#123;</span><br><span class="line">            cluster[i][j] = t[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mirror</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;cluster, <span class="keyword">int</span> lx, <span class="keyword">int</span> ly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lx; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ly/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            swap(cluster[i][j], cluster[i][ly - <span class="number">1</span> - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; cluster, <span class="keyword">int</span> lx, <span class="keyword">int</span> ly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lx; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ly; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = clusters[index].min_x + i,</span><br><span class="line">                yy = clusters[index].min_y + j;</span><br><span class="line">            <span class="keyword">if</span>(mark[xx][yy] == index &amp;&amp; cluster[i][j] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_two_cluster_same</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clusters[a].num_of_stars != clusters[b].num_of_stars) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ax = clusters[a].max_x - clusters[a].min_x + <span class="number">1</span>,</span><br><span class="line">        ay = clusters[a].max_y - clusters[a].min_y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lx = clusters[b].max_x - clusters[b].min_x + <span class="number">1</span>,</span><br><span class="line">        ly = clusters[b].max_y - clusters[b].min_y + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; tmp(<span class="number">110</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(<span class="number">110</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lx; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ly; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = i + clusters[b].min_x, yy = j + clusters[b].min_y;</span><br><span class="line">            tmp[i][j] = sky[xx][yy];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ax == lx &amp;&amp; ay == ly &amp;&amp; match(a, tmp, lx, ly)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        rotate(tmp, lx, ly);</span><br><span class="line">        swap(lx, ly);</span><br><span class="line">        <span class="keyword">if</span>(ax == lx &amp;&amp; ay == ly &amp;&amp; match(a, tmp, lx, ly)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mirror(tmp, lx, ly);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        rotate(tmp, lx, ly);</span><br><span class="line">        swap(lx, ly);</span><br><span class="line">        <span class="keyword">if</span>(ax == lx &amp;&amp; ay == ly &amp;&amp; match(a, tmp, lx, ly)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"starry.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"starry.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    fin &gt;&gt; C &gt;&gt; R;</span><br><span class="line">    sky = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;(R, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(C));</span><br><span class="line">    mark = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt;&gt;(R, <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt;(C, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">            fin &gt;&gt; sky[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sky[i][j] == <span class="string">'1'</span> &amp;&amp; mark[i][j] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num_of_stars = flood_fill(i, j, idx);</span><br><span class="line">                clusters[idx].num_of_stars = num_of_stars;</span><br><span class="line">                ++idx;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; idx - <span class="number">1</span> &lt;&lt; <span class="string">" : stars "</span> &lt;&lt; num_of_stars &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; ans = sky;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(is_two_cluster_same(i, j)) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" and "</span> &lt;&lt; j &lt;&lt; <span class="string">" same!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">-1</span>)  &#123;</span><br><span class="line">            p[i] = p[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = clusters[i].min_x; ii &lt;= clusters[i].max_x; ++ii) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> jj = clusters[i].min_y; jj &lt;= clusters[i].max_y; ++jj) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mark[ii][jj] == i) &#123;</span><br><span class="line">                   ans[ii][jj] = p[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">            fout &lt;&lt; ans[i][j];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flood Fill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 5.1 Fencing The Cows]]></title>
      <url>http://lianghan.org/2017/03/05/2017-03-05-USACO-FencingTheCows/</url>
      <content type="html"><![CDATA[<p>The answer is the perimeter of the convex hull of all the grazing points. Use <a href>Graham Scan</a> to calculate the convex hull, because it’s efficient and easy to implement:</p>
<ul>
<li>First, pick a point that has smallest x coordinate. Use y coordinate to break ties if necessary. Let’s call this point the base point.</li>
<li>Then iterate for the rest of the points, calculate the polar angle between the current point and the base point. </li>
<li>Now we get all points and their polar angles with respect to the base point, sort these points based on polar angle.</li>
<li>Walk through the sorted points and make sure a new point only appear in the counter clock wise direction (turn left) of the current point. Add the new point to the result, and drop old points if necessary.</li>
<li>We should now have a convex hull point sets available. Calculate the perimeter is now trivial.</li>
</ul>
<p>This implementation also dealt with degenerated case where the points are co-linear. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">struct</span> Point &#123;</span><br><span class="line">    <span class="keyword">double</span> x; <span class="keyword">double</span> y; <span class="keyword">double</span> pa <span class="comment">/* Polar Angle with reference point. */</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; points;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point &amp;a, Point &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ccw</span><span class="params">(Point &amp;a, Point &amp;b, Point &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area = (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);</span><br><span class="line">    <span class="keyword">if</span> (area &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">graham_scan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Point&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push(points[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">stack</span>.push(points[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">stack</span>.push(points[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i++) &#123;</span><br><span class="line">        Point top = <span class="built_in">stack</span>.top();</span><br><span class="line">        <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">while</span> (!ccw(<span class="built_in">stack</span>.top(), top, points[i]))   &#123;</span><br><span class="line">            top = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(top);</span><br><span class="line">        <span class="built_in">stack</span>.push(points[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Save the last point to close the hull with p0.</span></span><br><span class="line">    Point p1 = <span class="built_in">stack</span>.top(); <span class="built_in">stack</span>.pop();</span><br><span class="line">    Point cur = p1;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">        ans += dist(cur, <span class="built_in">stack</span>.top());</span><br><span class="line">        cur = <span class="built_in">stack</span>.top(); <span class="built_in">stack</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    ans += dist(cur, p1);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fc.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fc.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    points = <span class="built_in">vector</span>&lt;Point&gt;(N);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; points[i].x &gt;&gt; points[i].y;</span><br><span class="line">        <span class="keyword">if</span> (points[i].x &lt; points[idx].x) &#123;</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(points[i].x - points[idx].x) &lt;</span><br><span class="line">                   <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::epsilon() &amp;&amp;</span><br><span class="line">                   points[i].y &lt; points[idx].y) &#123;</span><br><span class="line">            idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::swap(points[idx], points[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        points[i].pa = (points[i].y - points[<span class="number">0</span>].y) / dist(points[i], points[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(points.begin() + <span class="number">1</span>, points.end(), [] (<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.pa &lt; b.pa;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> ret = graham_scan();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>) &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>) &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Convex Hull </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZooKeeper Consistency Guarantees]]></title>
      <url>http://lianghan.org/2017/03/03/2017-03-03-ZooKeeper%20Consistency%20Guarantees/</url>
      <content type="html"><![CDATA[<p>There are many consistency models out there, from stronger ones to weaker ones. What consistency model best describes ZooKeeper? </p>
<h1 id="Consistency-Models"><a href="#Consistency-Models" class="headerlink" title="Consistency Models"></a>Consistency Models</h1><p>It is useful to think consistency models from two perspectives: server side (data centric) and client side (client centric), in particular in the context of ZooKeeper (or a general distributed storage system that is composed of clients and servers.).</p>
<ul>
<li>Data Centric Consistency Models<ul>
<li>Strict Consistency<br>The strongest consistency model for distributed systems. All changes to system state are required to populate to all replicas instantly, so any write should be immediately visible to all parts of the system (both server and client). More formally, any read on a data item should returns a value corresponding to the result of the most recent write on this item. This system model is not possible to implement on top of the current hardware for distributed systems, because it requires a global clock (for strict ordering), and zero latency and infinite bandwidth for communications between different parts of the system. A closer resemble of a system that satisfy this model is a single machine where latency / bandwidth / clock constraints are almost satisfied (even on a single machine, achieve strict consistency is hard due to cache hierarchies and latencies of memory / cache access.).<br>Because of the impossibilities of implementation, a less strict model called atomic register was proposed (from Leslie Lamport), and a particular version of this model is known as linearizable consistency.<ul>
<li>Linearizable consistency<br>Linearizable consistency model, comparing to strict consistency model, takes the latency into account, so it does not require writes to an item being visible instantly. The real constraint of this consistency model is that the operations can’t interleave, can’t be reordered, and the sequence of writes are visible in strict global ordering as these writes were issued. It is a recency guarantee such that if a change to the value is visible to one client, the change has to be visible to all clients. A client can’t read old value if some other clients have seen the new value. The change history is linearized such that all operations appear to have executed atomically in the order that is consistent with the global real time ordering of operations. One nice property of linearizable consistency is that it composes - which is an extremely useful property for reasoning about the behavior of concurrent operations in distributed systems.</li>
</ul>
</li>
<li>Sequential Consistency<br>Sequential consistency is a weaker consistency model comparing to linearizable consistency. It requires all operations appear to have executed atomically in some order, and the key constraint is that this order that is visible to all part of the system has to be consistent. However, this order does not have to be consistent with the ordering of the original operations. Because of this, the system is free to reorder the executions of the operations, it just need to satisfy a globally consistent visible orderings of operations for all clients. That is the key difference between linearizable consistency model. Also, sequential consistency does not compose as linearizable consistency does.</li>
<li>Causal Consistency<br>Causal consistency is a even weaker model than sequential consistency. It only requires causally related writes must be visible by all processes, while none causally related writes are free to executed in any order. This violates the constraint for sequential consistency (all writes must converge to the same order), so it is weaker model than sequential consistency. Sequential consistency is thus by definition implicitly causal consistency as well.</li>
<li>Eventual Consistency<br>The weakest consistency model, ever. Distributed systems adopt this model makes a lot things harder, though it is good trade off to make in certain use case. Eventual consistency is more about a liveness property (that values converge finally), so it is usually trivially satisfiable in most systems.</li>
</ul>
</li>
<li>Client Centric Consistency Models:<ul>
<li>Monotonic reads<br>Once read, subsequent reads on that data items return same or more recent values.</li>
<li>Monotonic writes<br>A write must be propagated to all replicas before a successive write by the same process; writes from same process are processed in same order.</li>
<li>Read your writes<br>read(x) always returns write(x) by that process.</li>
<li>Writes follow reads<br>write(x) following read(x) will take place on same or more recent version of x.</li>
</ul>
</li>
</ul>
<p>With all these said, what consistency model ZooKeeper fit in?</p>
<ul>
<li>Linearizable consistency: ZooKeeper does not guarantee linearizable consistency. Two ZooKeeper clients can see two different values of the same data item (value of znode) at the same time - e.g. one client can see an old value while the other client can see the new value. Even with the sync command, which stalls the write processors, it is still possible that a client miss a value of the write (e.g. after sync executed finished but before client gets the updated value, another client issuing a new write that update the value again.). Also due to potential network delays it is hard to guarantee that operations on all clients happen on same order globally.</li>
<li>Sequential consistency: this is what ZooKeeper guarantees. Sequential consistency does not care about exact ordering of operations and ZooKeeper can reorder operations, but all the operations ordering will converge to a single globally consistent ordering that is visible to all clients (eventually, or near instantly if client uses sync command.).</li>
<li>Causal consistency: because ZooKeeper satisfies sequential consistency, it also satisfy causal consistency. More specifically, since causal consistency is a stronger guarantee than read your writes and monotonic reads, those properties are also guaranteed. </li>
<li>Monotonic reads / Read your writes: as discussed, these are trivially satisfied with stronger guarantee. Note in practice there are a lot of corner cases to consider to satisfy these properties from a client point of view, for example what if a client disconnect and connect to a server node where it does not have latest values for the same znode client has seen before (that this server lags behind leader, which is normal because ZooKeeper only requires a quorum of servers in sync with leader). This and similar cases are handled by the guarantees of ZooKeeper session which provides some strong guarantees with regards to how client and server could interact (will describe this in a future post). </li>
<li>Monotonic writes: ZooKeeper does not satisfy this because a write is only required to be replicated to a quorum of servers.</li>
<li>Also a side note is there is a long pending bug of the sync operation - it is not a quorum operation so the guarantee it provides only apply if the client is connecting to leader.. this needs to be fixed, soon.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.4 Frame Up]]></title>
      <url>http://lianghan.org/2017/02/22/2017-02-22-USACO-FrameUp/</url>
      <content type="html"><![CDATA[<p>The problem description mentions:</p>
<ul>
<li>It is possible to see at least one part of each of the four sides of a frame.</li>
</ul>
<p>With the information of the position of each side, we can calculate the position of each frame, as each frame can be determined by its left/down and right/up (or left/up right/down) corner. The relationship of frame B stacks on top of frame A can be modeled as a directed graph where A and B are vertices and there is an edge from A to B. Then do a topological sort pass to generate the result. Note it requires all possible results of topological sort, which requires back tracking with DFS. A good reference implementation of such algorithm can be found <a href="http://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/" target="_blank" rel="noopener">here</a>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H, W;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min_x(<span class="number">30</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min_y(<span class="number">30</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_x(<span class="number">30</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_y(<span class="number">30</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; exist(<span class="number">30</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">char</span> grid[<span class="number">33</span>][<span class="number">33</span>]; <span class="comment">// processed input.</span></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">30</span>][<span class="number">30</span>]; <span class="comment">// matrix representation of graph.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in_degree(<span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"frameup.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"frameup.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">30</span>], nans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; H &gt;&gt; W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; H; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; grid[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; W; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; grid[i][j];</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = grid[i][j] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span>(min_x[v] == <span class="number">-1</span> || min_x[v]&gt;i) min_x[v] = i;</span><br><span class="line">            <span class="keyword">if</span>(min_y[v] == <span class="number">-1</span> || min_y[v]&gt;j) min_y[v] = j;</span><br><span class="line">            <span class="keyword">if</span>(max_x[v] == <span class="number">-1</span> || max_x[v]&lt;i) max_x[v] = i;</span><br><span class="line">            <span class="keyword">if</span>(max_y[v] == <span class="number">-1</span> || max_y[v]&lt;j) max_y[v] = j;</span><br><span class="line">            exist[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; <span class="number">26</span>; ++u) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!exist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = min_y[u]; y &lt;= max_y[u]; ++y) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = grid[min_x[u]][y] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span>(v != u &amp;&amp; !g[u][v]) &#123;</span><br><span class="line">                g[u][v] = <span class="number">1</span>; ++in_degree[v];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            v = grid[max_x[u]][y] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span>(v != u &amp;&amp; !g[u][v]) &#123;</span><br><span class="line">                g[u][v] = <span class="number">1</span>; ++in_degree[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = min_x[u]; x &lt;= max_x[u]; ++x) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = grid[x][min_y[u]] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span>(v != u &amp;&amp; !g[u][v]) &#123;</span><br><span class="line">                g[u][v] = <span class="number">1</span>; ++in_degree[v];</span><br><span class="line">            &#125;</span><br><span class="line">            v = grid[x][max_y[u]] - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span>(v != u &amp;&amp; !g[u][v]) &#123;</span><br><span class="line">                g[u][v] = <span class="number">1</span>; ++in_degree[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS that generates all topological sorts in alphabetic order.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> all_used = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(exist[i]) &#123;</span><br><span class="line">            all_used = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(all_used) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nans; ++i) &#123;</span><br><span class="line">            fout &lt;&lt; (<span class="keyword">char</span>)(ans[i] + <span class="string">'A'</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)(ans[i] + <span class="string">'A'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fout &lt;&lt; <span class="built_in">endl</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; <span class="number">26</span>; ++u) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!exist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (in_degree[u]) <span class="keyword">continue</span>;</span><br><span class="line">        exist[u] = <span class="literal">false</span>;</span><br><span class="line">        ans[nans++] = u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="number">26</span>; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[u][v]) --in_degree[v];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs();</span><br><span class="line">        exist[u] = <span class="literal">true</span>;</span><br><span class="line">        nans--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; <span class="number">26</span>; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[u][v]) in_degree[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    buildGraph();</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtrack </tag>
            
            <tag> Topological Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.4 Pollutant Control]]></title>
      <url>http://lianghan.org/2017/02/19/2017-02-19-USACO-PollutantControl/</url>
      <content type="html"><![CDATA[<p>It is an obvious max flow min cut problem. The nasty part of this problems is:</p>
<ul>
<li>There might be multiple routes between same warehouses, so the graph might contain multiple edges between two vertices.</li>
<li>The output requires to print the routes under certain constraints, instead of just asking about the min cut cost.</li>
</ul>
<p>The idea is:</p>
<ul>
<li>Find the max flow first. The cost of the max flow must be min cut.</li>
<li>Sort all edges in cost descending order. Then iterate through the sorted edges, do two things:<ul>
<li>Remove this edge from the graph temporarily, calculate the maximum flow value. If the diff between the calculated maximum flow value and the original max flow value (the value calculated without removing the edge from the graph) is the capacity of the edge, then this edge must be in the min cut.</li>
<li>If an edge is in a min cut, remove this edge from the graph, and repeat, until we get all edges.</li>
</ul>
</li>
</ul>
<p>This code is a simple modification of the <a href="http://lianghan.org/2017/01/04/2017-01-04-USACO-DrainageDitches.h/">Drainage Ditches Problem Solution</a> that fits this problem, however it does not pass all test data because it does not deal with multiple edges connecting same two vertices. Will post another solution soon. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Si, Ei, Ci;</span><br><span class="line"><span class="keyword">struct</span> Edge &#123;</span><br><span class="line">    <span class="keyword">int</span> to, cap, rev, index;</span><br><span class="line">    Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> rev, <span class="keyword">int</span> index) :</span><br><span class="line">    to(to), cap(cap), rev(rev), index(index) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; graphCopy;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge*&gt; edges;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    graph[from].emplace_back(Edge(to, cap, (<span class="keyword">int</span>)graph[to].size(), index));</span><br><span class="line">    graph[to].emplace_back(Edge(from, <span class="number">0</span>, (<span class="keyword">int</span>)graph[from].size() - <span class="number">1</span>, index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ford–Fulkerson</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == t)</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph[v].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;e = graph[v][i];</span><br><span class="line">        <span class="keyword">if</span> (visited[e.to] || e.cap &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> d = dfs(e.to, t, <span class="built_in">std</span>::min(f, e.cap));</span><br><span class="line">        <span class="keyword">if</span> (d &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        e.cap -= d;</span><br><span class="line">        graph[e.to][e.rev].cap += d;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">int</span> f = dfs(s, t, INT_MAX);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line">        flow += f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"milk6.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"milk6.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    fin &gt;&gt; N <span class="comment">/* warehouses - vertices */</span> &gt;&gt; M <span class="comment">/* trucks - edges */</span>;</span><br><span class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;Edge&gt;());</span><br><span class="line">    </span><br><span class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; Si &gt;&gt; Ei &gt;&gt; Ci;</span><br><span class="line">        addEdge(Si, Ei, Ci, i);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; Si &lt;&lt; " " &lt;&lt; Ei &lt;&lt; " " &lt;&lt; Ci &lt;&lt; " " &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge.cap == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            edges.emplace_back(&amp;edge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(edges.begin(), edges.end(), [] (Edge *e1, <span class="keyword">const</span> Edge *e2) &#123;</span><br><span class="line">        <span class="keyword">return</span> e1-&gt;cap &gt; e2-&gt;cap;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    graphCopy = graph;</span><br><span class="line">    <span class="keyword">int</span> ans = maxFlow(<span class="number">1</span>, N);</span><br><span class="line">    graph = graphCopy;</span><br><span class="line">    <span class="keyword">int</span> total = ans;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "cap : " &lt;&lt; edges[i]-&gt;cap &lt;&lt; "; index : " &lt;&lt; edges[i]-&gt;index &lt;&lt; endl;</span></span><br><span class="line">        graphCopy = graph;</span><br><span class="line">        <span class="keyword">int</span> cap = edges[i]-&gt;cap;</span><br><span class="line">        edges[i]-&gt;cap -= cap;</span><br><span class="line">        <span class="keyword">int</span> flow = maxFlow(<span class="number">1</span>, N);</span><br><span class="line">        <span class="keyword">if</span> (ans - flow == cap) &#123;</span><br><span class="line">            ret.push_back(edges[i]-&gt;index);</span><br><span class="line">            graph = graphCopy;</span><br><span class="line">            ans = flow;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            graph = graphCopy;</span><br><span class="line">            edges[i]-&gt;cap += cap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fout &lt;&lt; total - ans &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : ret) &#123;</span><br><span class="line">        fout &lt;&lt; val + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph Theory </tag>
            
            <tag> Ford-Fulkerson </tag>
            
            <tag> Network Flow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dynamo, Amazon’s Highly Available Key-value Store]]></title>
      <url>http://lianghan.org/2017/02/11/2017-02-11-DynamoPaper/</url>
      <content type="html"><![CDATA[<p>Paper digest - <a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">Dynamo: Amazon’s Highly Available Key-value Store </a></p>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>A highly available key-value storage system that manages state of Amazon services.</li>
<li>Reliability at massive scale, provide an “always-on” experience.</li>
</ul>
<h1 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h1><ul>
<li><p>Query Model: simple read and write operations to objects (relatively small, usually less than 1MB) that is uniquely identified by a key. </p>
</li>
<li><p>ACID (Atomicity, Consistency, Isolation, Durability) : weak consistency, no isolation, only single key update.</p>
</li>
<li><p>Efficiency: </p>
<ul>
<li>Function on a commodity hardware infrastructure.</li>
<li>Strict latency requirements and SLA.</li>
<li>Configurable to achieve customizable latency and throughput requirements.</li>
</ul>
</li>
<li><p>Operation and Security:</p>
<ul>
<li>No authentication and authorization (operating in non-hostile environment). </li>
<li>Scale up (each service uses its distinct instance of Dynamo).</li>
</ul>
</li>
<li><p>SLA:</p>
<ul>
<li>Traditional SLA metrics (average, median and expected variance) are not good enough to build a system where all customers have a good experience.</li>
<li>SLAs are expressed and measured at the 99.9th percentile of the distribution. Choose 99.9 for cost effective.</li>
</ul>
</li>
</ul>
<h1 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h1><ul>
<li>Favor availability over consistency by using optimistic replication techniques.</li>
<li>Optimistic replication introduces conflict. Conflict resolution introduces two problems: when to resolve them and who resolves them.<ul>
<li>When to resolve:<ul>
<li>Write time: writes may be rejected if the data store cannot reach all the replicas at a given time. This leads to poor user experience.</li>
<li>Read time: Dynamo targets the design space of an “always write-able” data store. So conflicts are resolved at read time.</li>
</ul>
</li>
<li>Who to perform resolve:<ul>
<li>Configurable.</li>
<li>System level resolution: last write wins.</li>
<li>Application level resolution: interactive guided merge conflicts, etc.</li>
</ul>
</li>
</ul>
</li>
<li>Other design considerations: Incremental scalability, Symmetry, Decentralization, Heterogeneity.</li>
</ul>
<h1 id="System-Architecture"><a href="#System-Architecture" class="headerlink" title="System Architecture"></a>System Architecture</h1><ul>
<li>Partitioning: Consistent Hashing.</li>
<li>Replication: Replicated write protocol with configurable NWR parameters.</li>
<li>Conflict Resolution: Vector clock.</li>
<li>Temporary failures: Sloppy Quorum and hinted handoff.</li>
<li>Recovering from permanent failures: Merkle trees.</li>
<li>Membership and failure detection: Gossip-based membership protocol and failure detection. </li>
</ul>
<h1 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued."></a>To be continued.</h1>]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Distributed System </tag>
            
            <tag> Paper Digest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.4 Shuttle Puzzle]]></title>
      <url>http://lianghan.org/2017/02/03/2017-02-03-USACO-ShuttlePuzzle/</url>
      <content type="html"><![CDATA[<p>BFS with pruning with key observation that W can only moves to right, and B can only moves to left to satisfy the constraints of smallest lexicographic order. Also the judge has tight memory bounds, so decide state duplication needs to use hashing (i.e. if using a set<string> then memory will grow out of bounds for “large” test data set.).</string></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> State &#123;</span><br><span class="line">    <span class="keyword">int</span> op; <span class="comment">// index of the hole where next operation is going to happen.</span></span><br><span class="line">    <span class="keyword">struct</span> State *prev;</span><br><span class="line">    <span class="built_in">string</span> state;</span><br><span class="line">    <span class="keyword">int</span> empty; <span class="comment">// index of empty hole.</span></span><br><span class="line">    State(<span class="keyword">int</span> op, <span class="built_in">string</span> state, <span class="keyword">int</span> empty, State *prev) :</span><br><span class="line">    op(op), state(state), empty(empty), prev(prev) &#123;&#125;</span><br><span class="line">&#125; State;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;State*&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;State*&gt; sp;</span><br><span class="line"><span class="built_in">string</span> target;</span><br><span class="line"><span class="built_in">string</span> start;</span><br><span class="line">State *ss;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solution;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start = <span class="built_in">string</span>(<span class="number">2</span> * N + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">    target = <span class="built_in">string</span>(<span class="number">2</span> * N + <span class="number">1</span>, <span class="string">' '</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        start[i] = <span class="string">'W'</span>;</span><br><span class="line">        target[i] = <span class="string">'B'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N + <span class="number">1</span>; i &lt; <span class="number">2</span> * N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        start[i] = <span class="string">'B'</span>;</span><br><span class="line">        target[i] = <span class="string">'W'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ss = <span class="keyword">new</span> State(<span class="number">0</span>, start, N, <span class="literal">nullptr</span>);</span><br><span class="line">    q.push(ss);</span><br><span class="line">    sp.push_back(ss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> s = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;state == target) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"target state reached."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">while</span> (s) &#123;</span><br><span class="line">                solution.push_back(s-&gt;op);</span><br><span class="line">                s = s-&gt;prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> empty = s-&gt;empty;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// W_ : W move right</span></span><br><span class="line">        <span class="keyword">if</span> (empty &gt; <span class="number">0</span> &amp;&amp; s-&gt;state[empty - <span class="number">1</span>] == <span class="string">'W'</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = <span class="keyword">new</span> State(*s);</span><br><span class="line">            sp.push_back(next);</span><br><span class="line">            next-&gt;state[empty] = <span class="string">'W'</span>;</span><br><span class="line">            next-&gt;state[empty - <span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">            next-&gt;op = empty - <span class="number">1</span>;</span><br><span class="line">            next-&gt;prev = s;</span><br><span class="line">            next-&gt;empty--;</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">std</span>::hash&lt;<span class="built_in">string</span>&gt;&#123;&#125;(next-&gt;state);</span><br><span class="line">            <span class="keyword">if</span> (!visited.count(h)) &#123;</span><br><span class="line">                visited.insert(h);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// _B : B move left</span></span><br><span class="line">         <span class="keyword">if</span> (empty &lt; <span class="number">2</span> * N &amp;&amp; s-&gt;state[empty + <span class="number">1</span>] == <span class="string">'B'</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = <span class="keyword">new</span> State(*s);</span><br><span class="line">            sp.push_back(next);</span><br><span class="line">            next-&gt;state[empty] = <span class="string">'B'</span>;</span><br><span class="line">            next-&gt;state[empty + <span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">            next-&gt;op = empty + <span class="number">1</span>;</span><br><span class="line">            next-&gt;prev = s;</span><br><span class="line">            next-&gt;empty++;</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">std</span>::hash&lt;<span class="built_in">string</span>&gt;&#123;&#125;(next-&gt;state);</span><br><span class="line">            <span class="keyword">if</span> (!visited.count(h)) &#123;</span><br><span class="line">                visited.insert(h);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// WB_ : W jump right</span></span><br><span class="line">        <span class="keyword">if</span> (empty &gt; <span class="number">1</span> &amp;&amp; s-&gt;state[empty - <span class="number">2</span>] == <span class="string">'W'</span> &amp;&amp;</span><br><span class="line">            s-&gt;state[empty - <span class="number">1</span>] != <span class="string">'W'</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = <span class="keyword">new</span> State(*s);</span><br><span class="line">            sp.push_back(next);</span><br><span class="line">            next-&gt;state[empty] = <span class="string">'W'</span>;</span><br><span class="line">            next-&gt;state[empty - <span class="number">2</span>] = <span class="string">' '</span>;</span><br><span class="line">            next-&gt;op = empty - <span class="number">2</span>;</span><br><span class="line">            next-&gt;prev = s;</span><br><span class="line">            next-&gt;empty -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">std</span>::hash&lt;<span class="built_in">string</span>&gt;&#123;&#125;(next-&gt;state);</span><br><span class="line">            <span class="keyword">if</span> (!visited.count(h)) &#123;</span><br><span class="line">                visited.insert(h);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// _WB : B jump left</span></span><br><span class="line">        <span class="keyword">if</span> (empty &lt; <span class="number">2</span> * N - <span class="number">1</span> &amp;&amp; s-&gt;state[empty + <span class="number">2</span>] == <span class="string">'B'</span> &amp;&amp;</span><br><span class="line">            s-&gt;state[empty + <span class="number">1</span>] == <span class="string">'W'</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = <span class="keyword">new</span> State(*s);</span><br><span class="line">            sp.push_back(next);</span><br><span class="line">            next-&gt;state[empty] = <span class="string">'B'</span>;</span><br><span class="line">            next-&gt;state[empty + <span class="number">2</span>] = <span class="string">' '</span>;</span><br><span class="line">            next-&gt;op = empty + <span class="number">2</span>;</span><br><span class="line">            next-&gt;prev = s;</span><br><span class="line">            next-&gt;empty += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> h = <span class="built_in">std</span>::hash&lt;<span class="built_in">string</span>&gt;&#123;&#125;(next-&gt;state);</span><br><span class="line">            <span class="keyword">if</span> (!visited.count(h)) &#123;</span><br><span class="line">                visited.insert(h);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"shuttle.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"shuttle.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    setup();</span><br><span class="line">    bfs();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, size = (<span class="keyword">int</span>)solution.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solution[i] + <span class="number">1</span>;</span><br><span class="line">        fout &lt;&lt; solution[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">20</span> &amp;&amp; i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            fout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ptr : sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr; ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Why we need n >= 3f + 1 in Byzantine Fault Tolerance]]></title>
      <url>http://lianghan.org/2017/02/01/2017-02-01-ByzantineFaultTolerance/</url>
      <content type="html"><![CDATA[<p>In distributed systems where messages are asynchronous and failures can be Byzantine, we have to use at least n = 3f + 1 replicas in total to tolerate f faulty replicas. But why?</p>
<p>Consider this scenario: a client sends the same command to each of n servers and then waits for servers to execute the command and send back the result. If we have f byzantine servers, then up to f messages could not be trusted, or up to f servers could not responding. So the client must be able to function with n - f responses. In addition, as the messages are asynchronous, these messages could be delayed for an indefinite amount of time. So if there are f messages not received by client, then it could be also be that these f messages are not from faulty servers, but instead caused by networking partition or slow responding non-faulty servers. In this case, where the f messages are from slow but non-faulty servers, we will have n - f messages remaining and out of these n - f messages, there could be at most f faulty messages again from byzantine servers, so the worst case we will have n - 2f correct message. For the system to function properly, the correct messages must out number faulty messages for client to identify which is which, which implies we should have n - 2f &gt; f, so n &gt; 3f where f is the number of byzantine servers.</p>
]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BFT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 707 DIV 2 500 Steps Construct]]></title>
      <url>http://lianghan.org/2017/01/31/2017-01-31-TopCoder-SRM-707-DivII/</url>
      <content type="html"><![CDATA[<p>Problem with interesting constraints… hopefully figured this out during SRM this time. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StepsConstruct &#123;</span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">getD</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'R'</span>) <span class="keyword">return</span> <span class="string">'L'</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'L'</span>) <span class="keyword">return</span> <span class="string">'R'</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'U'</span>) <span class="keyword">return</span> <span class="string">'D'</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'D'</span>) <span class="keyword">return</span> <span class="string">'U'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'R'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">construct</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; board, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        rows = (<span class="keyword">int</span>)board.size(); cols = (<span class="keyword">int</span>)board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; paths;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; qp;</span><br><span class="line">        q.push(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        qp.push(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> x = cur.first, y = cur.second;</span><br><span class="line">            <span class="built_in">string</span> curp = qp.front();</span><br><span class="line">            qp.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">char</span> steps[] = &#123;<span class="string">'D'</span>, <span class="string">'U'</span>, <span class="string">'R'</span>, <span class="string">'L'</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cur = &#123;x + dx[i], y + dy[i]&#125;;</span><br><span class="line">                <span class="keyword">if</span>(cur.first &lt; <span class="number">0</span> || cur.second &lt; <span class="number">0</span> || cur.first &gt;= rows || cur.second &gt;= cols)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(visited.count(cur))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[cur.first][cur.second] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    visited.insert(cur);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">string</span> p = curp + steps[i];</span><br><span class="line">                <span class="keyword">if</span> (cur.first == rows - <span class="number">1</span> &amp;&amp; cur.second == cols - <span class="number">1</span>) &#123;</span><br><span class="line">                    paths.push_back(p);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                visited.insert(cur);</span><br><span class="line">                qp.push(p);</span><br><span class="line">                q.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minsteps = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> path : paths) &#123;</span><br><span class="line">            minsteps = <span class="built_in">std</span>::min((<span class="keyword">int</span>)path.size(), minsteps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minsteps &gt; k) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> path : paths) &#123;</span><br><span class="line">            <span class="keyword">int</span> steps = (<span class="keyword">int</span>)path.size();</span><br><span class="line">            <span class="keyword">if</span> (steps &lt;= k &amp;&amp; ((k - steps) % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = k - steps;</span><br><span class="line">                <span class="built_in">string</span> prefix = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">char</span> c = path[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) &#123;</span><br><span class="line">                    prefix += c;</span><br><span class="line">                    c = getD(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> prefix + path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.3 Letter Game]]></title>
      <url>http://lianghan.org/2017/01/27/2017-01-27-USACO-LetterGame/</url>
      <content type="html"><![CDATA[<p>The basic idea is to use brutal force approach by enumerating all possible words generated from input word and choose the right ones. There are a couple of optimizations that we can do:</p>
<ul>
<li>There are at most two strings in each anwser, because the length constraints (3 is the minimum length, 7 is the maximum length, so at most two strings.).</li>
<li>Similarly, since each word in dictionary is at least 3 characters long, we can skip sub strings with length 1 or 2 during enumeration.</li>
<li>During enumeration, whenever we find the first substring is greater lexicographically than the second, we can abort because the same string pair can occur later (which is what we want, the lexicographically smaller ones). There are some edge cases to deal with here though, such as the second string is empty, in which case the first string would be the full length of the source string.</li>
<li>The STL next_enumeration comes really handy.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; wordval;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; used;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans1 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(word.begin(),word.end());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= (<span class="keyword">int</span>)word.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= (<span class="keyword">int</span>)word.size(); ++j) &#123;</span><br><span class="line">                <span class="built_in">string</span> w1, w2, w;</span><br><span class="line">                w1 = word.substr(<span class="number">0</span>,i);</span><br><span class="line">                w2 = word.substr(i,j-i);</span><br><span class="line">                <span class="keyword">if</span> (w1 &gt; w2 &amp;&amp; w2 != <span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!wordval[w1] || (!wordval[w2] &amp;&amp; w2 != <span class="string">""</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                w = w1;</span><br><span class="line">                <span class="keyword">if</span>(!w2.empty())  &#123;</span><br><span class="line">                    w += <span class="string">" "</span>; w += w2;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(ans1 == wordval[w1] + wordval[w2] &amp;&amp; !used.count(w)) &#123;</span><br><span class="line">                    used.insert(w);</span><br><span class="line">                    ans.push_back(w);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ans1 &lt; wordval[w1] + wordval[w2]) &#123;</span><br><span class="line">                    ans1 = wordval[w1] + wordval[w2];</span><br><span class="line">                    used.clear();</span><br><span class="line">                    ans.clear();</span><br><span class="line">                    used.insert(w);</span><br><span class="line">                    ans.push_back(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(word.begin(),word.end()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fdin</span><span class="params">(<span class="string">"lgame.dict"</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"lgame.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"lgame.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    wordval[<span class="string">""</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fdin &gt;&gt; str &amp;&amp; str != <span class="string">"."</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; (<span class="keyword">int</span>)str.size(); ++i) &#123;</span><br><span class="line">            val += value[str[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        wordval[str] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; word;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    compute();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)ans.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String </tag>
            
            <tag> Enumeration </tag>
            
            <tag> Permutation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The Google File System]]></title>
      <url>http://lianghan.org/2017/01/21/2017-01-21-Google-File-System/</url>
      <content type="html"><![CDATA[<p>Paper digest - <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">The Google File System</a></p>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>Scalable distributed file system for large distributed data-intensive applications driven by observations of application workloads and technological environment, both current and anticipated:<ul>
<li>Component failures are the norm rather than the exception.</li>
<li>Files are huge by traditional standards. Multi-GB files are common.</li>
<li>Workloads: large streaming reads and small random reads; many large, sequential writes.</li>
</ul>
</li>
</ul>
<h1 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h1><ul>
<li><p>Provides fault tolerance while running on inexpensive commodity hardware.</p>
</li>
<li><p>Delivers high aggregate performance to a large number of clients.</p>
</li>
<li><p>Must efficiently implement well-defined semantics for multiple clients that concurrently append to the same file. Atomicity with minimal synchronization overhead is essential. </p>
</li>
<li><p>Prefer bandwidth over latency (batch processing, not real time.).</p>
</li>
<li><p>Consistency Model : co-designing the applications and the file system for flexibility (in other words, push hard problem to other places.).</p>
</li>
</ul>
<h1 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h1><ul>
<li><p>Master-Slave architecture.</p>
<ul>
<li>GFS Master:<ul>
<li>Management data storage: metadata, namespace, access control, mappings from files to chunks, current location of chunk.</li>
<li>System wide activities: chunk lease management, garbage collect of orphaned chunks, chunk migration.</li>
<li>System is designed to minimize master’s involvement since master is SPOF.</li>
</ul>
</li>
<li>GFS Slave (aka chunk server):<ul>
<li>Chunk with 64 bit globally uniquely chunk handle. Stored on linux FS. Replicated (3 copies by default.).</li>
<li>Does not cache files (rely on Linux’s buffer cache.).</li>
</ul>
</li>
<li>GFS Client:<ul>
<li>Interact with master for metadata operations.</li>
<li>Actual data IO does not go through master; go through between client and chunk server.</li>
<li>Does not cache files (infeasible to cache - too large; hard problem to solve for cache coherence, so don’t solve it.).</li>
<li>Does not cache files - continued: GFS applications, MapReduce and BigTable. MapReduce - sequential read, no need to cache. Bigtable has its own cache management.</li>
</ul>
</li>
</ul>
</li>
<li><p>Lease Management</p>
<ul>
<li>Lease is used to maintain a consistent mutation order across replicas. </li>
<li>Master grants chunk lease to one replica (primary).</li>
<li>The primary picks a serial order for all mutations to the chunk. All replicas follow this order when applying mutations.</li>
<li>A lease has an initial timeout of 60 seconds. Can be extended at the request of primary chunk server, or can be revoked by master after lease expire.</li>
</ul>
</li>
<li><p>Consistency Model</p>
<ul>
<li>Relaxed consistency model.</li>
<li>File namespace mutations (e.g., file creation) are atomic, handled by master exclusively.</li>
<li>Data mutation case: consistent but undefined (e.g., concurrent succeed mutation).</li>
<li>Data mutation case: Inconsistent and undefined (e.g., failed mutation).</li>
<li>Concurrent append: at least once semantic (implies that records could have paddings in between, that readers need to dealt with).</li>
<li>Reader dealt with validating (through checksums) and identifying records.</li>
<li>Overall - flexible consistency model (instead of strong consistency) makes application development a little bit difficult.</li>
</ul>
</li>
<li><p>Append</p>
<ul>
<li>Pipeline</li>
<li>Data flow and control flow decoupled.</li>
</ul>
</li>
<li><p>Fault Tolerant</p>
<ul>
<li>Replicated master, check points and snapshots (**Q: how replication is done??)</li>
<li>Replicated chunk servers (default 3). Erasure codes / parity.</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Distributed System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Distributed System </tag>
            
            <tag> Paper Digest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 706 DIV 2 500 Selling Fruits]]></title>
      <url>http://lianghan.org/2017/01/21/2017-01-21-TopCoder-SRM706-DIV2-500/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> SellingFruits &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDays</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = d / x;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; f) <span class="keyword">return</span> ret;</span><br><span class="line">        ret = f;</span><br><span class="line">        d -= f * x;</span><br><span class="line">        ret += (d / (x + p));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.3 Street Race]]></title>
      <url>http://lianghan.org/2017/01/15/2017-01-15-USACO-StreetRace/</url>
      <content type="html"><![CDATA[<p>Use DFS to do brutal force search given the small data size. There are two problems:</p>
<ul>
<li>Decide the unavoidable points. This can be solved by iterating over each point (except the starting and ending point 0 and N, respectively) and assume the current point is being taken out of the graph. If in such a graph starting from 0 there is still a path to N then the current point being taken out is not an unavoidable point. Otherwise, the current point is an unavoidable point.</li>
<li>Decide the splitting points. The splitting points must be a subset of unavoidable points. So iterating through all the unavoidable points figured out in first step, and do two search from 0 and the current iterating point respectively, and record the sets of point that two search could reach. If the two sets intersect, then the current point can’t be a splitting point by definition; otherwise the current point is a splitting point.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">bool</span> graph[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">55</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> split;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] || !graph[v][i] || i == j || i == v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((i == N &amp;&amp; graph[v][i]) || dfs(i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    st.insert(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.count(i) || !graph[s][i] || s == i || i == split) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"race3.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"race3.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!fin.eof()) &#123;</span><br><span class="line">        fin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-2</span>) &#123;</span><br><span class="line">            ++N;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        graph[N][n] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --N;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r1, r2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        <span class="keyword">if</span> (!dfs(<span class="number">0</span>, i)) r1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r1.size(); fout &lt;&lt; r1.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> r : r1) &#123;</span><br><span class="line">        st.clear();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; r; fout &lt;&lt; <span class="string">" "</span> &lt;&lt; r;</span><br><span class="line">        split = r; dfs(<span class="number">0</span>); <span class="keyword">auto</span> stt = st; st.clear(); dfs(r);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; common_data;</span><br><span class="line">        set_intersection(st.begin(), st.end(), stt.begin(), stt.end(),</span><br><span class="line">                         <span class="built_in">std</span>::back_inserter(common_data));</span><br><span class="line">        <span class="keyword">if</span> (!common_data.empty()) <span class="keyword">continue</span>;</span><br><span class="line">        r2.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r2.size(); fout &lt;&lt; r2.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> r : r2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; r; fout &lt;&lt; <span class="string">" "</span> &lt;&lt; r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Search </tag>
            
            <tag> DFS </tag>
            
            <tag> Graph Theory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.3 Buy Low]]></title>
      <url>http://lianghan.org/2017/01/13/2017-01-13-USACO-BuyLow/</url>
      <content type="html"><![CDATA[<p>Essentially a longest decreasing sequence problem that is easy to solve using typical DP approach. Counting the number of such sequences is also not hard, the real problem is that the counts could be too big to fit in 32 or 64 bit integers, so need to use big integers struct.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base_digits = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BigInteger &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">int</span> sign;</span><br><span class="line"></span><br><span class="line">    BigInteger() : sign(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    BigInteger(<span class="keyword">long</span> <span class="keyword">long</span> v) &#123;</span><br><span class="line">        *<span class="keyword">this</span> = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger &amp;v) &#123;</span><br><span class="line">        sign = v.sign;</span><br><span class="line">        a = v.a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">long</span> <span class="keyword">long</span> v) &#123;</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">        a.clear();</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>, v = -v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; v &gt; <span class="number">0</span>; v = v / base) &#123;</span><br><span class="line">            a.push_back(v % base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign != v.sign) <span class="keyword">return</span> *<span class="keyword">this</span> - (-v);</span><br><span class="line">        BigInteger res = v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">             i &lt; (<span class="keyword">int</span>) max(a.size(), v.a.size()) || carry; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == (<span class="keyword">int</span>) res.a.size())</span><br><span class="line">                res.a.push_back(<span class="number">0</span>);</span><br><span class="line">            res.a[i] += carry + (i &lt; (<span class="keyword">int</span>) a.size() ? a[i] : <span class="number">0</span>);</span><br><span class="line">            carry = res.a[i] &gt;= base;</span><br><span class="line">            <span class="keyword">if</span> (carry) res.a[i] -= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign != v.sign) <span class="keyword">return</span> *<span class="keyword">this</span> + (-v);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>() &lt; v.<span class="built_in">abs</span>()) <span class="keyword">return</span> -(v - *<span class="keyword">this</span>);</span><br><span class="line">        BigInteger res = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) v.a.size() || carry; ++i) &#123;</span><br><span class="line">            res.a[i] -= carry + (i &lt; (<span class="keyword">int</span>) v.a.size() ? v.a[i] : <span class="number">0</span>);</span><br><span class="line">            carry = res.a[i] &lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (carry)</span><br><span class="line">                res.a[i] += base;</span><br><span class="line">        &#125;</span><br><span class="line">        res.trim();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger &amp;v) &#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> + v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger &amp;v) &#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> - v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign != v.sign)</span><br><span class="line">            <span class="keyword">return</span> sign &lt; v.sign;</span><br><span class="line">        <span class="keyword">if</span> (a.size() != v.a.size())</span><br><span class="line">            <span class="keyword">return</span> a.size() * sign &lt; v.a.size() * v.sign;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != v.a[i])</span><br><span class="line">                <span class="keyword">return</span> a[i] * sign &lt; v.a[i] * sign;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(v &lt; *<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; v); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; v) &amp;&amp; !(v &lt; *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> &lt; v || v &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!a.empty() &amp;&amp; !a.back())</span><br><span class="line">            a.pop_back();</span><br><span class="line">        <span class="keyword">if</span> (a.empty())</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInteger res = *<span class="keyword">this</span>;</span><br><span class="line">        res.sign = -sign;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInteger <span class="title">abs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        BigInteger res = *<span class="keyword">this</span>;</span><br><span class="line">        res.sign *= res.sign;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream, <span class="keyword">const</span> BigInteger &amp;v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.sign == <span class="number">-1</span>)</span><br><span class="line">            stream &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line">        stream &lt;&lt; (v.a.empty() ? <span class="number">0</span> : v.a.back());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) v.a.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            stream &lt;&lt; setw(base_digits) &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; v.a[i];</span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, dp;</span><br><span class="line"><span class="built_in">vector</span>&lt;BigInteger&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"buylow.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"buylow.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    num = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    cnt = <span class="built_in">vector</span>&lt;BigInteger&gt;(N, BigInteger(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt; num[i]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">std</span>::max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt; num[i] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                cnt[i] += cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) cnt[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] == num[i] &amp;&amp; dp[j] == dp[i]) &#123;</span><br><span class="line">                cnt[i] -= cnt[j]; <span class="comment">// remove duplicates.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = *<span class="built_in">std</span>::minmax_element(dp.begin(), dp.end()).second;</span><br><span class="line">    BigInteger finalCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxLen == dp[i]) &#123;</span><br><span class="line">            finalCnt += cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxLen &lt;&lt; <span class="string">" "</span> &lt;&lt; finalCnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; maxLen &lt;&lt; <span class="string">" "</span> &lt;&lt; finalCnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Big Integer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.2 Job Processing]]></title>
      <url>http://lianghan.org/2017/01/08/2017-01-08-USACO-JobProcessing/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M1, M2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; va, vb, cost, ta, tb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)vec.size();</span><br><span class="line">    cost = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX, index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> delay = cost[j] + vec[j];</span><br><span class="line">            <span class="keyword">if</span> (min &lt;= delay) <span class="keyword">continue</span>;</span><br><span class="line">            min = delay; index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        cost[index] = min;</span><br><span class="line">        table[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"job.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"job.out"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ansA, ansB = INT_MIN;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; M1 &gt;&gt; M2;</span><br><span class="line">    va = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M1, <span class="number">0</span>), vb = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M2, <span class="number">0</span>);</span><br><span class="line">    ta = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>), tb = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M1; ++i) fin &gt;&gt; va[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M2; ++i) fin &gt;&gt; vb[i];</span><br><span class="line">    compute(va, ta); compute(vb, tb);</span><br><span class="line">    sort(ta.begin(), ta.end());</span><br><span class="line">    sort(tb.begin(), tb.end(), [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    ansA = ta[N - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        ansB = <span class="built_in">std</span>::max(ta[i] + tb[i], ansB);</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; ansA &lt;&lt; <span class="string">" "</span> &lt;&lt; ansB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ansA &lt;&lt; <span class="string">" "</span> &lt;&lt; ansB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Greedy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.2 The Pefect Stall]]></title>
      <url>http://lianghan.org/2017/01/04/2017-01-04-USACO-ThePerfectStall/</url>
      <content type="html"><![CDATA[<p>Standard bipartite match with Hungarain Algorithm.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N <span class="comment">/* cows */</span>, M <span class="comment">/* stalls */</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; match;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    graph[u].emplace_back(v);</span><br><span class="line">    graph[v].emplace_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[v].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = graph[v][i], w = match[u];</span><br><span class="line">        <span class="keyword">if</span> (w &lt; <span class="number">0</span> || (!visited[w] &amp;&amp; dfs(w))) &#123;</span><br><span class="line">            match[v] = u; match[u] = v;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite_match</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::fill(match.begin(), match.end(), <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i] &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i)) <span class="keyword">continue</span>;</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"stall4.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"stall4.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">int</span> size = N + M + <span class="number">1</span>;</span><br><span class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    match = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">-1</span>);</span><br><span class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(size, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            fin &gt;&gt; k;</span><br><span class="line">            addEdge(i, k + N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = bipartite_match();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph Theory </tag>
            
            <tag> Bipartite Match </tag>
            
            <tag> Hungarian Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.2 Drainage Ditches]]></title>
      <url>http://lianghan.org/2017/01/04/2017-01-04-USACO-DrainageDitches.h/</url>
      <content type="html"><![CDATA[<p>Simple Network Flow problem with (inefficient) DFS based Ford-Fulkerson algorithm.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Si, Ei, Ci;</span><br><span class="line"><span class="keyword">struct</span> Edge &#123;</span><br><span class="line">    <span class="keyword">int</span> to, cap, rev;</span><br><span class="line">    Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> rev) :</span><br><span class="line">    to(to), cap(cap), rev(rev) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    graph[from].emplace_back(Edge(to, cap, (<span class="keyword">int</span>)graph[to].size()));</span><br><span class="line">    graph[to].emplace_back(Edge(from, <span class="number">0</span>, (<span class="keyword">int</span>)graph[from].size() - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ford–Fulkerson</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == t)</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph[v].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;e = graph[v][i];</span><br><span class="line">        <span class="keyword">if</span> (visited[e.to] || e.cap &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> d = dfs(e.to, t, <span class="built_in">std</span>::min(f, e.cap));</span><br><span class="line">        <span class="keyword">if</span> (d &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        e.cap -= d;</span><br><span class="line">        graph[e.to][e.rev].cap += d;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">int</span> f = dfs(s, t, INT_MAX);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line">        flow += f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"ditch.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"ditch.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N <span class="comment">/* edges */</span> &gt;&gt; M <span class="comment">/* vertices */</span>;</span><br><span class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt;(M + <span class="number">1</span>, <span class="built_in">vector</span>&lt;Edge&gt;());</span><br><span class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(M + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; Si &gt;&gt; Ei &gt;&gt; Ci;</span><br><span class="line">        addEdge(Si, Ei, Ci);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = maxFlow(<span class="number">1</span>, M);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph Theory </tag>
            
            <tag> Ford-Fulkerson </tag>
            
            <tag> Network Flow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.1 Fence Loops]]></title>
      <url>http://lianghan.org/2016/12/27/2016-12-27-USACO-FenceLoops/</url>
      <content type="html"><![CDATA[<p>The problem is to find smallest loops in a DAG. The idea is simple: each loop must have a start vertex and an end vertex. Since no loop connects to itself as the problem stated, the start and end vertex must be different. Also, the smallest perimeter of such a loop is the shortest path between the start vertex and end vertex, plus the length of the edge between two vertices. So to find the loop with smallest perimeter, we can iterate through each edge, calculate the shortest distance between two vertices that connect the edge (without considering the edge itself, of course, otherwise the shortest distance between two vertices would be the edge itself.), then add length of the edge. Do this for all possible edge and we get the result. The shortest distance between two vertices can be calculated using <a href="http://lianghan.org/2016/08/03/2016-08-03-DijKstra/">Dijkstra algorithm I posted earlier</a>.</p>
<p>The pain point here is to properly transfer the source data to the graph representation. Here the transformation is done through state encoding (each vertex can be uniquely identified by the edge id it connects to). The overall code is a little bit bloated due to this.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [to node index, edge weight] pair.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge;</span><br><span class="line"><span class="comment">// [node index, distance to source] pair.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; element;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; vxts;</span><br><span class="line"><span class="keyword">int</span> vxtCnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vs;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fence6.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fence6.out"</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, s, Ls, N1s, N2s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVertexId</span><span class="params">(<span class="keyword">int</span> Ns)</span> </span>&#123;</span><br><span class="line">    vs.clear(); vs.insert(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Ns; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> sn; fin &gt;&gt; sn;</span><br><span class="line">        vs.insert(sn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> iter = vxts.find(vs);</span><br><span class="line">    <span class="keyword">if</span> (iter == vxts.end()) &#123;</span><br><span class="line">        vxts[vs] = vxtCnt++;</span><br><span class="line">        <span class="keyword">return</span> vxts[vs];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;edge&gt;&gt; g;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; s &gt;&gt; Ls &gt;&gt; N1s &gt;&gt; N2s;</span><br><span class="line">        <span class="keyword">int</span> vtx1 = getVertexId(N1s);</span><br><span class="line">        <span class="keyword">int</span> vtx2 = getVertexId(N2s);</span><br><span class="line">        g[vtx1].emplace_back(make_pair(vtx2, Ls));</span><br><span class="line">        g[vtx2].emplace_back(make_pair(vtx1, Ls));</span><br><span class="line">    &#125;</span><br><span class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt;(vxtCnt, <span class="built_in">vector</span>&lt;edge&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vxtCnt; ++i) &#123;</span><br><span class="line">        graph[i] = g[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> compare &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> element&amp;a, <span class="keyword">const</span> element &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; &amp;graph, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph.size();</span><br><span class="line">    <span class="keyword">if</span> (!size) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (source &lt; <span class="number">0</span> || source &gt;= size || target &lt; <span class="number">0</span> || target &gt;= size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(size, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distance(size, INT_MAX);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(size, <span class="number">-1</span>);</span><br><span class="line">    distance[source] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;element, <span class="built_in">vector</span>&lt;element&gt;, compare&gt; pq;</span><br><span class="line">    pq.emplace(make_pair(source, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = pq.top().first;</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (v == target) <span class="keyword">return</span> distance[v];</span><br><span class="line">        <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph[v]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = edge.first; <span class="comment">// vertice u that connects to v.</span></span><br><span class="line">            <span class="keyword">int</span> w = edge.second; <span class="comment">// weight of edge that connects u and v.</span></span><br><span class="line">            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (distance[v] &lt; distance[u] - w) &#123;</span><br><span class="line">                distance[u] = distance[v] + w;</span><br><span class="line">                pq.emplace(make_pair(u, distance[u]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    genGraph();</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vxtCnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e1 : graph[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e1.second;</span><br><span class="line">            <span class="keyword">int</span> to = e1.first;</span><br><span class="line">            edge *e2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[to].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[to][j].first == i) &#123;</span><br><span class="line">                    e2 = &amp;graph[to][j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            e1.second = INT_MAX;</span><br><span class="line">            e2-&gt;second = INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> p = dijkstra(graph, i, to);</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="number">-1</span> &amp;&amp; p + w &lt; ans) &#123;</span><br><span class="line">                ans = p + w;</span><br><span class="line">            &#125;</span><br><span class="line">            e1.second = w;</span><br><span class="line">            e2-&gt;second = INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dijkstra </tag>
            
            <tag> Graph Theory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 4.1 Beef McNuggests]]></title>
      <url>http://lianghan.org/2016/12/23/2016-12-23-USACO-BeefMcNuggets/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"nuggets.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"nuggets.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vals = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; vals[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = vals[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        n = gcd(n, vals[i]);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(vals.begin(), vals.end());</span><br><span class="line">    <span class="keyword">int</span> max = vals[N - <span class="number">1</span>] * vals[N - <span class="number">2</span>] * gcd(vals[N - <span class="number">1</span>], vals[N - <span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(max, <span class="literal">false</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = vals[i]; j &lt;= max; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j - vals[i]]) &#123;</span><br><span class="line">               dp[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp[i]) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            fout &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Number Theory </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.4 Raucous Rockers]]></title>
      <url>http://lianghan.org/2016/12/16/2016-12-16-USACO-RaucousRockers/</url>
      <content type="html"><![CDATA[<p>Typical BackPack problem but with the limited scale of test data, a straight forward brutal force search could do it. The search space is the permutation of subsets of all songs, for each song we have two choice - choose or not choose. Iterate the sequence under the constraint of ordering.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N <span class="comment">/* songs */</span>, M <span class="comment">/* disks */</span>, T <span class="comment">/* disk capacity */</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; songs;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; disks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"rockers.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"rockers.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; T &gt;&gt; M;</span><br><span class="line">    songs = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; songs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    disks = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> upper = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= upper; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::fill(disks.begin(), disks.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">bool</span> pick = (<span class="number">1</span> &lt;&lt; j) &amp; i;</span><br><span class="line">            <span class="keyword">if</span> (!pick) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = idx; k &lt; M; ++k, ++idx)&#123;</span><br><span class="line">                <span class="keyword">if</span>(disks[k] + songs[j] &lt;= T)&#123;</span><br><span class="line">                    disks[k] += songs[j];</span><br><span class="line">                    ++sum;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">std</span>::max(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Search </tag>
            
            <tag> Brutal Force </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.4 Electric Fence]]></title>
      <url>http://lianghan.org/2016/12/14/2016-12-14-USACO-ElectricFence/</url>
      <content type="html"><![CDATA[<p><a href="https://www.math.hmc.edu/funfacts/ffiles/10002.2.shtml" target="_blank" rel="noopener">Pick’s Theorem</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    a %= b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fence9.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fence9.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">int</span> ret = p * m / <span class="number">2.0</span> - (gcd(m, n) + gcd(m, <span class="built_in">abs</span>(p - n)) + p) / <span class="number">2.0</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Math </tag>
            
            <tag> Computation Geometry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 703 GCDGraph]]></title>
      <url>http://lianghan.org/2016/12/14/2016-12-13-TopCoder-SRM-703-GCDGraph/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> GCDGraph &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::iota(tree.begin(), tree.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; root = [&amp;] (<span class="keyword">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i] != i) &#123;</span><br><span class="line">                <span class="comment">// Tail recursion is surprisingly well optimized</span></span><br><span class="line">                <span class="comment">// here by compiler to pass large test data set.</span></span><br><span class="line">                tree[i] = root(tree[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tree[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = root(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) &#123;</span><br><span class="line">                tree[root(j)] = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root(x) == root(y) ? <span class="string">"Possible"</span> : <span class="string">"Impossible"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UnionFind </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.4 American Heritage]]></title>
      <url>http://lianghan.org/2016/12/12/2016-12-12-USACO-AmericanHeritage/</url>
      <content type="html"><![CDATA[<p>Probably the most easiest problem solved on USACO so far?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> preorder;</span><br><span class="line"><span class="built_in">string</span> inorder;</span><br><span class="line"><span class="built_in">string</span> postorder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">char</span> c) : left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>), c(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">construct</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == preorder[preStart]) &#123;</span><br><span class="line">            index = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = construct(preStart + <span class="number">1</span>, preStart + index - inStart,</span><br><span class="line">                           inStart, index - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = construct(preStart + index - inStart + <span class="number">1</span>, preEnd,</span><br><span class="line">                            index + <span class="number">1</span>, inEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postTraverse</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    postTraverse(root-&gt;left);</span><br><span class="line">    postTraverse(root-&gt;right);</span><br><span class="line">    postorder += root-&gt;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"heritage.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"heritage.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; inorder &gt;&gt; preorder;</span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)inorder.size();</span><br><span class="line">    postTraverse(construct(<span class="number">0</span>, size - <span class="number">1</span>, <span class="number">0</span>, size - <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; postorder &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; postorder &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DFS </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.3 Camelot]]></title>
      <url>http://lianghan.org/2016/12/09/2016-12-09-USACO-Camelot/</url>
      <content type="html"><![CDATA[<p>Interesting problem… thinking this way:</p>
<ul>
<li>What would be the final meeting point? Hard to tell so let’s do a search for every point on the grid.</li>
<li>What if there is no king? Then it’s much easier, we just need to find a point whose sum of steps to all the knights is minimum. This could be done by doing BFS starting from each knight, and ending at the desired point. Since we don’t know what the desired point is, the target is the entire grid.</li>
<li>Now add king into the picture. King has interesting property that he does not cost any steps if with at least one knights. There are two cases here: first, the king might walk himself to the final meeting point; and second, there might be one or more knights that pick up the king <em>at certain point</em> and then head to meeting point together.</li>
<li>So how to find that <em>certain point</em> where a king might be picked up by a knight? Hard to tell again so let’s do a search for every point on the grid… err that is not good, and will timeout. Interestingly, it turns out that for the test data, this pick up location is within 2 or 3 steps at most from where the king initially was, so we can cut the search space. Not sure if this can be proved though…</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R, C;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">32</span>][<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">32</span>][<span class="number">32</span>][<span class="number">32</span>][<span class="number">32</span>];</span><br><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, d;</span><br><span class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d) : x(x), y(y), d(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; knights;</span><br><span class="line"><span class="function">Node <span class="title">king</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">char</span> yc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onGrid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; R || y &gt; C) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">knightBFS</span><span class="params">(Node k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    q.push(k);</span><br><span class="line">    <span class="keyword">int</span> sx = k.x, sy = k.y;</span><br><span class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = node.x, y = node.y;</span><br><span class="line">        dist[x][y][x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> yy = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (!onGrid(xx, yy)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[sx][sy][xx][yy] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.emplace(Node(xx, yy, node.d + <span class="number">1</span>));</span><br><span class="line">            dist[sx][sy][xx][yy] = node.d + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"camelot.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"camelot.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; R &gt;&gt; C;</span><br><span class="line">    <span class="keyword">bool</span> kingFound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (fin &gt;&gt; yc &gt;&gt; x) &#123;</span><br><span class="line">        y = yc - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!kingFound) &#123;</span><br><span class="line">            king = Node(x, y, <span class="number">0</span>);</span><br><span class="line">            kingFound = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            knights.emplace_back(Node(x, y, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; ++j) &#123;</span><br><span class="line">            knightBFS(Node(i, j, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;knight : knights) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; ++j) &#123;</span><br><span class="line">                sum[i][j] += dist[knight.x][knight.y][i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_STEP = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dx = -MAX_STEP; dx &lt;= MAX_STEP; ++dx) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> dy = -MAX_STEP; dy &lt;= MAX_STEP; ++dy) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;knight : knights) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!onGrid(king.x + dx, king.y + dy)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> kx = knight.x, ky = knight.y;</span><br><span class="line">                        <span class="keyword">int</span> d1 = dist[king.x + dx][king.y + dy][i][j],</span><br><span class="line">                        d2 = dist[kx][ky][king.x + dx][king.y + dy];</span><br><span class="line">                        <span class="keyword">if</span> (d1 == <span class="number">-1</span> || d2 == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">int</span> distance = sum[i][j] -dist[kx][ky][i][j] + d1 + d2</span><br><span class="line">                        + <span class="built_in">std</span>::max(<span class="built_in">abs</span>(dx),<span class="built_in">abs</span>(dy));</span><br><span class="line">                        ans = <span class="built_in">std</span>::min(distance, ans);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;= C; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i][j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans = min(sum[i][j] + max(<span class="built_in">abs</span>(i - king.x), <span class="built_in">abs</span>(j - king.y)),ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.3 Home On The Range]]></title>
      <url>http://lianghan.org/2016/12/07/2016-12-07-USACO-HomeOnRange/</url>
      <content type="html"><![CDATA[<p>Another relatively straightforward DP problem: the basic idea is to calculate the maximum possible squares (land segment that cows can graze on) that each land can expand to, if the given land is considered as the top-left most corner of the square land segment to be expanded. We calculate this information for each land, starting from the right-down most land (which is just itself), then iteratively repeat the calculation until we reach the top-left most corner. During the computation we can also calculate the final answer incrementally.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"range.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"range.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">    ret = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            fin &gt;&gt; c;</span><br><span class="line">            dp[i][j] = c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]),</span><br><span class="line">                                dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= dp[i][j]; ++k) &#123;</span><br><span class="line">                ret[k]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ret[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ret[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ret[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.3 A Game]]></title>
      <url>http://lianghan.org/2016/11/29/2016-11-29-USACO-AGame/</url>
      <content type="html"><![CDATA[<p>Typical dynamic programming problem. The search space is the optimal value player A could get at a given play step. A play step can be identified by the current state of the board - namely the unused board which is marked by the starting (left) and ending (right) indices. Let’s denote the start index as a, end index as b, and denote dp[a][b] as the optimal value player A could get.</p>
<p>Next we need find out the state transfer function. Since player B will also play optimally (that is, player B is as smart as player A, and both players will try use same optimal strategy to win the game), we can have the transfer function like this:</p>
<p>$f(a, b) = \begin{cases}0 &amp; a &gt; b \\<br>max(f(a) + min(f(a + 2, b), f(a + 1, b - 1)), f(b) + min(f(a, b - 2), f(a + 1, b - 1) &amp; a \le b \\<br>\end{cases}$</p>
<p>And this could be calculated recursively (from two ends of board to middle).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; board;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[a][b] == <span class="number">-1</span>) &#123;</span><br><span class="line">        dp[a][b] = <span class="built_in">std</span>::max(board[a] + <span class="built_in">std</span>::min(compute(a + <span class="number">2</span>, b),</span><br><span class="line">                                                compute(a + <span class="number">1</span>, b - <span class="number">1</span>)),</span><br><span class="line">                            board[b] + <span class="built_in">std</span>::min(compute(a, b - <span class="number">2</span>),</span><br><span class="line">                                                compute(a + <span class="number">1</span>, b - <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[a][b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"game1.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"game1.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    board = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; board[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(board.begin(), board.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> p1 = compute(<span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> p2 = sum - p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.3 Shopping Offers]]></title>
      <url>http://lianghan.org/2016/11/28/2016-11-28-USACO-ShoppingOffers/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="comment">// 2nd dimension stores the offer price as element 0, (normalized) product</span></span><br><span class="line"><span class="comment">// code as element 1, 2, 3, 4, 5.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; offer(<span class="number">106</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// Normalize product code to the range of 1-5 inclusive.</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">int</span> totalOffers;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buy(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> sentinel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a1,<span class="keyword">int</span> a2, <span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[a1][a2][a3][a4][a5] != sentinel)</span><br><span class="line">        <span class="keyword">return</span> dp[a1][a2][a3][a4][a5];</span><br><span class="line">    <span class="keyword">int</span> w1,w2,w3,w4,w5, ret = sentinel;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalOffers; ++i)&#123;</span><br><span class="line">        w1 = a1 - offer[i][<span class="number">1</span>];w2 = a2 - offer[i][<span class="number">2</span>];</span><br><span class="line">        w3 = a3 - offer[i][<span class="number">3</span>];w4 = a4 - offer[i][<span class="number">4</span>];</span><br><span class="line">        w5 = a5 - offer[i][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">if</span>(w1 &lt; <span class="number">0</span> || w2 &lt; <span class="number">0</span> || w3 &lt; <span class="number">0</span> || w4 &lt; <span class="number">0</span> || w5 &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[w1][w2][w3][w4][w5] == sentinel) &#123;</span><br><span class="line">            dp[w1][w2][w3][w4][w5] = compute(w1,w2,w3,w4,w5);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">std</span>::min(ret, dp[w1][w2][w3][w4][w5] + offer[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"shopping.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"shopping.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n, c, k, b, code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            fin &gt;&gt; c &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(c) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[c] = ++code;</span><br><span class="line">            &#125;</span><br><span class="line">            offer[i][<span class="built_in">map</span>[c]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        fin &gt;&gt; offer[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fin &gt;&gt; b;</span><br><span class="line">    totalOffers = s + b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; ++i)&#123;</span><br><span class="line">        fin &gt;&gt; c &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.find(c) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            <span class="built_in">map</span>[c] = ++code;</span><br><span class="line">        &#125;</span><br><span class="line">        offer[s + i][<span class="built_in">map</span>[c]] = <span class="number">1</span>;</span><br><span class="line">        buy[<span class="built_in">map</span>[c]] = k;</span><br><span class="line">        fin &gt;&gt; offer[s + i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0xf</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    sentinel = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = compute(buy[<span class="number">1</span>], buy[<span class="number">2</span>], buy[<span class="number">3</span>], buy[<span class="number">4</span>], buy[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UASCO 3.3 Riding The Fence]]></title>
      <url>http://lianghan.org/2016/11/25/2016-11-25-USACO-RidingTheFence/</url>
      <content type="html"><![CDATA[<p>This is a problem to find Euler Path of the graph. As this is an undirected graph, the Euler Path exists iff:</p>
<ul>
<li>All graph vertices have even degree. Or,</li>
<li>All graph vertices have even degree, except two vertices have odd degree. And these two vertices will be start / end of the Euler Path.</li>
</ul>
<p>This problem explicitly stated that the Euler Path existing, so no need to do the test to find out if the path exists or not. Instead, the job is to find out the exact path with the constraint that vertices should be sequenced in ascending order. There are a couple of well studied algorithm can solve the Euler Path finding problem, however for this test data set I find that we can just use DFS - which is not strictly a Euler Path finding solution because the DFS solution here alone can’t decide if an edge we are going to remove is a ‘bridge edge’ (which, if removed will never makes us traverse back to the graph). I think the solution here is not sound to cover any type of Euler Path, but is just lucky enough to pass the existing test data set.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIMIT = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> F;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(LIMIT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(LIMIT, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(LIMIT, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!degree[idx]) &#123;</span><br><span class="line">        path.push(idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LIMIT; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (adj[idx][i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        --adj[idx][i]; --adj[i][idx]; --degree[idx]; --degree[i];</span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    path.push(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fence.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fence.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; F;</span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        adj[v1][v2]++; adj[v2][v1]++;</span><br><span class="line">        degree[v1]++; degree[v2]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LIMIT; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(degree[i] % <span class="number">2</span>)&#123;</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!path.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; path.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; path.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
            <tag> Euler Path </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.2 Sweet Butter]]></title>
      <url>http://lianghan.org/2016/11/23/2016-11-23-USACO-SweetButter/</url>
      <content type="html"><![CDATA[<p>This problem is essentially a shortest path problem: given a graph, find a single node in the graph (where we will put the butter) such that the combined distances from this graph node (the butter) to a set of graph nodes (the graph nodes where the cows are placed) is minimized.<br>The basic idea is for every node (pasture) in the graph, we calculate the shortest distances between this node and the rest of the nodes. Then for every node (pasture), we sum up the distances between itself and the pastures where cows are placed. The calculation of shortest paths between current pasture and the rest of pasture could be further optimized, as we only care about pasture with cows, so we can skip the pastures pairs where both pastures don’t have cows. But even without this optimization the code pass the test data set. The code use a slightly modified version of <a href="http://lianghan.org/2016/08/03/2016-08-03-DijKstra/">Dijkstra algorithm I posted earlier</a>, otherwise there would be too much redundant computations that leads to timeout errors for large test data set.</p>
<p>I suspect this problem can also be solved using Bellmen-Ford or SFPA, and that would be a good exercise at some point in future…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N <span class="comment">/* cows */</span>, P <span class="comment">/* pastures */</span>, C <span class="comment">/* paths */</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c2p;<span class="comment">// [to node index, edge weight] pair.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge;</span><br><span class="line"><span class="comment">// [node index, distance to source] pair.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; element;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; graph;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> compare &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> element&amp;a, <span class="keyword">const</span> element &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; &amp;graph, <span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(dist.begin(), dist.end(), INT_MAX);</span><br><span class="line">    dist[source] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;element, <span class="built_in">vector</span>&lt;element&gt;, compare&gt; pq;</span><br><span class="line">    pq.emplace(make_pair(source, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = pq.top().first;</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph[v]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = edge.first; <span class="comment">// vertice u that connects to v.</span></span><br><span class="line">            <span class="keyword">int</span> w = edge.second; <span class="comment">// weight of edge that connects u and v.</span></span><br><span class="line">            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] + w &lt; dist[u]) &#123;</span><br><span class="line">                dist[u] = dist[v] + w;</span><br><span class="line">                pq.emplace(make_pair(u, dist[u]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"butter.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"butter.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; N &gt;&gt; P &gt;&gt; C;</span><br><span class="line">    c2p = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt;(C + <span class="number">1</span>, <span class="built_in">vector</span>&lt;edge&gt;());</span><br><span class="line">    dist = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C + <span class="number">1</span>, INT_MAX);</span><br><span class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(C + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; c2p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> s, d, w;</span><br><span class="line">        fin &gt;&gt; s &gt;&gt; d &gt;&gt; w;</span><br><span class="line">        graph[s].emplace_back(make_pair(d, w));</span><br><span class="line">        graph[d].emplace_back(make_pair(s, w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        dijkstra(graph, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            ans += dist[c2p[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">std</span>::min(ret, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dijkstra </tag>
            
            <tag> Search </tag>
            
            <tag> Graph </tag>
            
            <tag> Shortest Path </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.2 Magic Squares]]></title>
      <url>http://lianghan.org/2016/11/19/2016-11-19-USACO-MagicSquares/</url>
      <content type="html"><![CDATA[<p>Typical solution for ‘minimum’ or ‘maximum’ problems:</p>
<ul>
<li>Greedy</li>
<li>Dynamic Programming</li>
<li>BFS</li>
</ul>
<p>For this problem, it is not obvious about overlapping sub-problems so BFS is an obvious solution.<br>The tricky parts are:</p>
<ul>
<li>How to encode the transforms (the A, B, and C).</li>
<li>How to test if a state has been explored.</li>
<li>How to perform backtracking once we have hit desired states.</li>
</ul>
<p>I think this problem is very good on testing implementation skills, as the algorithm itself is not very complicated.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tx = &#123;</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;, <span class="comment">// A</span></span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>&#125;, <span class="comment">// B</span></span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>&#125;, <span class="comment">// C</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> state &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">    state() &#123;</span><br><span class="line">        val = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::iota(val.begin(), val.end(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;state&gt; q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_STATES = <span class="number">40500</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(MAX_STATES, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// Stores state_hash:(previous state hash : transform index)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; trace(MAX_STATES, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="comment">// Stores state_hash:transform index</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; transforms(MAX_STATES, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factorial = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>&#125;;</span><br><span class="line"><span class="comment">// Expected state (read from input.).</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; target(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> steps;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(state[j] &lt; state[i]) ++t;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += t * factorial[<span class="number">7</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    trace[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.emplace(state());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = q.front();q.pop();</span><br><span class="line">        hash = hashing(cur.val);</span><br><span class="line">        <span class="keyword">if</span>(cur.val == target)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            state next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                next.val[j] = cur.val[tx[i][j] - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> next_state_hash = hashing(next.val);</span><br><span class="line">            <span class="keyword">if</span> (visited[next_state_hash]) <span class="keyword">continue</span>;</span><br><span class="line">            q.push(next);</span><br><span class="line">            visited[next_state_hash] = <span class="literal">true</span>;</span><br><span class="line">            trace[next_state_hash][<span class="number">0</span>] = hash;</span><br><span class="line">            trace[next_state_hash][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (trace[hash][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">        transforms[steps]= trace[hash][<span class="number">1</span>];</span><br><span class="line">        hash = trace[hash][<span class="number">0</span>];</span><br><span class="line">        ++steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(ofstream &amp;fout)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; steps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; steps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = steps - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = transforms[i] + <span class="string">'A'</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c; fout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"msquare.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"msquare.out"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; target[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    output(fout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Search </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.2 Feed Ratios]]></title>
      <url>http://lianghan.org/2016/11/08/2016-11-08-USACO-FeedRatios/</url>
      <content type="html"><![CDATA[<p>Could be solved using Gauss Elimination, but there is a constraint on the mixture upper bound (less than 100), so a brutal force search could do it.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goal(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; source(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anws(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> total = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sum[<span class="number">0</span>] &lt; goal[<span class="number">0</span>] || sum[<span class="number">1</span>] &lt; goal[<span class="number">1</span>] || sum[<span class="number">2</span>] &lt; goal[<span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (sum[<span class="number">0</span>] * goal[<span class="number">1</span>] != sum[<span class="number">1</span>] * goal[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (sum[<span class="number">1</span>] * goal[<span class="number">2</span>] != sum[<span class="number">2</span>] * goal[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sum, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">3</span>; ++idx) &#123;</span><br><span class="line">    sum[idx] = source[<span class="number">0</span>][idx] * i + source[<span class="number">1</span>][idx] * j + source[<span class="number">2</span>][idx] * k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"ratios.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"ratios.out"</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    fin &gt;&gt; goal[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">      fin &gt;&gt; source[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> gSum = <span class="built_in">std</span>::accumulate(goal.begin(), goal.end(), <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; ++k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        fillSum(sum, i, j, k);</span><br><span class="line">        <span class="keyword">if</span> (!judge(sum)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + j + k &gt; total) <span class="keyword">continue</span>;</span><br><span class="line">        total = i + j + k;</span><br><span class="line">        anws[<span class="number">0</span>] = i; anws[<span class="number">1</span>] = j; anws[<span class="number">2</span>] = k;</span><br><span class="line">        anws[<span class="number">3</span>] = <span class="built_in">std</span>::accumulate(sum.begin(), sum.end(), <span class="number">0</span>) / gSum;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (anws[<span class="number">3</span>] == INT_MAX || (anws[<span class="number">3</span>] == <span class="number">0</span> &amp;&amp; gSum != <span class="number">0</span>)) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="string">"NONE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      fout &lt;&lt; anws[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; anws[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Search </tag>
            
            <tag> Gauss Elimination </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.2 Spinning Wheels]]></title>
      <url>http://lianghan.org/2016/11/06/2016-11-06-USACO-SpinningWheels/</url>
      <content type="html"><![CDATA[<p>This problem can be treated as a search problem. The search space is the set of states of all wedges of all wheels. The match criteria is at any give second, each wheel out of five wheels should have at least one wedge whose angle and ‘covers’ (the extent) that overlaps with (again, at least one) wedges from other wheels.<br>The catch is we only need to examine the first 360 second and bail out as soon as we have a match, because the state of the wheel and wedges will be reset to the same original state after 360 sec (a cycle).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> wheel &#123;</span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="keyword">int</span> wedgeCnt;</span><br><span class="line">    <span class="keyword">int</span> start[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> angle[<span class="number">5</span>];</span><br><span class="line">&#125; tWheel;</span><br><span class="line"></span><br><span class="line">tWheel wheels[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"spin.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"spin.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; wheels[i].speed &gt;&gt; wheels[i].wedgeCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wheels[i].wedgeCnt; ++j) &#123;</span><br><span class="line">            fin &gt;&gt; wheels[i].start[j] &gt;&gt; wheels[i].angle[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= <span class="number">360</span>; ++m) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; align(<span class="number">360</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            tWheel wheel = wheels[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wheel.wedgeCnt; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = (wheel.start[j] + wheel.speed * m) % <span class="number">360</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = start; k &lt;= start + wheel.angle[j]; ++k) &#123;</span><br><span class="line">                    align[k % <span class="number">360</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (align[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                fout &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"none"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; <span class="string">"none"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Search </tag>
            
            <tag> Simulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.2 Stringsorbits]]></title>
      <url>http://lianghan.org/2016/11/01/2016-11-01-USACO-StringsOrbits.h/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N<span class="comment">/* length of string*/</span>, L<span class="comment">/* max number of bits per string */</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> I <span class="comment">/* the order */</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">32</span>][<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    dp[i][j] = compute(i - <span class="number">1</span>, j) + compute(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"kimbits.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"kimbits.out"</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  fin &gt;&gt; N &gt;&gt; L &gt;&gt; I;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= L; j++)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = N - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(compute(k, L) &lt; I)&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      fout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      I -= compute(k,L);</span><br><span class="line">      L--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">      fout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Combination </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.2 Factorials]]></title>
      <url>http://lianghan.org/2016/10/27/2016-10-27-Factorials/</url>
      <content type="html"><![CDATA[<p>Do pre-processing steps to remove the pairs of factor 2 and 5 (which combines together can generate a 0). Then do factorial calculation against preprocessed numbers, and only keep a single digit at each step.<br>Why not just keep a single digit without pre-processing step? Because even if a digit is not zero, it could become zero after multiplying - so we need make sure kill those factors (2 and 5) first.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fact4.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fact4.out"</span>)</span></span>;</span><br><span class="line">  fin &gt;&gt; N;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(N, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    num[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : num) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      i = i / <span class="number">5</span>;</span><br><span class="line">      ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : num) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      i = i / <span class="number">2</span>;</span><br><span class="line">      --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    r = (r * num[i]) % <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fout &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Number Theory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.1 Stamps]]></title>
      <url>http://lianghan.org/2016/10/25/2016-10-25-USACO-Stamps/</url>
      <content type="html"><![CDATA[<p>Dynamic programming problem. Let dp[i] denotes the minimum number of stamps required to construct a value of i. Then the state transfer function is dp[i] = min(dp[i - val[j]) + 1 for all j between 1 and N, where i &gt;= val[j].<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K, N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"stamps.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"stamps.out"</span>)</span></span>;</span><br><span class="line">  fin &gt;&gt; K &gt;&gt; N;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val(N, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    fin &gt;&gt; val[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">2000001</span>, INT_MAX);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (dp[i] &lt;= K) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">int</span> cur = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val[j] &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">      cur = <span class="built_in">std</span>::min(cur, dp[i - val[j]]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = cur + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fout &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.1 Contact]]></title>
      <url>http://lianghan.org/2016/10/23/2016-10-23-USACO-Contact/</url>
      <content type="html"><![CDATA[<p>The problem can be reduced to a string search and counting problem. The search space is any possible sub strings with size between A and B inclusive. Use a map to record the frequency of the occurrence of each bit pattern (string). Nothing dramatic, but the output formatting is quite nuisance. 输出坑爹!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A, B, N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"contact.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"contact.out"</span>)</span></span>;</span><br><span class="line">  fin &gt;&gt; A &gt;&gt; B &gt;&gt; N;</span><br><span class="line">  <span class="built_in">string</span> s, t;</span><br><span class="line">  <span class="keyword">while</span> (fin &gt;&gt; t) &#123;</span><br><span class="line">    s += t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> size = (<span class="keyword">int</span>)s.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = A; j &lt;= B &amp;&amp; i + j &lt;= size; ++j) &#123;</span><br><span class="line">      <span class="built_in">string</span> sub = s.substr(i, j);</span><br><span class="line">      <span class="built_in">map</span>[sub]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; v;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cm; <span class="comment">// Key: frequence; Val: frequence count.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">map</span>.begin(); iter != <span class="built_in">map</span>.end(); ++iter) &#123;</span><br><span class="line">    v.emplace_back(make_pair(iter-&gt;second, iter-&gt;first));</span><br><span class="line">    cm[iter-&gt;second]++;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(v.begin(), v.end(), [] (<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; &amp;a,</span><br><span class="line">                               <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.first &gt; b.first) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.first &lt; b.first) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sa = (<span class="keyword">int</span>)a.second.size(), sb = (<span class="keyword">int</span>)b.second.size();</span><br><span class="line">    <span class="keyword">if</span> (sa &lt; sb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (sa &gt; sb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; count &lt; N &amp;&amp; i &lt; v.size();) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = cm[v[i].first];</span><br><span class="line">    fout &lt;&lt; v[i].first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j + <span class="number">1</span>) % <span class="number">6</span> == <span class="number">0</span> || j == cnt - <span class="number">1</span>) &#123;</span><br><span class="line">          fout &lt;&lt; v[i + j].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          fout &lt;&lt; v[i + j].second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      i += cnt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fout &lt;&lt; v[i].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> String Manipulation </tag>
            
            <tag> Hashing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.1 Humble Numbers]]></title>
      <url>http://lianghan.org/2016/10/21/2016-10-21-USACO-HumbleNumbers/</url>
      <content type="html"><![CDATA[<p>The idea is to generate and maintain a sorted list of humble numbers:</p>
<ul>
<li>Each humble number can be generated together with this sorted list, and with one of the seed prime numbers.</li>
<li>For each humble number, there is one and only one way of generating the number - in other words the prime factors are fixed for a given humble number.</li>
<li>For each prime factor number, maintain an index into the humble number sorted list. The indexed number in the humble number list would be the next number that this prime factor should multiply.</li>
<li>The invariant is, at each iteration, the smallest possible humble number is generated, and each index associated with each prime factor is incremented by one, if the prime factor contributes to the generation (num % prime == 0).</li>
</ul>
<p>Following this idea, the humble numbers can be generated systematically without duplicates, and we only need maintain a single sorted list of humble numbers.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"humble.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"humble.out"</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  fin &gt;&gt; K &gt;&gt; N;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(N + <span class="number">1</span>, INT_MAX);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(K, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices(K, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) &#123;</span><br><span class="line">    fin &gt;&gt; num[i];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++j) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">std</span>::min(dp[i], dp[indices[j]] * num[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dp[i] % num[j] == <span class="number">0</span>) &#123;</span><br><span class="line">        ++indices[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fout &lt;&lt; dp[N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.1 Inflation]]></title>
      <url>http://lianghan.org/2016/10/18/2016-10-18-USACO-Inflation/</url>
      <content type="html"><![CDATA[<p>This is a standard ‘Complete Knapsack’ problem. First stab:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M <span class="comment">/* minutes */</span>, N <span class="comment">/* classes */</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"inflate.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"inflate.out"</span>)</span></span>;</span><br><span class="line">  fin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"> </span><br><span class="line">  dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M + <span class="number">1</span>));</span><br><span class="line">  w = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">  v = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    fin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i + <span class="number">1</span>][j] = <span class="built_in">std</span>::max(dp[i][j], dp[i + <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fout &lt;&lt; dp[N][M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[N][M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This solution exceeds the memory limit (16MB, it seems) set by the problem judge. So the optimization of using a rolling array to compress the states is required. It is possible to do the optimization because the compute of a given state only depends on the value of the current state and the value of previous state.<br>Now this one passes:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"inflate.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"inflate.out"</span>)</span></span>;</span><br><span class="line">  fin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    fin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= M; ++j) &#123;</span><br><span class="line">      dp[j] = <span class="built_in">std</span>::max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fout &lt;&lt; dp[M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Knapsack </tag>
            
            <tag> Rolling Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 3.1 AgriNet]]></title>
      <url>http://lianghan.org/2016/10/14/2016-10-14-USACO-AgriNet/</url>
      <content type="html"><![CDATA[<p>Easy problem with prim MST algorithm.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; minset;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"agrinet.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"agrinet.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; N;</span><br><span class="line">  grid = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">      fin &gt;&gt; grid[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minset = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N, <span class="literal">false</span>);</span><br><span class="line">  parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">-1</span>);</span><br><span class="line">  dist = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, INT_MAX);</span><br><span class="line">  dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate N -1 times (since we have initialized dist for vertex 0 already).</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// Find next vertex that not in set, which has smallest distance to existing</span></span><br><span class="line">    <span class="comment">// set of vertices.</span></span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX; <span class="keyword">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; N; ++ii) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!minset[ii] &amp;&amp; dist[ii] &lt; min) &#123;</span><br><span class="line">        minIdx = ii;</span><br><span class="line">        min = dist[ii];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the new vertex to the set, and update all dist accordingly.</span></span><br><span class="line">    minset[minIdx] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[minIdx][j] &amp;&amp; !minset[j] &amp;&amp; grid[minIdx][j] &lt; dist[j]) &#123;</span><br><span class="line">        dist[j] = grid[minIdx][j];</span><br><span class="line">        parent[j] = minIdx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    ret += grid[parent[i]][i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph </tag>
            
            <tag> Minimum Spanning Tree </tag>
            
            <tag> Prim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 700 DIV II 450]]></title>
      <url>http://lianghan.org/2016/10/13/2016-10-11-TopCoder-SRM700/</url>
      <content type="html"><![CDATA[<p>My DFS solution during contest, which passed all system tests except TLE for one. As a result, I received zero points.<br>This is not the first time that I am tempted to use a brutal force solution for a 450 / 500 problem that seemingly work but<br>ultimately fail due to inefficiency.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> XMarksTheSpot &#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> rs, <span class="keyword">int</span> cs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == rs - <span class="number">1</span> &amp;&amp; j == cs - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'?'</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                compute(board);</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                compute(board);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                compute(board);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ni, nj;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; cs) &#123;</span><br><span class="line">            ni = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ni = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nj = (j + <span class="number">1</span>) % cs;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span> || board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">            dfs(board, ni, nj, rs, cs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            dfs(board, ni, nj, rs, cs);</span><br><span class="line">            board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            dfs(board, ni, nj, rs, cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rs = (<span class="keyword">int</span>)board.size();</span><br><span class="line">        <span class="keyword">int</span> cs = (<span class="keyword">int</span>)board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> t = INT_MAX, b = INT_MIN, l = INT_MAX, r = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cs; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                t = <span class="built_in">std</span>::min(i, t);</span><br><span class="line">                b = <span class="built_in">std</span>::max(i, b);</span><br><span class="line">                l = <span class="built_in">std</span>::min(j, l);</span><br><span class="line">                r = <span class="built_in">std</span>::max(j, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; ++j) &#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rs = (<span class="keyword">int</span>)board.size();</span><br><span class="line">        <span class="keyword">int</span> cs = (<span class="keyword">int</span>)board[<span class="number">0</span>].size();</span><br><span class="line">        dfs(board, <span class="number">0</span>, <span class="number">0</span>, rs, cs);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actually even with brutal force, there is better approaches without recursing (which is the root of many evils of time outs during contest).<br>We can just iterate through all the states explicitly and calculate the results at higher level while iterating. <a href="https://community.topcoder.com/stat?c=problem_solution&amp;cr=40494659&amp;rd=16821&amp;pm=14416" target="_blank" rel="noopener">Here</a> is a good example on how to do so.</p>
]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Counting </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.4 Fractions To Decimals]]></title>
      <url>http://lianghan.org/2016/10/12/2016-10-12-USACO-FractionToDecimal/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, D;</span><br><span class="line"><span class="keyword">int</span> outCnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">format</span><span class="params">(ofstream &amp;output)</span> </span>&#123;</span><br><span class="line">  ++outCnt;</span><br><span class="line">  <span class="keyword">if</span> (outCnt == <span class="number">76</span>) &#123;</span><br><span class="line">    output &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    outCnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fracdec.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fracdec.out"</span>)</span></span>;</span><br><span class="line">  fin &gt;&gt; N &gt;&gt; D;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">ostringstream</span> os;</span><br><span class="line">  <span class="keyword">int</span> d = N / D;</span><br><span class="line">  fout &lt;&lt; N / D;</span><br><span class="line">  <span class="keyword">while</span> (d / <span class="number">10</span>) &#123;</span><br><span class="line">    ++outCnt;</span><br><span class="line">    d %= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> r = N % D;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!r) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="string">".0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    outCnt += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fout &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">    ++outCnt;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ds;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (r &amp;&amp; <span class="built_in">map</span>.find(r) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">    <span class="built_in">map</span>[r] = (<span class="keyword">int</span>)ds.size();</span><br><span class="line">    r *= <span class="number">10</span>;</span><br><span class="line">    ds.push_back(r / D);</span><br><span class="line">    r %= D;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">map</span>[r]; ++i) &#123;</span><br><span class="line">      fout &lt;&lt; ds[i]; format(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fout &lt;&lt; <span class="string">"("</span>; format(fout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">map</span>[r]; i &lt; ds.size(); ++i) &#123;</span><br><span class="line">      fout &lt;&lt; ds[i]; format(fout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fout &lt;&lt; <span class="string">")"</span>; format(fout);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ds.size(); ++i) &#123;</span><br><span class="line">      fout &lt;&lt; ds[i]; format(fout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Brutal Force </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.4 Bessie Come Home]]></title>
      <url>http://lianghan.org/2016/10/11/2016-10-11-USACO-BessieComeHome/</url>
      <content type="html"><![CDATA[<p>Pretty straightforward solution with Floyd all pair shortest path algorithm: we simply compute every path and pick up the shortest one between a cow and the barn. One catch is to prepare all the input data. In particular, there is test data where for same pair of pastures, say A and B, distance between AB and BA is different. So need a check to select the smaller one, if distance AB and BA is different. This is very annoying, though it sounds legitimate test data, and maybe intentionally crafted in such a way.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(<span class="number">52</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">52</span>, INT_MAX));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">char2index</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">26</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c - <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"comehome.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"comehome.out"</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  fin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">char</span> c1, c2; <span class="keyword">int</span> d;</span><br><span class="line">    fin &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; d;</span><br><span class="line">    <span class="keyword">int</span> m = char2index(c1), n = char2index(c2);</span><br><span class="line">    <span class="keyword">if</span> (d &lt; dist[m][n]) &#123;</span><br><span class="line">        <span class="comment">// Need this check because sometimes dist[m][n]</span></span><br><span class="line">        <span class="comment">// read from input does not equal to dist[n][m]!!</span></span><br><span class="line">        dist[m][n] = d; dist[n][m] = d;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">52</span>; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">52</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">52</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j] &amp;&amp;</span><br><span class="line">            dist[i][k] != INT_MAX &amp;&amp;</span><br><span class="line">            dist[k][j] != INT_MAX) &#123;</span><br><span class="line">          dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">52</span>; ++i) &#123;</span><br><span class="line">    dist[i][i] = INT_MAX;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = INT_MAX; <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dist[i][<span class="number">25</span>] == INT_MAX)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; dist[i][<span class="number">25</span>]) &#123;</span><br><span class="line">        ret = dist[i][<span class="number">25</span>];</span><br><span class="line">        index = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)(<span class="string">'A'</span> + index) &lt;&lt; <span class="string">" "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fout &lt;&lt; (<span class="keyword">char</span>)(<span class="string">'A'</span> + index) &lt;&lt; <span class="string">" "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Floyd </tag>
            
            <tag> Shortest Path </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.4 Cow Tours]]></title>
      <url>http://lianghan.org/2016/10/09/2016-10-09-USACO-Cowtours/</url>
      <content type="html"><![CDATA[<p>This problem asks about the longest paths among the shortest paths. The basic idea is to use a brutal force search against all pair shortest paths. There are two cases for the shortest paths:</p>
<ul>
<li>The shortest path is one of those that’s connecting two pastures that’s already connected. These paths are already available in original graph.</li>
<li>The shortest path does not exist in original graph. Between two disconnected pastures, say pasture A and pasture B, we can have them connected by having a path go between A and B. Now before we connect A and B, there must exist pasture C and D, such that distance AC is the maximized possible distance between A and all other pastures A already connected in original graph, and similarly distance BD is maximized possible distance between B and all other pastures B already connected in original graph. The new possible longest path of all shortest path between pairs is now distance(AC) + distance(BD) + distance (AB). </li>
<li>Combining two cases, we can do a brutal force search and find the maximum path.</li>
<li>For all pastures that have already connected, use Floyd all pair shortest paths to calculate the path values. </li>
<li>There is no need to explicitly calculate the strongly connected component that connected pastures form, because we would iterate through pair of pastures, rather than through pair of strongly connected components formed by pastures. And we can tell if two pastures needs to be checked because we will only check those that have initial distance value of infinite (meaning not connected initially.).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLE_MAX std::numeric_limits<span class="meta-string">&lt;double&gt;</span>::max()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Point &#123;</span><br><span class="line">  <span class="keyword">int</span> x; <span class="keyword">int</span> y;</span><br><span class="line">&#125; tPoint;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tPoint&gt; points;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; dist;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dmax;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)<span class="built_in">pow</span>(x1 - x2, <span class="number">2</span>) + (<span class="keyword">double</span>)<span class="built_in">pow</span>(y1 - y2, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"cowtour.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"cowtour.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; N;</span><br><span class="line">  points = <span class="built_in">vector</span>&lt;tPoint&gt;(N, tPoint());</span><br><span class="line">  dist = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">  dmax = <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    fin &gt;&gt; points[i].x;</span><br><span class="line">    fin &gt;&gt; points[i].y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">      <span class="keyword">char</span> c;</span><br><span class="line">      fin &gt;&gt; c;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">        dist[i][j] = DOUBLE_MAX;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dist[i][j] = distance(points[i].x, points[i].y, points[j].x, points[j].y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flyod all pair shortest path.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dist[i][k] + dist[k][j] &lt; dist[i][j]) &amp;&amp;</span><br><span class="line">             dist[i][k] != DOUBLE_MAX &amp;&amp;</span><br><span class="line">             dist[k][j] != DOUBLE_MAX) &#123;</span><br><span class="line">          dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">    dist[i][i] = DOUBLE_MAX;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> max_distance = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">    <span class="keyword">double</span> cmax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (dist[i][j] == DOUBLE_MAX)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      cmax = <span class="built_in">std</span>::max(cmax, dist[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    dmax[i] = cmax;</span><br><span class="line">    max_distance = <span class="built_in">std</span>::max(max_distance, cmax);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> ret = DOUBLE_MAX;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i != j &amp;&amp; dist[i][j] == DOUBLE_MAX) &#123;</span><br><span class="line">        <span class="keyword">double</span> d = distance(points[i].x, points[i].y,</span><br><span class="line">                            points[j].x, points[j].y);</span><br><span class="line">        ret = <span class="built_in">std</span>::min(ret, d + dmax[i] + dmax[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">6</span>)</span><br><span class="line">    &lt;&lt; (max_distance &gt; ret ? max_distance : ret) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">6</span>)</span><br><span class="line">  &lt;&lt; (max_distance &gt; ret ? max_distance : ret) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graph </tag>
            
            <tag> Floyd </tag>
            
            <tag> Shortest Path </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.4 Overfencing]]></title>
      <url>http://lianghan.org/2016/10/07/2016-10-07-USACO-Overfencing/</url>
      <content type="html"><![CDATA[<p>The basic idea is for each starting position, find the shortest path from the starting position to one of the exists. Then, among all these shortest paths, find the longest one.<br>The shortest path problem typically can be solved using either BFS, or, by superimposing the grid into some sort of graph and then applying graph shortest path algorithms (Dijkstra or<br> Floyd-Warshall). Here I am using simple BFS which is easier to implement with hands tied.</p>
<p>Two catches for this problem:</p>
<ul>
<li>Be careful with parse of input. For example ifstream in C++ by default will skip white space charaters, this is obviously what we don’t want here because white space char is legitimate input char. Hopefully the behavior is tunable through std::noskipws.</li>
<li>The number of steps need to be encoded in each state.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> W, H;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> state &#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="keyword">int</span> y; <span class="keyword">int</span> s;</span><br><span class="line">    state(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> s) : x(x), y(y), s(s) &#123;&#125;</span><br><span class="line">&#125; tState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ongrid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= <span class="number">2</span> * H + <span class="number">1</span> || y &lt; <span class="number">0</span> || y &gt;= <span class="number">2</span> * W + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// All possible start positions.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;tState&gt; pos;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"maze1.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"maze1.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseGrid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; W &gt;&gt; H;</span><br><span class="line">    </span><br><span class="line">    grid = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;(<span class="number">2</span> * H + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(<span class="number">2</span> * W + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * H + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * W + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            fin &gt;&gt; <span class="built_in">std</span>::noskipws &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                fin &gt;&gt; <span class="built_in">std</span>::noskipws &gt;&gt; c;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[i][j] = c;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span> &amp;&amp; i % <span class="number">2</span> &amp;&amp; j % <span class="number">2</span>) &#123;</span><br><span class="line">                pos.emplace_back(tState(i, j, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    parseGrid();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(<span class="number">2</span> * H + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">2</span> * W + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;position : pos) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * H + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> *W + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;tState&gt; q;</span><br><span class="line">        q.push(position);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; !find) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (visited[p.x][p.y])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p.x, y = p.y;</span><br><span class="line">                <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (!ongrid(xx, yy))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[xx][yy] == <span class="string">'|'</span> || grid[xx][yy] == <span class="string">'-'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                xx = xx + dx[i]; yy = yy + dy[i];</span><br><span class="line">                <span class="function">tState <span class="title">next</span><span class="params">(xx, yy, p.s + <span class="number">1</span>)</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (!ongrid(xx, yy)) &#123;</span><br><span class="line">                    step = next.s;</span><br><span class="line">                    find = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!visited[next.x][next.y]) &#123;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">                visited[p.x][p.y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">std</span>::max(res, step);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fout &lt;&lt; res&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.4 The Tamworth Two]]></title>
      <url>http://lianghan.org/2016/10/06/2016-10-06-USACO-TheTamWorthTwo/</url>
      <content type="html"><![CDATA[<p>The problem can be solved using simple search. The only catch seems that we need properly encode the global state such that we don’t end up visit two exact same state twice, so we can bail out in cases where farmer and cows would never meet.<br>The visited state can be encoded using a six dimensional array, with dimensions as farmers locations (x, y), direction, and cows locations (x, y) and direction.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">10</span>][<span class="number">10</span>][<span class="number">4</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">4</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; grid(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(<span class="number">10</span>, <span class="string">' '</span>));</span><br><span class="line"><span class="comment">// Encoding of directions: 0, 1, 2, 3 for north, east, south, west.</span></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>, cd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> state &#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="keyword">int</span> y; <span class="keyword">int</span> d;</span><br><span class="line">    state() : x(<span class="number">0</span>), y(<span class="number">0</span>), d(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; tState;</span><br><span class="line">tState fs, cs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(tState &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.d == <span class="number">0</span>) &#123;</span><br><span class="line">        --s.y;</span><br><span class="line">        <span class="keyword">if</span> (s.y &lt; <span class="number">0</span> || grid[s.y][s.x] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            ++s.y;</span><br><span class="line">            s.d = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.d == <span class="number">1</span>) &#123;</span><br><span class="line">        ++s.x;</span><br><span class="line">        <span class="keyword">if</span> (s.x &gt; <span class="number">9</span> || grid[s.y][s.x] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            --s.x;</span><br><span class="line">            s.d = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.d == <span class="number">2</span>) &#123;</span><br><span class="line">        ++s.y;</span><br><span class="line">        <span class="keyword">if</span> (s.y &gt; <span class="number">9</span> || grid[s.y][s.x] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            --s.y;</span><br><span class="line">            s.d = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.d == <span class="number">3</span>) &#123;</span><br><span class="line">        --s.x;</span><br><span class="line">        <span class="keyword">if</span> (s.x &lt; <span class="number">0</span> || grid[s.y][s.x] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            ++s.x;</span><br><span class="line">            s.d = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Invalid State!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"ttwo.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"ttwo.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;</span><br><span class="line">            fin &gt;&gt; c;</span><br><span class="line">            grid[i][j] = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'F'</span>) &#123;</span><br><span class="line">                fs.x = j; fs.y = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'C'</span>) &#123;</span><br><span class="line">                cs.x = j; cs.y = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; grid[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    visited[fs.x][fs.y][fs.d][cs.x][cs.y][cs.d] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ++res;</span><br><span class="line">        move(fs);</span><br><span class="line">        move(cs);</span><br><span class="line">        <span class="keyword">if</span> (visited[fs.x][fs.y][fs.d][cs.x][cs.y][cs.d]) &#123;</span><br><span class="line">            res = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fs.x == cs.x &amp;&amp; fs.y == cs.y) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[fs.x][fs.y][fs.d][cs.x][cs.y][cs.d] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fout &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Search </tag>
            
            <tag> Simulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.3 Controlling Companies]]></title>
      <url>http://lianghan.org/2016/10/05/2016-10-05-USACO-ControllingCompanies/</url>
      <content type="html"><![CDATA[<p>This is a search problem that can be solved using brutal force DFS. We first have a pass to initialize the states of companies’ controlling states by bootstrapping controlling companies and controlled companies, and also gather company share statistics for each companies. Then we have a second pass to update the global control state where for each company A, if it controls company B (initialized in first pass by calculating if A has over 50% shares of B), then A should also have same number shares for each company C that company B has shares in. This process continues and the global state should converge and reach a fixed state, as for each company, we will do DFS for every other company only once.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"concom.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"concom.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; nodes(C + <span class="number">1</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> f, c, p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; f &gt;&gt; c &gt;&gt; p;</span><br><span class="line">        nodes[f].push_back(make_pair(c, p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(C + <span class="number">1</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; result(C + <span class="number">1</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(C + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : nodes[i]) &#123;</span><br><span class="line">            <span class="built_in">map</span>[i][pair.first] += pair.second;</span><br><span class="line">            <span class="keyword">if</span> (pair.second &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i].insert(pair.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : result[i]) &#123;</span><br><span class="line">            s.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (visited[c]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;cc : nodes[c]) &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][cc.first] += cc.second;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[i][cc.first] &gt; <span class="number">50</span>) &#123;</span><br><span class="line">                    result[i].insert(cc.first);</span><br><span class="line">                    s.push(cc.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[c] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = result[i].begin(); iter != result[i].end(); ++iter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == *iter) <span class="keyword">continue</span>;</span><br><span class="line">            fout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.3 Money System]]></title>
      <url>http://lianghan.org/2016/09/26/2016-09-26-USACO-MoneySystem/</url>
      <content type="html"><![CDATA[<p>Very classic DP problem.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> COINS;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">100001</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; coins;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COINS; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= N; ++j) &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"money.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"money.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; COINS &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COINS; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c; fin &gt;&gt; c; coins.emplace_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    compute();</span><br><span class="line">    fout &lt;&lt; dp[N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.3 Zero Sum]]></title>
      <url>http://lianghan.org/2016/09/25/2016-09-25-USACO-ZeroSum/</url>
      <content type="html"><![CDATA[<p>Brutal force DFS search.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ops = &#123;<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">' '</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == N) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, cur = <span class="number">1</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> op = s[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">' '</span>) &#123;</span><br><span class="line">                cur = cur * <span class="number">10</span> + i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += cur * sign;</span><br><span class="line">                cur = i;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">'+'</span>) &#123;</span><br><span class="line">                    sign = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sign = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += cur * sign;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : ops) &#123;</span><br><span class="line">        s.push_back(c);</span><br><span class="line">        dfs(i + <span class="number">1</span>);</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"zerosum.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"zerosum.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    sort(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;result : res) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            fout &lt;&lt; i &lt;&lt; result[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        fout &lt;&lt; N &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.3 Cow Pedigrees]]></title>
      <url>http://lianghan.org/2016/09/24/2016-09-24-USACO-CowPedigrees/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"nocows.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"nocows.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(K + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j+= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                dp[i][j] = (dp[i][j] +</span><br><span class="line">                            dp[i - <span class="number">1</span>][k] * dp[i - <span class="number">1</span>][j - k - <span class="number">1</span>]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = (dp[K][N] - dp[K - <span class="number">1</span>][N] + MOD) % MOD;</span><br><span class="line">    fout &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.3 Longest Prefix]]></title>
      <url>http://lianghan.org/2016/09/22/2016-09-22-USACO-LongestPrefix/</url>
      <content type="html"><![CDATA[<p>Typical dyanmic programming problem as the string matching can be broken into sub problems which overlap with each other.</p>
<p>Key observations:</p>
<ul>
<li>Let’s have dp[i] represents the longest possible prefix starting at index i, with i in the range of 0 to size - 1, with size being the length on the source string under match. The state transformation equation is: dp[i] = max(dp[i], dp[i] + j - i), if and only if substring starting from index i with length j - i is one of the dictionary string. With this, we search starting from the end of the string and once we finish, the answer would be dp[0].</li>
<li>Compute the state transformation from end to start of string (as we are searching for longest prefix.).</li>
</ul>
<p>Traps:</p>
<ul>
<li>The input string to match can span across multiple lines! So a single read will not possibly grab the entire source string; instead multiple reads might be required.</li>
<li>The important constraint when matching against primitives: primitives are all in length 1..10. Without this constraints, it is very easy to get timeout error on the last test case.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"prefix.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"prefix.out"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; pset;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> cur;</span><br><span class="line">    fin &gt;&gt; cur;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="string">"."</span>) &#123;</span><br><span class="line">        pset.insert(cur);</span><br><span class="line">        fin &gt;&gt; cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (!fin.eof()) &#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        fin &gt;&gt; str;</span><br><span class="line">        s += str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)s.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pset.count(s.substr(size - <span class="number">1</span>))) &#123;</span><br><span class="line">        dp[size - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= i + <span class="number">10</span> &amp;&amp; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = s.substr(i, j - i);</span><br><span class="line">            <span class="keyword">if</span> (pset.count(str)) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">std</span>::max(dp[i], dp[j] + j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; dp[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.2 Party Lamps]]></title>
      <url>http://lianghan.org/2016/09/20/2016-09-20-USACO-PartyLamps/</url>
      <content type="html"><![CDATA[<p>Search space would be huge so reducing and consolidating states is required. Key observations:</p>
<ol>
<li>Press same button twice yield no effect. Thus there is at most 2 ^ 4 = 16 switch state.</li>
<li>The switch state can be further reduced by enumerating all possible switch states and consolidate. Essentially, when the count of key press is larger than three, every switch state (among the maximum 16 states in total) could possibly appear.</li>
<li>The lamp state has a cycle of six.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Total # of lamps.</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="comment">// Total # of button pressed.</span></span><br><span class="line"><span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All possible final state, with different key combinations.</span></span><br><span class="line"><span class="comment">//char lampStates[][7] =</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; lampStates = &#123;</span><br><span class="line">     <span class="string">"111111"</span>,  <span class="comment">// (),(1,2,3)</span></span><br><span class="line">     <span class="string">"011011"</span>,  <span class="comment">// (1,2,3,4),(4)</span></span><br><span class="line">     <span class="string">"101010"</span>,  <span class="comment">// (1,2),(3)</span></span><br><span class="line">     <span class="string">"001110"</span>,  <span class="comment">// (1,2,4),(3,4)</span></span><br><span class="line">     <span class="string">"010101"</span>,  <span class="comment">// (1,3),(2)</span></span><br><span class="line">     <span class="string">"110001"</span>,  <span class="comment">// (1,3,4),(2,4)</span></span><br><span class="line">     <span class="string">"000000"</span>,  <span class="comment">// (1),(2,3)</span></span><br><span class="line">     <span class="string">"100100"</span>   <span class="comment">// (1,4),(2,3,4)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of key presses required to reach a given lampState[index].</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; keyStates = &#123; &#123;<span class="number">0</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; on(<span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; off(<span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((on[i] &amp;&amp; lampStates[index][i] == <span class="string">'0'</span>) ||</span><br><span class="line">            (off[i] &amp;&amp; lampStates[index][i] == <span class="string">'1'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Result &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Result&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(s.c_str(),  a.s.c_str()) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; result[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"lamps.in"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    fin &gt;&gt; C;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    fin &gt;&gt; cur;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="number">-1</span>) &#123;</span><br><span class="line">        on[(cur - <span class="number">1</span>) % <span class="number">6</span>] = <span class="literal">true</span>;</span><br><span class="line">        fin &gt;&gt; cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; cur;</span><br><span class="line">    <span class="keyword">while</span> (cur != - <span class="number">1</span>) &#123;</span><br><span class="line">        off[(cur - <span class="number">1</span>) % <span class="number">6</span>] = <span class="literal">true</span>;</span><br><span class="line">        fin &gt;&gt; cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    parseInput();</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"lamps.out"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(C &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>((keyStates[i][j] == C ||</span><br><span class="line">                    keyStates[i][j] == C - <span class="number">2</span>) &amp;&amp; validate(i))</span><br><span class="line">                    result[count++].s = lampStates[i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span>(validate(i)) &#123;</span><br><span class="line">                result[count++].s = lampStates[i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sort(result, result + count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = N;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">                fout &lt;&lt; result[i].s;</span><br><span class="line">                k -= <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                fout &lt;&lt; result[i].s[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Simulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TopCoder SRM 698]]></title>
      <url>http://lianghan.org/2016/09/17/2016-09-17-TopCoder-SRM698/</url>
      <content type="html"><![CDATA[<p>DIV2 500</p>
<p><a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=14390" target="_blank" rel="noopener">Problem Statement</a></p>
<p>Brutal force with LCS: this problem is easy if we can identify and transform the core matching algorithm it requires to LCS. Here two implementations of LCS are provided, one is through recursion the other is through explicitly maintaining a lookup table. For some reasons, the recursion solution time out on one system test.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will get TLE on one system test..</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((s1[m - <span class="number">1</span>] == s2[n - <span class="number">1</span>]) &amp;&amp; (m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + lcs(s1, s2, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> max(lcs(s1, s2, m, n - <span class="number">1</span>), lcs(s1, s2, m - <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RepeatStringEasy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalLength</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = <span class="string">""</span>, s2 = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= i; ++m) s1 += s[m];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = i + <span class="number">1</span>; n &lt; s.size(); ++n) s2 += s[n];</span><br><span class="line">            ret = <span class="built_in">std</span>::max(ret, <span class="number">2</span> * lcs2(s1, s2, (<span class="keyword">int</span>)s1.size(), (<span class="keyword">int</span>)s2.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.2 Runaround Numbers]]></title>
      <url>http://lianghan.org/2016/09/09/2016-09-09-USACO-Runaround%20Numbers/</url>
      <content type="html"><![CDATA[<p>Straight forward brutal force approach. Mainly test implementation skills.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRunaroundNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.find(d) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>[d] = <span class="number">0</span>;</span><br><span class="line">        num.push_back(d);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(num.begin(), num.end());</span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)num.size(), index = <span class="number">0</span>, next = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">map</span>[num[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (next != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = (index + num[index]) % size;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>[num[i]] != <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>[num[next]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">map</span>[num[next]]++;</span><br><span class="line">        index = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"runround.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"runround.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    ++N;</span><br><span class="line">    <span class="keyword">while</span> (!isRunaroundNumber(N++));</span><br><span class="line">    fout &lt;&lt; --N &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Brutal Force </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.2 Subset Sum]]></title>
      <url>http://lianghan.org/2016/09/08/2016-09-08-USACO-SubsetSum/</url>
      <content type="html"><![CDATA[<p>It’s tempting to solve this using brutal force search like dfs:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">int</span> expected;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; st;</span><br><span class="line"><span class="built_in">bitset</span>&lt;32&gt; bset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == expected &amp;&amp; !st.count(bset.to_ulong())) &#123;</span><br><span class="line">        st.insert(bset.to_ulong());</span><br><span class="line">        ++result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum &gt; expected) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= N ; ++i) &#123;</span><br><span class="line">        bset.<span class="built_in">set</span>(i);</span><br><span class="line">        dfs(sum + i, i + <span class="number">1</span>);</span><br><span class="line">        bset.flip(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"subset.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"subset.out"</span>)</span></span>;</span><br><span class="line">    bset.reset();</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    expected = (N + <span class="number">1</span>) * N / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (expected % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    expected /= <span class="number">2</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    fout &lt;&lt; result / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This solution however does not pass all tests, which has a time limit of 1 sec and a space limit of 16MB. The reason is the simple search will yield an exponential algorithm, given the state that we are about to explore is as much as 2^N, where N could be as large as 39. That said, it might be possible to optimize the search based algorithm using data structures that provides very optimized memory foot print with fast lookup, but I’ve not yet found such a data structure that satisfy the constraints.</p>
<p>Thinking from another perspective, the set / sum exhibits recursive nature and there are sub problems when solving each set partition, so dynamic programming is here for rescue:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> expected;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"subset.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"subset.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(<span class="number">40</span>, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">800</span>, <span class="number">0</span>));</span><br><span class="line">    expected = (N + <span class="number">1</span>) * N / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (expected % <span class="number">2</span>) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expected /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"expected :"</span> &lt;&lt; expected &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; N &lt;&lt; <span class="string">" "</span> &lt;&lt; expected &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= expected; ++j) &#123;</span><br><span class="line">            dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; dp[N][expected] / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.2 Preface Numbering]]></title>
      <url>http://lianghan.org/2016/09/07/2016-09-07-PrefaceNumbering/</url>
      <content type="html"><![CDATA[<p>Simple brutal force approach can pass the tests. We iterate through the numbers, for each number converting the numerical value of the number to Roman number representation and then counting.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[<span class="number">13</span>] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>,</span><br><span class="line">        <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *roman[<span class="number">13</span>] = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>,</span><br><span class="line">        <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= numbers[i]) &#123;</span><br><span class="line">            num -= numbers[i];</span><br><span class="line">            result += roman[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cmp &#123;</span><br><span class="line">    cmp() &#123;</span><br><span class="line">        <span class="keyword">char</span> nums[<span class="number">7</span>] = &#123;<span class="string">'I'</span>, <span class="string">'V'</span>, <span class="string">'X'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'M'</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[a] &lt; <span class="built_in">map</span>[b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"preface.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"preface.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, cmp&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> num = intToRoman(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : num) &#123;</span><br><span class="line">            mp[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator iter = mp.begin(); iter != mp.end(); ++iter) &#123;</span><br><span class="line">        fout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Brutal Force </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.1 Hamming Codes]]></title>
      <url>http://lianghan.org/2016/09/02/2016-09-02-USACO-HammingCode/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"hamming.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"hamming.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> N, B, D;</span><br><span class="line">  fin &gt;&gt; N &gt;&gt; B &gt;&gt; D;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">  result.push_back(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; count &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == N) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : result) &#123;</span><br><span class="line">      <span class="built_in">bitset</span>&lt;64&gt; diff(i ^ item);</span><br><span class="line">      <span class="keyword">if</span> (diff.count() &lt; D) &#123;</span><br><span class="line">        ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      ++count;</span><br><span class="line">      result.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); ++i) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    fout &lt;&lt; result[i];</span><br><span class="line">    <span class="keyword">if</span> ((count != <span class="number">0</span> &amp;&amp; count % <span class="number">10</span> == <span class="number">0</span>) || count == result.size())</span><br><span class="line">      fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      fout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.1 Healthy Holsteins]]></title>
      <url>http://lianghan.org/2016/08/31/2016-08-31-USACO-HealthyHolsteins/</url>
      <content type="html"><![CDATA[<p>Brutal force approach using bit set to speed up search.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V, vit[<span class="number">26</span>], G, feedType[<span class="number">16</span>][<span class="number">26</span>], vc;</span><br><span class="line"><span class="built_in">bitset</span>&lt;16&gt; minbit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"holstein.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"holstein.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  vc = <span class="number">16</span>;</span><br><span class="line">	fin &gt;&gt; V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; ++i)</span><br><span class="line">		fin &gt;&gt; vit[i];</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; G;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j &lt; V; ++j)</span><br><span class="line">      fin &gt;&gt; feedType[i][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> limit = <span class="number">1</span> &lt;&lt; G;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="built_in">bitset</span>&lt;16&gt; bit(i);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b != G; ++b) &#123;</span><br><span class="line">      <span class="keyword">if</span>(bit[b]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != V; ++j)</span><br><span class="line">          v[j] += feedType[b][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> satisfy = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span>(v[j] &lt; vit[j]) &#123;</span><br><span class="line">        satisfy = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(satisfy &amp;&amp; <span class="keyword">int</span>(bit.count()) &lt; vc &amp;&amp; bit.to_ulong() &gt; minbit.to_ulong()) &#123;</span><br><span class="line">			vc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bit.count());</span><br><span class="line">			minbit = bit;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fout &lt;&lt; vc;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(minbit[i])</span><br><span class="line">      fout &lt;&lt; <span class="string">" "</span> &lt;&lt; i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Brutal Force </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.1 Sort Three Valued Sequence]]></title>
      <url>http://lianghan.org/2016/08/31/2016-08-31-USACO-SortThreeValuedSequence/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"sort3.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"sort3.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count[<span class="number">4</span>], a[<span class="number">4</span>], t[<span class="number">1001</span>], x, n, k = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="keyword">sizeof</span>(count));</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (fin &gt;&gt; x) &#123;</span><br><span class="line">    count[x]++;</span><br><span class="line">    t[++k] = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count[<span class="number">1</span>] + count[<span class="number">2</span>]; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[i] == <span class="number">3</span>)</span><br><span class="line">      a[<span class="number">3</span>]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="number">2</span> &amp;&amp; i &lt;= count[<span class="number">1</span>])</span><br><span class="line">      a[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="number">1</span> &amp;&amp; i &gt; count[<span class="number">1</span>])</span><br><span class="line">      a[<span class="number">2</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; a[<span class="number">3</span>] + (a[<span class="number">1</span>] &gt; a[<span class="number">2</span>] ? a[<span class="number">1</span>] : a[<span class="number">2</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.1 Ordered Fraction]]></title>
      <url>http://lianghan.org/2016/08/30/2016-08-30-USACO-OrderedFraction/</url>
      <content type="html"><![CDATA[<p>Brutal force search.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    swap(a, b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"frac1.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"frac1.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  fin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (gcd(j, i) == <span class="number">1</span>)</span><br><span class="line">        vec.emplace_back(make_pair(j, i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sort(vec.begin(), vec.end(), [] (<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;lhs,</span><br><span class="line">                                   <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(lhs.first) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(lhs.second)) &lt;</span><br><span class="line">    (<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(rhs.first) / (<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(rhs.second)));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : vec)</span><br><span class="line">    fout &lt;&lt; item.first &lt;&lt;  <span class="string">"/"</span> &lt;&lt; item.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Brutal Force </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 2.1 The Carstle]]></title>
      <url>http://lianghan.org/2016/08/26/2016-08-26-USACO-TheCarstle/</url>
      <content type="html"><![CDATA[<p>This problem is a typical graph / grid search problem and the solution is also obvious (flood fill is your best friend.). The challenge is to properly transform the problem into right data structure.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> dir;</span><br><span class="line"><span class="keyword">bool</span> visited[maxn][maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>  dx[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>  dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>  N, M, t, row, col, color = <span class="number">1</span>, rSize = <span class="number">-1</span>, maxSize = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  roomSize(maxn * maxn, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// last dimension - Index 0/1/2/3 walls 4 color.</span></span><br><span class="line"><span class="keyword">int</span> castle[maxn][maxn][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floodFill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">  ++roomSize[color];</span><br><span class="line">  castle[x][y][<span class="number">4</span>] = color;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">    <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= N || ny &gt;= M) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[nx][ny] || castle[x][y][i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    floodFill(nx, ny);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; castle[x - <span class="number">1</span>][y][<span class="number">4</span>] != castle[x][y][<span class="number">4</span>]) &#123;</span><br><span class="line">    sum = roomSize[castle[x - <span class="number">1</span>][y][<span class="number">4</span>]] + roomSize[castle[x][y][<span class="number">4</span>]];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; maxSize) &#123;</span><br><span class="line">      maxSize = sum;</span><br><span class="line">      row = x, col = y, dir = <span class="string">'N'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (y &lt; M - <span class="number">1</span> &amp;&amp; castle[x][y + <span class="number">1</span>][<span class="number">4</span>] != castle[x][y][<span class="number">4</span>]) &#123;</span><br><span class="line">    sum = roomSize[castle[x][y + <span class="number">1</span>][<span class="number">4</span>]] + roomSize[castle[x][y][<span class="number">4</span>]];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; maxSize) &#123;</span><br><span class="line">      maxSize = sum;</span><br><span class="line">      row = x, col = y, dir = <span class="string">'E'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"castle.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"castle.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">      fin &gt;&gt; t;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">3</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        castle[i][j][k] = t%<span class="number">2</span>;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      castle[i][j][<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited[i][j]) &#123;</span><br><span class="line">        floodFill(i, j);</span><br><span class="line">        ++color;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rSize = *max_element(roomSize.begin(), roomSize.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">      merge(j, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; color - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fout &lt;&lt; rSize &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fout &lt;&lt; maxSize &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fout &lt;&lt; row + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; col + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; dir &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Flood Fill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.5 SuperPrime Rib]]></title>
      <url>http://lianghan.org/2016/08/20/2016-08-20-USACO-SuperPrimeRib/</url>
      <content type="html"><![CDATA[<p>A straight forward combination generation problem that can be solved using DFS / Backtrack technique.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number == <span class="number">3</span> || number == <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span> || number % <span class="number">5</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> m = <span class="built_in">sqrt</span>(number);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (number % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prev, ofstream &amp;fout)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidate;</span><br><span class="line">  <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">    candidate = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : candidate)</span><br><span class="line">      fout &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index == N) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : prev)</span><br><span class="line">        fout &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  candidate = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : prev) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;number : candidate) &#123;</span><br><span class="line">      <span class="keyword">auto</span> i = item * <span class="number">10</span> + number;</span><br><span class="line">      <span class="keyword">if</span> (isPrime(i))</span><br><span class="line">        tmp.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tmp.size())</span><br><span class="line">    dfs(index + <span class="number">1</span>, N, tmp, fout);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"sprime.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"sprime.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  fin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">  dfs(<span class="number">1</span>, N, prev, fout);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Backtrack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.5 Number Triangles]]></title>
      <url>http://lianghan.org/2016/08/20/2016-08-20-USACO-NumberTriangles/</url>
      <content type="html"><![CDATA[<p>Simple DP problem.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTriangle</span><span class="params">(ifstream &amp;fin, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;triangle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> total;</span><br><span class="line">  fin &gt;&gt; total;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> prev = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; current;</span><br><span class="line">    <span class="keyword">int</span> cur = prev;</span><br><span class="line">    <span class="keyword">while</span> (cur--) &#123;</span><br><span class="line">      <span class="keyword">int</span> item;</span><br><span class="line">      fin &gt;&gt; item;</span><br><span class="line">      current.emplace_back(item);</span><br><span class="line">    &#125;</span><br><span class="line">    triangle.push_back(current);</span><br><span class="line">    ++prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;triangle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rows = (<span class="keyword">int</span>)triangle.size();</span><br><span class="line">  <span class="keyword">if</span> (!rows) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (rows == <span class="number">1</span>) <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; table(triangle[rows - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = rows - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); ++j)</span><br><span class="line">      table[j] = <span class="built_in">std</span>::max(table[j+<span class="number">1</span>], table[j]) + triangle[i][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> table[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"numtri.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"numtri.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; triangle;</span><br><span class="line">  getTriangle(fin, triangle);</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; findMaxPath(triangle) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.4 Mother's Milk]]></title>
      <url>http://lianghan.org/2016/08/20/2016-08-20-USACO-Mother's%20Milk/</url>
      <content type="html"><![CDATA[<p>This is a search problem and the search space is the set of states of the bucket which can be encoded as a three dimensional array. The idea is to do an exhaustive search on all valid states by starting from the initial state, and this algorithm will at some point converge and reach a fixed point where all states are visited. Use the three dimensional array to store the state might be a little bit waste considering the state can be abstracted by the values in bucket B and C, so the state encoding can be optimized.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> capacity[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> State &#123;</span><br><span class="line">  <span class="keyword">int</span> water[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">State <span class="title">pour</span><span class="params">(State state, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">  State next = state;</span><br><span class="line">  <span class="keyword">int</span> water = min(state.water[from], capacity[to] - state.water[to]);</span><br><span class="line">  next.water[from] -= water;</span><br><span class="line">  next.water[to] += water;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">satisfy</span><span class="params">(State &amp;state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state.water[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"milk3.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"milk3.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; capacity[<span class="number">0</span>] &gt;&gt; capacity[<span class="number">1</span>] &gt;&gt; capacity[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.water[<span class="number">0</span>] = <span class="number">0</span>; state.water[<span class="number">1</span>] = <span class="number">0</span>; state.water[<span class="number">2</span>] = capacity[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&gt; visited(capacity[<span class="number">0</span>] + <span class="number">1</span>,</span><br><span class="line">                                       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(capacity[<span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                                                            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(capacity[<span class="number">2</span>] + <span class="number">1</span>, <span class="literal">false</span>)));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= capacity[<span class="number">0</span>]; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt;= capacity[<span class="number">1</span>]; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt;= capacity[<span class="number">2</span>]; ++k)</span><br><span class="line">        visited[i][j][k] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">stack</span>&lt;State&gt; <span class="built_in">stack</span>;</span><br><span class="line">  <span class="built_in">stack</span>.emplace(state);</span><br><span class="line">  visited[state.water[<span class="number">0</span>]][state.water[<span class="number">1</span>]][state.water[<span class="number">2</span>]] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (satisfy(state))</span><br><span class="line">    result.push_back(state.water[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">stack</span>.top();</span><br><span class="line">    <span class="built_in">stack</span>.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        State next = pour(s, i, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[next.water[<span class="number">0</span>]][next.water[<span class="number">1</span>]][next.water[<span class="number">2</span>]]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (satisfy(next))</span><br><span class="line">          result.push_back(next.water[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">stack</span>.emplace(next);</span><br><span class="line">        visited[next.water[<span class="number">0</span>]][next.water[<span class="number">1</span>]][next.water[<span class="number">2</span>]] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sort(result.begin(), result.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i  = <span class="number">0</span>; i &lt; result.size() - <span class="number">1</span>; ++i)</span><br><span class="line">    fout &lt;&lt; result[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  fout &lt;&lt; result[result.size() - <span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.4 Arithmetic Progression]]></title>
      <url>http://lianghan.org/2016/08/18/2016-08-18-USACO-ArithmeticProgression/</url>
      <content type="html"><![CDATA[<p>Brutal force, pretty ugly code. Need optimize.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"ariprog.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"ariprog.out"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> SIZE = <span class="number">250</span>;</span><br><span class="line">  <span class="keyword">int</span> N, M;</span><br><span class="line">  fin &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="built_in">set</span>(SIZE * SIZE * <span class="number">2</span> + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">      <span class="built_in">set</span>[i * i + j * j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">  <span class="keyword">auto</span> limit = M * M * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) &#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; limit - i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j * (N - <span class="number">1</span>) + i &gt; limit) &#123;</span><br><span class="line">        found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = N - <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">auto</span> val = i + k * j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &gt; limit) &#123;</span><br><span class="line">          found = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">set</span>[val]) &#123;</span><br><span class="line">          found = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        result.emplace_back(<span class="built_in">std</span>::make_pair(i, j));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sort(result.begin(), result.end(), [] (<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;lhs,</span><br><span class="line">                                         <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.second != rhs.second ? lhs.second &lt; rhs.second : lhs.first &lt; rhs.first;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> item : result) &#123;</span><br><span class="line">    fout &lt;&lt; item.first &lt;&lt; <span class="string">" "</span> &lt;&lt; item.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!result.size())</span><br><span class="line">    fout &lt;&lt; <span class="string">"NONE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Brutal Force </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.3 Ski Course Design]]></title>
      <url>http://lianghan.org/2016/08/17/2016-8-17-USACO-SkiCourseDesign/</url>
      <content type="html"><![CDATA[<p>At first glance, a reasonable approach seems to sort the heights of hills then starting from both ends (smallest and biggest), adjust and iterate and converge to a fixed point. However, the problem has a constraint that for each hill only a single change can be made, so this would not work. Think in the other direction, given the constraints each hill has to end up with a height that’s fall in the range of 0 to 83 (inclusive), so we can simply use brutal force to iterate that for each range, what would be the overall cost to adjust all hills.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hills;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = INT_MAX;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">83</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;h : hills) &#123;</span><br><span class="line">      <span class="keyword">if</span> (h &lt; i) &#123;</span><br><span class="line">        result += <span class="built_in">pow</span>(i - h, <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (h &gt; i + <span class="number">17</span>) &#123;</span><br><span class="line">        result += <span class="built_in">pow</span>(h -i - <span class="number">17</span>, <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = min(ret, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"skidesign.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"skidesign.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    fin &gt;&gt; h;</span><br><span class="line">    hills.emplace_back(h);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ret = compute();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Brutal Force </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.3 Wormholes]]></title>
      <url>http://lianghan.org/2016/08/17/2016-08-17-USACO-WormHoles/</url>
      <content type="html"><![CDATA[<p>The problem can be reduced to two sub problems:</p>
<ul>
<li>Generate all combinations of pairs. This can be solved using backtrack.</li>
<li>For each combination test if there is a cycle. This can be solved by exhaustive search: starting from each wormhole, and try move the number of total wormholes, and repeat, until all wormholes are tested.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxHoles = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vx(kMaxHoles + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vy(kMaxHoles + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextWormhole(kMaxHoles + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vpair(kMaxHoles + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(kMaxHoles + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>; start &lt;= total; ++start)&#123;</span><br><span class="line">    <span class="keyword">int</span> current = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> move = <span class="number">1</span>; move &lt;= total; ++move)</span><br><span class="line">      current = nextWormhole[vpair[current]];</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrack</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> unpaired = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vpair[i] == <span class="number">0</span>)&#123;</span><br><span class="line">      unpaired = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unpaired == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasCycle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> topair = unpaired + <span class="number">1</span>; topair &lt;= total; ++topair)</span><br><span class="line">    <span class="keyword">if</span> (vpair[topair]  == <span class="number">0</span>)&#123;</span><br><span class="line">      vpair[unpaired] = topair;</span><br><span class="line">      vpair[topair] = unpaired;</span><br><span class="line">      result += backtrack();</span><br><span class="line">      vpair[unpaired] = <span class="number">0</span>;</span><br><span class="line">      vpair[topair] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"wormhole.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"wormhole.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  fin &gt;&gt; total;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total; ++i) &#123;</span><br><span class="line">    fin &gt;&gt; vx[i] &gt;&gt; vy[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vx[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; vy[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> current, next;</span><br><span class="line">  <span class="keyword">for</span> (current = <span class="number">1</span>; current &lt;= total; ++current) &#123;</span><br><span class="line">    <span class="keyword">for</span> (next = <span class="number">1</span>; next &lt;= total; ++next)&#123;</span><br><span class="line">      <span class="keyword">if</span> (vy[current] != vy[next] || vx[next] &lt;= vx[current]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (nextWormhole[current] == <span class="number">0</span> || vx[next] &lt; vx[nextWormhole[current]]) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"current : "</span> &lt;&lt; current &lt;&lt; <span class="string">"; next : "</span> &lt;&lt; next &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        nextWormhole[current] = next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nextWormhole[i] &lt;&lt; <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; backtrack() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.3 Combation Lock]]></title>
      <url>http://lianghan.org/2016/08/13/2016-08-13-USACO-CombinationLock/</url>
      <content type="html"><![CDATA[<p>Reduce to a search problem, pay attion to the search space. Code can be further optimized.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num + N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> num - N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getCandidate(<span class="keyword">int</span> num, <span class="keyword">int</span> N) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> range;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">        range = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>) &#123;</span><br><span class="line">        range = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        range = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -range &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = -range; i &lt;= range; ++i) &#123;</span><br><span class="line">        ret.emplace_back(wrap(num + i, N));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"combo.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"combo.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lock(<span class="number">3</span>, <span class="number">0</span>), master(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a, b;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; lock[i];</span><br><span class="line">        a.emplace_back(getCandidate(lock[i], N));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; master[i];</span><br><span class="line">        b.emplace_back(getCandidate(master[i], N));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[<span class="number">0</span>].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[<span class="number">1</span>].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a[<span class="number">2</span>].size(); ++k) &#123;</span><br><span class="line">                s.insert(make_tuple(a[<span class="number">0</span>][i], a[<span class="number">1</span>][j], a[<span class="number">2</span>][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b[<span class="number">0</span>].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[<span class="number">1</span>].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; b[<span class="number">2</span>].size(); ++k) &#123;</span><br><span class="line">                s.insert(make_tuple(b[<span class="number">0</span>][i], b[<span class="number">1</span>][j], b[<span class="number">2</span>][k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : s) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(item) &lt;&lt; <span class="string">","</span></span><br><span class="line">        &lt;&lt; get&lt;<span class="number">1</span>&gt;(item) &lt;&lt; <span class="string">","</span></span><br><span class="line">        &lt;&lt; get&lt;<span class="number">2</span>&gt;(item) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Combination </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.2 Dual Palindrome]]></title>
      <url>http://lianghan.org/2016/08/11/2016-08-11-USACO-DualPalindrome/</url>
      <content type="html"><![CDATA[<p>Another implementation skill test for base conversion.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = str.size() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getNumber</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> BASE)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> str;</span><br><span class="line">  <span class="keyword">int</span> base = BASE;</span><br><span class="line">  <span class="keyword">while</span> (number) &#123;</span><br><span class="line">    <span class="keyword">int</span> digit = number % base;</span><br><span class="line">    <span class="keyword">int</span> factor = base / BASE;</span><br><span class="line">    digit /= factor;</span><br><span class="line">    str.push_back(digit + <span class="string">'0'</span>);</span><br><span class="line">    number -= digit * factor;</span><br><span class="line">    base *= BASE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"dualpal.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"dualpal.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> N, S;</span><br><span class="line">  fin &gt;&gt; N &gt;&gt; S;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = S + <span class="number">1</span>, j = <span class="number">0</span>; j &lt; N;) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">10</span>; ++k) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &gt; N) <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">string</span> num = getNumber(i, k);</span><br><span class="line">      <span class="keyword">if</span> (isPalindrome(num)) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">          fout &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          ++j; ++i;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">2</span>) ++i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Base Conversion </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TopCoder SRM 696]]></title>
      <url>http://lianghan.org/2016/08/10/2016-08-09-TopCoderSRM696/</url>
      <content type="html"><![CDATA[<figure class="highlight cpp"><figcaption><span>250_Rope_String</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Ropestring &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makerope</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; even, odd;</span><br><span class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>)s.size();</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>)</span><br><span class="line">                ++cur;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur % <span class="number">2</span>) &#123;</span><br><span class="line">                        odd.push_back(cur);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        even.push_back(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[size - <span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur % <span class="number">2</span>) &#123;</span><br><span class="line">                odd.push_back(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even.push_back(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(odd.begin(), odd.end());</span><br><span class="line">        sort(even.begin(), even.end());</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)even.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = even[i];</span><br><span class="line">            <span class="keyword">while</span> (size) &#123;</span><br><span class="line">                ret.push_back(<span class="string">'-'</span>);</span><br><span class="line">                ++count;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                ret.push_back(<span class="string">'.'</span>); ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!even.empty() &amp;&amp; !odd.empty()) &#123;</span><br><span class="line">            ret.push_back(<span class="string">'.'</span>); ++count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)(odd.size() - <span class="number">1</span>); i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = odd[i];</span><br><span class="line">            <span class="keyword">while</span> (size) &#123;</span><br><span class="line">                ret.push_back(<span class="string">'-'</span>);</span><br><span class="line">                ++count;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                ret.push_back(<span class="string">'.'</span>); ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = (<span class="keyword">int</span>)s.size() - count;</span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            ret.push_back(<span class="string">'.'</span>); --left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>500_Array_Fix</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Arrfix &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mindiff</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; B, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; F)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashb;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : B) &#123;</span><br><span class="line">            hashb[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : F) &#123;</span><br><span class="line">            hashf[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>)A.size();</span><br><span class="line">        <span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == B[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (hashf[B[i]]) &#123;</span><br><span class="line">                hashf[B[i]]--;</span><br><span class="line">                ++used;</span><br><span class="line">                hashb[B[i]]--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++diff;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (used == (<span class="keyword">int</span>)F.size())</span><br><span class="line">            <span class="keyword">return</span> diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = hashf.begin(); iter != hashf.end(); ++iter) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = iter-&gt;first;</span><br><span class="line">            <span class="keyword">int</span> count = iter-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (hashb[key]) &#123;</span><br><span class="line">                hashb[key]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.2 Palindrome Square]]></title>
      <url>http://lianghan.org/2016/08/09/2016-08-09-PalindromeSquare/</url>
      <content type="html"><![CDATA[<p>This problem is very straightforward to solve, just pay attention to implementation details.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = str.size() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i] != str[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getNumber</span><span class="params">(<span class="keyword">int</span> number, <span class="keyword">int</span> BASE, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> str;</span><br><span class="line">  <span class="keyword">int</span> base = BASE;</span><br><span class="line">  <span class="keyword">while</span> (number) &#123;</span><br><span class="line">    <span class="keyword">int</span> digit = number % base;</span><br><span class="line">    <span class="keyword">int</span> factor = base / BASE;</span><br><span class="line">    digit /= factor;</span><br><span class="line">    str.push_back(table[digit]);</span><br><span class="line">    number -= digit * factor;</span><br><span class="line">    base *= BASE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reverse(str.begin(), str.end());</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; table = &#123; <span class="string">'0'</span> , <span class="string">'1'</span> , <span class="string">'2'</span> , <span class="string">'3'</span> , <span class="string">'4'</span> , <span class="string">'5'</span> , <span class="string">'6'</span> , <span class="string">'7'</span> , <span class="string">'8'</span> , <span class="string">'9'</span> ,</span><br><span class="line">    <span class="string">'A'</span> , <span class="string">'B'</span> , <span class="string">'C'</span> , <span class="string">'D'</span> , <span class="string">'E'</span> , <span class="string">'F'</span> , <span class="string">'G'</span> , <span class="string">'H'</span> , <span class="string">'I'</span> , <span class="string">'J'</span> &#125; ;</span><br><span class="line"></span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"palsquare.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"palsquare.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> BASE;</span><br><span class="line">  fin &gt;&gt; BASE;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">string</span> num = getNumber(i * i, BASE, table);</span><br><span class="line">    <span class="keyword">if</span> (isPalindrome(num)) &#123;</span><br><span class="line">      fout &lt;&lt; getNumber(i, BASE, table) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      fout &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.2 Name That Number]]></title>
      <url>http://lianghan.org/2016/08/08/2016-08-08-NameThatNumber/</url>
      <content type="html"><![CDATA[<p>This is a search problem and the key is to figure out the search space. Given the input number, we can generate all possible combinations of the valid words and use these words as search space. The other approach is to generate all possible numbers from the input dictionary and then use these numbers as search space. Obviously, given the input constraints (a list of fewer than 5,000 acceptable cattle names), the number search space is more practical.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name2number</span><span class="params">(<span class="built_in">string</span> name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">ostringstream</span> buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> c : name)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; <span class="string">'Q'</span>)</span><br><span class="line">      value = (c - <span class="number">1</span> - <span class="string">'A'</span>) / <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      value = (c - <span class="string">'A'</span>) / <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    buf &lt;&lt; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buf.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"namenum.out"</span>)</span></span>;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"namenum.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ifstream <span class="title">dict_fin</span><span class="params">(<span class="string">"dict.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line">  fin &gt;&gt; value;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">bool</span> not_found = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(dict_fin &gt;&gt; name)&#123;</span><br><span class="line">    <span class="built_in">string</span> number = name2number(name);</span><br><span class="line">    <span class="keyword">if</span>(number != value)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    fout &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    not_found = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(not_found)</span><br><span class="line">    fout&lt;&lt;<span class="string">"NONE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  dict_fin.close();</span><br><span class="line">  fin.close();</span><br><span class="line">  fout.close();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.2 Transformation]]></title>
      <url>http://lianghan.org/2016/08/08/%202016-08-08-Transformation/</url>
      <content type="html"><![CDATA[<p>Brutal force search… and a Hexo bug that prevent syntax being highlighted!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; MATRIX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateMatrix90</span><span class="params">(MATRIX &amp;matrix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> size = matrix.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">      swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(matrix[i].begin(), matrix[i].end());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateMatrix180</span><span class="params">(MATRIX &amp;matrix)</span> </span>&#123;</span><br><span class="line">  rotateMatrix90(matrix);</span><br><span class="line">  rotateMatrix90(matrix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateMatrix270</span><span class="params">(MATRIX &amp;matrix)</span> </span>&#123;</span><br><span class="line">  rotateMatrix90(matrix);</span><br><span class="line">  rotateMatrix180(matrix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reflectMatrixHorizontal</span><span class="params">(MATRIX &amp;matrix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(matrix.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = size - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; ++k)</span><br><span class="line">      swap(matrix[k][i], matrix[k][j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMatrix</span><span class="params">(MATRIX &amp;matrix, ifstream &amp;fin)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> demension = matrix.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demension; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; demension; ++j) &#123;</span><br><span class="line">      fin &gt;&gt; matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> str;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"transform.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"transform.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> demension;</span><br><span class="line">  fin &gt;&gt; demension;</span><br><span class="line">  MATRIX matrix(demension, vector&lt;char&gt;(demension, ' '));</span><br><span class="line">  initializeMatrix(matrix, fin);</span><br><span class="line"></span><br><span class="line">  MATRIX baseline(demension, vector&lt;char&gt;(demension, ' '));</span><br><span class="line">  initializeMatrix(baseline, fin);</span><br><span class="line"></span><br><span class="line">  MATRIX old = matrix;</span><br><span class="line"></span><br><span class="line">  rotateMatrix90(matrix);</span><br><span class="line">  <span class="keyword">if</span> (baseline == matrix) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  matrix = old;</span><br><span class="line">  rotateMatrix180(matrix);</span><br><span class="line">  <span class="keyword">if</span> (baseline == matrix) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  matrix = old;</span><br><span class="line">  rotateMatrix270(matrix);</span><br><span class="line">  <span class="keyword">if</span> (baseline == matrix) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  matrix = old;</span><br><span class="line">  reflectMatrixHorizontal(matrix);</span><br><span class="line">  <span class="keyword">if</span> (baseline == matrix) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MATRIX reflected = matrix;</span><br><span class="line">  rotateMatrix90(matrix);</span><br><span class="line">  <span class="keyword">if</span> (matrix == baseline) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  matrix = reflected;</span><br><span class="line">  rotateMatrix180(matrix);</span><br><span class="line">  <span class="keyword">if</span> (matrix == baseline) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  matrix = reflected;</span><br><span class="line">  rotateMatrix270(matrix);</span><br><span class="line">  <span class="keyword">if</span> (matrix == baseline) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  matrix = old;</span><br><span class="line">  <span class="keyword">if</span> (matrix == baseline) &#123;</span><br><span class="line">    fout &lt;&lt; <span class="number">6</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; <span class="number">7</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.2 Milking Cows]]></title>
      <url>http://lianghan.org/2016/08/08/2016-08-08-MilkingCows/</url>
      <content type="html"><![CDATA[<p>Simple brutal force search with intervals.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Interval &#123;</span><br><span class="line">  <span class="keyword">int</span> start, end;</span><br><span class="line">  Interval(<span class="keyword">int</span> start, <span class="keyword">int</span> end) : start(start), end(end) &#123;&#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Interval&amp; interval) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start &lt; interval.start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> str;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"milk2.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"milk2.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;Interval&gt; intervals;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> farmers;</span><br><span class="line">  fin &gt;&gt; farmers;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; farmers; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    fin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">    intervals.emplace_back(Interval(start, end));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::sort(intervals.begin(), intervals.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maxOverlap = <span class="number">0</span>, maxGap = <span class="number">0</span>;</span><br><span class="line">  Interval it = intervals[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals[i].start &gt; it.end) &#123;</span><br><span class="line">      <span class="comment">// none overlap</span></span><br><span class="line">      maxOverlap = <span class="built_in">std</span>::max(maxOverlap, it.end - it.start);</span><br><span class="line">      maxGap = <span class="built_in">std</span>::max(maxGap, intervals[i].start - it.end);</span><br><span class="line">      it = intervals[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      it.end = <span class="built_in">std</span>::max(it.end, intervals[i].end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  maxOverlap = <span class="built_in">std</span>::max(maxOverlap, it.end - it.start);</span><br><span class="line"></span><br><span class="line">  fout &lt;&lt; maxOverlap &lt;&lt; <span class="string">" "</span> &lt;&lt; maxGap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.1 Broken Necklace]]></title>
      <url>http://lianghan.org/2016/08/06/2016-08-06%EF%BC%8DUSACO-BrokenNecklace/</url>
      <content type="html"><![CDATA[<p>Brutal force O(N^2) solution.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> str;</span><br><span class="line">  <span class="keyword">int</span> n, i, l, r, mx = <span class="number">0</span>;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"beads.in"</span>)</span></span>;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"beads.out"</span>)</span></span>;</span><br><span class="line">  fin &gt;&gt; n;</span><br><span class="line">  fin &gt;&gt; str;</span><br><span class="line">  str += str;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    l = r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> flag;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; n) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span>(str[j] == <span class="string">'w'</span>)</span><br><span class="line">        j++;</span><br><span class="line">      flag = str[j];</span><br><span class="line">      <span class="keyword">if</span> (str[k] == flag || str[k] == <span class="string">'w'</span>)</span><br><span class="line">        k++, l++;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k = i + n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; n) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span>(str[j] == <span class="string">'w'</span>)</span><br><span class="line">        j--;</span><br><span class="line">      <span class="keyword">if</span> (str[k] == str[i + n - <span class="number">1</span>] || str[k] == <span class="string">'w'</span>)</span><br><span class="line">        k--, r++;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l + r &gt; mx) mx = l + r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mx &gt; n) mx = n;</span><br><span class="line">  fout &lt;&lt; mx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.1 Friday]]></title>
      <url>http://lianghan.org/2016/08/06/2016-08-06-USACO-Friday/</url>
      <content type="html"><![CDATA[<p>Straightforward brutal force implementation.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Checker &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> day, year, offset;</span><br><span class="line"></span><br><span class="line">  Checker() : day(<span class="number">1</span>), year(<span class="number">1900</span>), offset(<span class="number">1</span>) &#123;</span><br><span class="line">    frequentCounterList = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    month2days = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> month = <span class="number">1</span>; month &lt;= <span class="number">12</span>; ++month) &#123;</span><br><span class="line">        day = offset + <span class="number">12</span>;</span><br><span class="line">        frequentCounterList[day % <span class="number">7</span> + <span class="number">1</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (month == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isLeapYear(year))</span><br><span class="line">            offset += <span class="number">29</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            offset += <span class="number">28</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          offset += month2days[month];</span><br><span class="line">      &#125;</span><br><span class="line">      ++year;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getFrequency() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> frequentCounterList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; frequentCounterList;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; month2days;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">100</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"friday.out"</span>)</span></span>;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"friday.in"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> years;</span><br><span class="line">  getline(fin, years);</span><br><span class="line">  Checker checker;</span><br><span class="line">  checker.traverse(stoi(years));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> <span class="built_in">list</span> = checker.getFrequency();</span><br><span class="line">  fout &lt;&lt; <span class="built_in">list</span>[<span class="number">7</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">list</span>[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">  <span class="built_in">list</span>[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">list</span>[<span class="number">3</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">list</span>[<span class="number">4</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">list</span>[<span class="number">5</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt;</span><br><span class="line">  <span class="built_in">list</span>[<span class="number">6</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.1 Greedy Gift Givers]]></title>
      <url>http://lianghan.org/2016/08/06/2016-08-06-USACO-Greedy-Gift-Givers/</url>
      <content type="html"><![CDATA[<p>The algorithm is simple but it is a pain in the ass to parse input and extract names.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Person*&gt; toList;</span><br><span class="line">  <span class="keyword">int</span> money;</span><br><span class="line">  <span class="keyword">int</span> left;</span><br><span class="line">  <span class="keyword">int</span> sum;</span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">  Person(<span class="built_in">string</span> name) : size(<span class="number">0</span>), money(<span class="number">0</span>), left(<span class="number">0</span>), name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"gift1.out"</span>)</span></span>;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"gift1.in"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> input;</span><br><span class="line">  getline(fin, input);</span><br><span class="line">  <span class="keyword">int</span> total = stoi(input);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Each line contains the name of a group member</span></span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, Person*&gt; hashmap;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Person*&gt; personList;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i) &#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    getline(fin, name);</span><br><span class="line">    <span class="keyword">auto</span> person = <span class="keyword">new</span> Person(name);</span><br><span class="line">    hashmap[name] = person;</span><br><span class="line">    personList.push_back(person);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   The first line in the group tells the person's name who will be giving gifts.</span></span><br><span class="line"><span class="comment">   The second line in the group contains two numbers: The initial amount of money (in the range 0..2000) to be divided up into gifts by the giver and then the number of people to whom the giver will give gifts, NGi (0 ≤ NGi ≤ NP-1).</span></span><br><span class="line"><span class="comment">   If NGi is nonzero, each of the next NGi lines lists the the name of a recipient of a gift.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i) &#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    getline(fin, name);</span><br><span class="line">    <span class="keyword">auto</span> person = hashmap[name];</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; person-&gt;money &gt;&gt; person-&gt;size;</span><br><span class="line">    <span class="built_in">string</span> newline;</span><br><span class="line">    getline(fin, newline);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!person-&gt;size)</span><br><span class="line">      person-&gt;left = person-&gt;money;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (person-&gt;size == <span class="number">1</span>)</span><br><span class="line">      person-&gt;left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      person-&gt;left = person-&gt;money % person-&gt;size;</span><br><span class="line"></span><br><span class="line">    person-&gt;sum = person-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (person-&gt;size) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; person-&gt;size; ++j) &#123;</span><br><span class="line">        <span class="built_in">string</span> toName;</span><br><span class="line">        getline(fin, toName);</span><br><span class="line">        person-&gt;toList.push_back(hashmap[toName]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : hashmap) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!item.second-&gt;size) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> money = (item.second-&gt;money - item.second-&gt;left) / item.second-&gt;size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;toPerson : item.second-&gt;toList) &#123;</span><br><span class="line">      toPerson-&gt;sum += money;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;person : personList) &#123;</span><br><span class="line">    fout &lt;&lt; person-&gt;name &lt;&lt; <span class="string">" "</span> &lt;&lt; person-&gt;sum - person-&gt;money &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[USACO 1.1 - Your Ride Is Here]]></title>
      <url>http://lianghan.org/2016/08/06/2016-08-06-USACO-YourRideIsHere/</url>
      <content type="html"><![CDATA[<p>The easiest problem in USACO training.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"ride.out"</span>)</span></span>;</span><br><span class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"ride.in"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> comet, group;</span><br><span class="line">  getline(fin, comet);</span><br><span class="line">  getline(fin, group);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> valComet = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> valGroup = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : comet)</span><br><span class="line">    valComet *= (c - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">  valComet %= <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : group)</span><br><span class="line">    valGroup *= (c - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">  valGroup %= <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (valComet == valGroup)</span><br><span class="line">    fout &lt;&lt; <span class="string">"GO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fout &lt;&lt; <span class="string">"STAY"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> USACO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[A C++ implementation of DijKstra Algorithm]]></title>
      <url>http://lianghan.org/2016/08/03/2016-08-03-DijKstra/</url>
      <content type="html"><![CDATA[<p>DijKstra is a very useful algorithm used in graph search for finding single source shortest path. Devils are in details, here is a caninocal implementation of the algorithm in C++.</p>
<p>Like many graph problems, figure out the data structure and the representation of the graph is critical to the implementation of algorithm. Here we use graph’s object-pointer representation which naturally encodes both node relationships and edge weights.</p>
<p>To be able to reconstruct the shortest path we need to keep a vector that stores the ‘previous’ relationship for each vertice while we are figuring out the shortest path.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif" alt="Dijkstra_Animation"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [to node index, edge weight] pair.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge;</span><br><span class="line"><span class="comment">// [node index, distance to source] pair.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; element;</span><br><span class="line"><span class="keyword">class</span> compare &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> element&amp;a, <span class="keyword">const</span> element &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; &amp;graph, <span class="keyword">int</span> source, <span class="keyword">int</span> target,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph.size();</span><br><span class="line">  <span class="keyword">if</span> (!size) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (source &lt; <span class="number">0</span> || source &gt;= size || target &lt; <span class="number">0</span> || target &gt;= size)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(size, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distance(size, INT_MAX);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(size, <span class="number">-1</span>);</span><br><span class="line">  path = prev;</span><br><span class="line">  distance[source] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  priority_queue&lt;element, <span class="built_in">vector</span>&lt;element&gt;, compare&gt; pq;</span><br><span class="line">  pq.emplace(make_pair(source, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = pq.top().first;</span><br><span class="line">    pq.pop();</span><br><span class="line">    <span class="keyword">if</span> (v == target) <span class="keyword">return</span> distance[v];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph[v]) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = edge.first; <span class="comment">// vertice u that connects to v.</span></span><br><span class="line">      <span class="keyword">int</span> w = edge.second; <span class="comment">// weight of edge that connects u and v.</span></span><br><span class="line">      <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (distance[v] + w &lt; distance[u]) &#123;</span><br><span class="line">        distance[u] = distance[v] + w;</span><br><span class="line">        pq.emplace(make_pair(u, distance[u]));</span><br><span class="line">        path[u] = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; graph(<span class="number">7</span>, <span class="built_in">vector</span>&lt;edge&gt;());</span><br><span class="line">  graph[<span class="number">1</span>].push_back(make_pair(<span class="number">3</span>, <span class="number">9</span>));</span><br><span class="line">  graph[<span class="number">1</span>].push_back(make_pair(<span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line">  graph[<span class="number">1</span>].push_back(make_pair(<span class="number">6</span>, <span class="number">14</span>));</span><br><span class="line">  graph[<span class="number">2</span>].push_back(make_pair(<span class="number">1</span>, <span class="number">7</span>));</span><br><span class="line">  graph[<span class="number">2</span>].push_back(make_pair(<span class="number">3</span>, <span class="number">10</span>));</span><br><span class="line">  graph[<span class="number">2</span>].push_back(make_pair(<span class="number">4</span>, <span class="number">15</span>));</span><br><span class="line">  graph[<span class="number">3</span>].push_back(make_pair(<span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">  graph[<span class="number">3</span>].push_back(make_pair(<span class="number">6</span>, <span class="number">2</span>));</span><br><span class="line">  graph[<span class="number">3</span>].push_back(make_pair(<span class="number">4</span>, <span class="number">11</span>));</span><br><span class="line">  graph[<span class="number">4</span>].push_back(make_pair(<span class="number">2</span>, <span class="number">15</span>));</span><br><span class="line">  graph[<span class="number">4</span>].push_back(make_pair(<span class="number">3</span>, <span class="number">11</span>));</span><br><span class="line">  graph[<span class="number">4</span>].push_back(make_pair(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">  graph[<span class="number">5</span>].push_back(make_pair(<span class="number">6</span>, <span class="number">9</span>));</span><br><span class="line">  graph[<span class="number">5</span>].push_back(make_pair(<span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">  graph[<span class="number">6</span>].push_back(make_pair(<span class="number">1</span>, <span class="number">14</span>));</span><br><span class="line">  graph[<span class="number">6</span>].push_back(make_pair(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">  graph[<span class="number">6</span>].push_back(make_pair(<span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">  <span class="keyword">int</span> shortestPath = dijkstra(graph, <span class="number">1</span>, <span class="number">5</span>, pre);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Shortest path from 1 to 5 has length of "</span> &lt;&lt; shortestPath &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct shortest path.</span></span><br><span class="line">  <span class="keyword">int</span> u = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">  <span class="keyword">while</span> (pre[u] != <span class="number">-1</span>) &#123;</span><br><span class="line">    path.push(u);</span><br><span class="line">    u = pre[u];</span><br><span class="line">  &#125;</span><br><span class="line">  path.push(u);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!path.empty()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; path.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 181 DIV-1 1000 KiloManX]]></title>
      <url>http://lianghan.org/2016/07/31/2016-7-31-KiloManX/</url>
      <content type="html"><![CDATA[<p><a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=2288&amp;rd=4725" target="_blank" rel="noopener">Problem Statement</a></p>
<p>This is another very interesting problem that can be solved using graph search. The problem itself looks<br>like an optimization problem and should be solvable using ‘traditional’ dynamic programming technique (which<br>is true), but with some observations we can turn this into a graph search problem:</p>
<ul>
<li>The problem can be reduced to a search problem.</li>
<li>The search space is the set of states where each state is a combination of ‘boss defeated so far’ and ‘shots used’.</li>
<li>For each boss, the state of ‘defeated’ equals to the presence of its weapon.</li>
<li>The state transfer function looks like: given the set of boss defeated and the shots taken, what would be the set of bosses<br>that we could defeat next and the corresponding shots we would use to defeat those boss?</li>
<li>So we represent each state as a node in a graph and the state transfer function as edges between graph nodes.</li>
<li>The problem now is reduced to find shortest path between two nodes: the start node where no boss is defeated and the end<br>node where all bosses have been defeated.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> GNode &#123;</span><br><span class="line">    <span class="keyword">int</span> weapon;</span><br><span class="line">    <span class="keyword">int</span> shot;</span><br><span class="line">    GNode() : weapon(<span class="number">0</span>), shot(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Compare &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> GNode &amp;n1, <span class="keyword">const</span> GNode &amp;n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1.shot &gt; n2.shot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> KiloManX &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; damageChart, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bossHealth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="keyword">int</span>)damageChart.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> CAP = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(CAP, <span class="literal">false</span>);</span><br><span class="line">        GNode node;</span><br><span class="line">        priority_queue&lt;GNode, <span class="built_in">vector</span>&lt;GNode&gt;, Compare&gt; pq;</span><br><span class="line">        pq.push(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[node.weapon])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            visited[node.weapon] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.weapon == CAP - <span class="number">1</span>) &#123;</span><br><span class="line">                ret = min(ret, node.shot);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((node.weapon &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> best = bossHealth[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (((node.weapon &gt;&gt; j) &amp; <span class="number">1</span>) &amp;&amp; damageChart[j][i] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> damage = damageChart[j][i] - <span class="string">'0'</span>;</span><br><span class="line">                        <span class="keyword">int</span> shot = bossHealth[i] / damage;</span><br><span class="line">                        <span class="keyword">if</span> (bossHealth[i] % damage)</span><br><span class="line">                            ++shot;</span><br><span class="line">                        best = min(best, shot);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                GNode newNode;</span><br><span class="line">                newNode.shot = best + node.shot;</span><br><span class="line">                newNode.weapon = (node.weapon | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">                pq.push(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Graph </tag>
            
            <tag> BFS </tag>
            
            <tag> TopCoder </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 211 DIV-1 500 grafixMask]]></title>
      <url>http://lianghan.org/2016/07/23/2016-7-23-GrafixMask/</url>
      <content type="html"><![CDATA[<p><a href="https://community.topcoder.com/tc?module=ProblemDetail&amp;rd=5857&amp;pm=2998" target="_blank" rel="noopener">Problem Statement</a></p>
<p>This is a typical problem that is easily solvable using Flood Fill / BFS / DFS. The first challenge is to digest the problem quickly, and implement the code to parse input and extract interested information (in this case, the graph representation.). The second challenge is to to make sure only visit a node once.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parseString(<span class="built_in">string</span> input) &#123;</span><br><span class="line">  <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(input)</span></span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens&#123;istream_iterator&lt;<span class="built_in">string</span>&gt;&#123;iss&#125;,</span><br><span class="line">    istream_iterator&lt;<span class="built_in">string</span>&gt;&#123;&#125;&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;str : tokens) &#123;</span><br><span class="line">    ret.emplace_back(stoi(str));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> grafixMask &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sortedAreas(<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; rectangles) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> ROWS = <span class="number">400</span>, COLS = <span class="number">600</span>;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; bitmap(ROWS, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(COLS, <span class="literal">false</span>));</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;rec : rectangles) &#123;</span><br><span class="line">        <span class="keyword">auto</span> vec = parseString(rec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = vec[<span class="number">0</span>]; i &lt;= vec[<span class="number">2</span>]; ++i) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = vec[<span class="number">1</span>]; j &lt;= vec[<span class="number">3</span>]; ++j) &#123;</span><br><span class="line">            bitmap[i][j] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROWS; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; COLS; ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (bitmap[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; <span class="built_in">stack</span>;</span><br><span class="line">          <span class="built_in">stack</span>.push(make_pair(i, j));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">int</span> x = pos.first, y = pos.second;</span><br><span class="line">            <span class="keyword">if</span> (bitmap[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            bitmap[x][y] = <span class="literal">true</span>;</span><br><span class="line">            ++area;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> dirx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> diry[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">              <span class="keyword">int</span> xx = x + dirx[k], yy = y + diry[k];</span><br><span class="line">              <span class="keyword">if</span> (xx &gt;= <span class="number">0</span> &amp;&amp; xx &lt; <span class="number">400</span> &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; yy &lt; <span class="number">600</span> &amp;&amp; !bitmap[xx][yy]) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(make_pair(xx, yy));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ret.push_back(area);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sort(ret.begin(), ret.end());</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Graph </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> Flood Fill </tag>
            
            <tag> TopCoder </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SRM 156 DIV-1 1000 Path Finding]]></title>
      <url>http://lianghan.org/2016/07/20/2016-7-20-PathFinding/</url>
      <content type="html"><![CDATA[<p><a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=1110" target="_blank" rel="noopener">Problem Statement</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PathFinding &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minTurns</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> state &#123;</span><br><span class="line">      <span class="keyword">int</span> ax, ay, bx, by;</span><br><span class="line">      <span class="keyword">int</span> step;</span><br><span class="line">    &#125; state;</span><br><span class="line"></span><br><span class="line">    state s;</span><br><span class="line">    s.ax = s.ay = s.bx = s.by = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows = board.size(), cols = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'A'</span>) &#123;</span><br><span class="line">          s.ax = i; s.ay = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'B'</span>) &#123;</span><br><span class="line">          s.bx = i; s.by = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalid board in first place.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ax == <span class="number">-1</span> || s.bx == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    s.step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;state&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    visited[s.ax][s.ay][s.bx][s.by] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">      state node = q.front();</span><br><span class="line">      q.pop();</span><br><span class="line">      <span class="keyword">if</span> (node.ax == s.bx &amp;&amp; node.ay == s.by &amp;&amp; node.bx == s.ax &amp;&amp;</span><br><span class="line">          node.by == s.ay) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.step;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dx1 = <span class="number">-1</span>; dx1 &lt;= <span class="number">1</span>; ++dx1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy1 = <span class="number">-1</span>; dy1 &lt;= <span class="number">1</span>; ++dy1) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx2 = <span class="number">-1</span>; dx2 &lt;= <span class="number">1</span>; ++dx2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dy2 = <span class="number">-1</span>; dy2 &lt;= <span class="number">1</span>; ++dy2) &#123;</span><br><span class="line">              <span class="keyword">int</span> axx = node.ax + dx1;</span><br><span class="line">              <span class="keyword">int</span> ayy = node.ay + dy1;</span><br><span class="line">              <span class="keyword">int</span> bxx = node.bx + dx2;</span><br><span class="line">              <span class="keyword">int</span> byy = node.by + dy2;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// Out of board.</span></span><br><span class="line">              <span class="keyword">if</span> (axx &lt; <span class="number">0</span> || axx &gt;= rows || ayy &lt; <span class="number">0</span> || ayy &gt;= cols ||</span><br><span class="line">                  bxx &lt; <span class="number">0</span> || bxx &gt;= rows || byy &lt; <span class="number">0</span> || byy &gt;= cols) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (board[axx][ayy] == <span class="string">'X'</span> || board[bxx][byy] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// obstacle.</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// Crossed line (both moves)</span></span><br><span class="line">              <span class="keyword">if</span> (axx == node.bx &amp;&amp; ayy == node.by &amp;&amp; bxx == node.ax &amp;&amp; byy == node.ay) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// Cross line (a single side move)</span></span><br><span class="line">              <span class="keyword">if</span> (axx == bxx &amp;&amp; ayy == byy) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (visited[axx][ayy][bxx][byy]) <span class="keyword">continue</span>;</span><br><span class="line">              state ns;</span><br><span class="line">              ns.step = node.step + <span class="number">1</span>;</span><br><span class="line">              ns.ax = axx, ns.ay = ayy, ns.bx = bxx, ns.by = byy;</span><br><span class="line">              visited[axx][ayy][bxx][byy] = <span class="literal">true</span>;</span><br><span class="line">              q.push(ns);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TopCoder </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> BFS </tag>
            
            <tag> TopCoder </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
