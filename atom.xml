<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quantum Field</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lianghan.org/"/>
  <updated>2019-11-14T04:59:58.317Z</updated>
  <id>http://lianghan.org/</id>
  
  <author>
    <name>Michael Han</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 1031 Maximum Sum of Two Non-Overlapping Subarrays</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1031/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1031/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-14T04:59:58.317Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Maintain a sliding window of two sub arrays with length L and M and slide through. For each slide check two cases:<br>L first, or M first. Use prefix sum to speed up calculation of sum of a given sub array.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">max_sum_two_no_overlap</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, l: <span class="keyword">i32</span>, m: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> A = a.iter().scan(<span class="number">0</span>, |sum, i| &#123;*sum += *i; <span class="literal">Some</span>(*sum)&#125;).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        <span class="keyword">let</span> (L, M) = (l <span class="keyword">as</span> <span class="keyword">usize</span>, m <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> lmax, <span class="keyword">mut</span> rmax) = (A[L + M - <span class="number">1</span>], A[L - <span class="number">1</span>], A[M - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> L + M..A.len() <span class="keyword">as</span> <span class="keyword">usize</span> &#123;</span><br><span class="line">            lmax = cmp::max(lmax, A[i - M] - A[i - M - L]);</span><br><span class="line">            rmax = cmp::max(rmax, A[i - L] - A[i - L - M]);</span><br><span class="line">            ans = cmp::max(ans, cmp::max(A[i] - A[i - L] + rmax, A[i] - A[i - M] + lmax));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem 
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>1197. Minimum Knight Moves</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1197/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1197/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-15T17:53:27.135Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-knight-moves/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_knight_moves</span></span>(x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">8</span>], [<span class="keyword">i32</span>; <span class="number">8</span>]) = (</span><br><span class="line">            [-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">            [-<span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> grid = [[-<span class="number">1</span>; <span class="number">888</span>] ; <span class="number">888</span>];</span><br><span class="line">        <span class="keyword">let</span> (ax, ay) = (x.abs() <span class="keyword">as</span> <span class="keyword">usize</span>, y.abs() <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        grid[<span class="number">400</span>][<span class="number">400</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q : VecDeque&lt;(<span class="keyword">usize</span>, <span class="keyword">usize</span>)&gt; = VecDeque::new();</span><br><span class="line">        q.push_back((<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> (cx, cy) = q.pop_front().unwrap();</span><br><span class="line">            <span class="keyword">if</span> cx == ax &amp;&amp; cy == ay &#123;</span><br><span class="line">                <span class="keyword">return</span> grid[cx + <span class="number">400</span>][cy + <span class="number">400</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (xx, yy) = (cx <span class="keyword">as</span> <span class="keyword">i32</span> + dx[k] , cy <span class="keyword">as</span> <span class="keyword">i32</span> + dy[k]);</span><br><span class="line">                <span class="keyword">let</span> (nx, ny) = ((xx + <span class="number">400</span>) <span class="keyword">as</span> <span class="keyword">usize</span>, (yy + <span class="number">400</span>) <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                <span class="keyword">if</span> grid[nx][ny] != -<span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[nx][ny] = grid[cx + <span class="number">400</span>][cy + <span class="number">400</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> xx <span class="keyword">as</span> <span class="keyword">usize</span> == ax &amp;&amp; yy <span class="keyword">as</span> <span class="keyword">usize</span> == ay &#123;</span><br><span class="line">                    <span class="keyword">return</span> grid[nx][ny];</span><br><span class="line">                &#125;</span><br><span class="line">                q.push_back((xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-knight-moves/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1020. Number of Enclaves</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1020/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1020/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-14T20:45:08.623Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-enclaves/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Typical DFS. Similar to <a href="https://leetcode.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">1254. Number of Closed Islands</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(a : &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, x : <span class="keyword">usize</span>, y : <span class="keyword">usize</span>) -&gt; () &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n) = (a.len(), a[<span class="number">0</span>].len());</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (xx, yy) : (<span class="keyword">i32</span>, <span class="keyword">i32</span>) = (x <span class="keyword">as</span> <span class="keyword">i32</span> + dx[i], y <span class="keyword">as</span> <span class="keyword">i32</span> + dy[i]);</span><br><span class="line">            <span class="keyword">if</span> xx &gt;= m <span class="keyword">as</span> <span class="keyword">i32</span> || xx &lt; <span class="number">0</span> || yy &gt;= n <span class="keyword">as</span> <span class="keyword">i32</span> || yy &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">            <span class="keyword">if</span> a[nx][ny] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">            Self::dfs(a, nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">num_enclaves</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> A = a;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> ans) = (A.len(), A[<span class="number">0</span>].len(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> A[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">                        A[i][j] = <span class="number">0</span>;</span><br><span class="line">                        Self::dfs(&amp;<span class="keyword">mut</span> A, i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> A[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-enclaves/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Typic
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1254. Number of Closed Islands</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1254/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1254/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-14T19:22:05.892Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-closed-islands/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Typical BFS.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">closed_island</span></span>(grid: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> ans) = (grid.len(), grid[<span class="number">0</span>].len(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> g = grid;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> g[i][j] == <span class="number">1</span> || g[i][j] == -<span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">                q.push_back((i, j));</span><br><span class="line">                g[i][j] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">                    <span class="keyword">let</span> (x, y) = q.pop_front().unwrap();</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> (xx, yy) = (x <span class="keyword">as</span> <span class="keyword">i32</span> + dx[k], y <span class="keyword">as</span> <span class="keyword">i32</span> + dy[k]);</span><br><span class="line">                        <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt;= m <span class="keyword">as</span> <span class="keyword">i32</span> || yy &gt;= n <span class="keyword">as</span> <span class="keyword">i32</span> &#123;</span><br><span class="line">                            valid = <span class="literal">false</span>; <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                        <span class="keyword">if</span> g[nx][ny] == <span class="number">1</span> || g[nx][ny] == -<span class="number">1</span> &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        q.push_back((nx, ny));</span><br><span class="line">                        g[nx][ny] = -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> valid &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-closed-islands/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>688. Knight Probability in Chessboard</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode688/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode688/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-15T21:59:16.751Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/knight-probability-in-chessboard/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>DP, be careful about pow overflow.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">knight_probability</span></span>(n: <span class="keyword">i32</span>, k: <span class="keyword">i32</span>, r: <span class="keyword">i32</span>, c: <span class="keyword">i32</span>) -&gt; <span class="keyword">f64</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">f64</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">8</span>], [<span class="keyword">i32</span>; <span class="number">8</span>]) = (</span><br><span class="line">            [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">            [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">f64</span>; n <span class="keyword">as</span> <span class="keyword">usize</span>]; n <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">        <span class="keyword">for</span> _m <span class="keyword">in</span> <span class="number">0</span>..k &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> tmp = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span> <span class="keyword">as</span> <span class="keyword">f64</span>; n <span class="keyword">as</span> <span class="keyword">usize</span>]; n <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> (xx, yy) = (i + dx[k], j + dy[k]);</span><br><span class="line">                        <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt;= n || yy &gt;= n &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp[i <span class="keyword">as</span> <span class="keyword">usize</span>][j <span class="keyword">as</span> <span class="keyword">usize</span>] += dp[xx <span class="keyword">as</span> <span class="keyword">usize</span>][yy <span class="keyword">as</span> <span class="keyword">usize</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.swap_with_slice(&amp;<span class="keyword">mut</span> tmp[<span class="number">0</span>..]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[r <span class="keyword">as</span> <span class="keyword">usize</span>][c <span class="keyword">as</span> <span class="keyword">usize</span>] / <span class="number">8_f64</span>.powf(k <span class="keyword">as</span> <span class="keyword">f64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/knight-probability-in-chessboard/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 935. Knight Dialer</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode935/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode935/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-15T18:27:44.364Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/knight-dialer/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Dynamic Programming</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">knight_dialer</span></span>(n: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> MOD : <span class="keyword">u64</span> = <span class="number">1e9</span> <span class="keyword">as</span> <span class="keyword">u64</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">const</span> dirs: [(<span class="keyword">i32</span>, <span class="keyword">i32</span>); <span class="number">8</span>] = [(-<span class="number">2</span>, -<span class="number">1</span>), (-<span class="number">2</span>, <span class="number">1</span>), (-<span class="number">1</span>, -<span class="number">2</span>), (-<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            (<span class="number">1</span>, -<span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, -<span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = [[<span class="number">1</span>; <span class="number">3</span>] ; <span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span>..n &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> tmp = [[<span class="number">0</span>; <span class="number">3</span>] ; <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">3</span> &amp;&amp; j != <span class="number">1</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> (xx, yy) = (j + dirs[d].<span class="number">0</span>, i + dirs[d].<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt;= <span class="number">3</span> || yy &gt;= <span class="number">4</span> &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp[i <span class="keyword">as</span> <span class="keyword">usize</span>][j <span class="keyword">as</span> <span class="keyword">usize</span>] = (tmp[i <span class="keyword">as</span> <span class="keyword">usize</span>][j <span class="keyword">as</span> <span class="keyword">usize</span>] +</span><br><span class="line">                            dp[yy <span class="keyword">as</span> <span class="keyword">usize</span>][xx <span class="keyword">as</span> <span class="keyword">usize</span>]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.swap_with_slice(&amp;<span class="keyword">mut</span> tmp[<span class="number">0</span>..]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans : <span class="keyword">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">                ans = ((ans <span class="keyword">as</span> <span class="keyword">u64</span> + dp[i][j]) % MOD) <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/knight-dialer/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dynamic Pr
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 924 Minimize Malware Spread</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode924/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode924/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-14T01:02:40.189Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimize-malware-spread/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>For each initially infected node, try remove it and then count the total number of infected nodes through BFS.<br>Pick up the solution that if removing such a node will yield the minimum number of infected nodes.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::vec::<span class="built_in">Vec</span>;</span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_malware_spread</span></span>(graph: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, initial: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> min) = (-<span class="number">1</span>, <span class="number">400</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> input = initial;</span><br><span class="line">        input.sort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> &amp;input &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> bad = <span class="built_in">vec!</span>[<span class="number">0</span>; graph.len()];</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> &amp;input &#123;</span><br><span class="line">                <span class="keyword">if</span> *n == *t &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bad[*n <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">1</span>; q.push_back(*n <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> affected = input.len() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">                <span class="keyword">let</span> n = q.pop_front().unwrap();</span><br><span class="line">                <span class="keyword">for</span> (i, item) <span class="keyword">in</span> graph[n].iter().enumerate() &#123;</span><br><span class="line">                    <span class="keyword">if</span> bad[i <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">1</span> || *item == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    affected += <span class="number">1</span>; bad[i <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">1</span>; q.push_back(i <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> affected &lt; min &#123;</span><br><span class="line">                min = affected;</span><br><span class="line">                ans = *t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimize-malware-spread/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1145 Binary Tree Coloring Game</title>
    <link href="http://lianghan.org/2019/10/15/2019-10-15-LeetCode1145/"/>
    <id>http://lianghan.org/2019/10/15/2019-10-15-LeetCode1145/</id>
    <published>2019-10-15T17:39:31.000Z</published>
    <updated>2019-10-17T23:18:08.492Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-tree-coloring-game/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::cmp::max;</span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">btree_game_winning_move</span></span>(root: <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, n: <span class="keyword">i32</span>, x: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">count_sub_tree_nodes</span></span>(node: <span class="built_in">Option</span>&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;, x : <span class="keyword">i32</span>,</span><br><span class="line">                                left : &amp;<span class="keyword">mut</span> <span class="keyword">i32</span>, right : &amp;<span class="keyword">mut</span> <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(n) = node &#123;</span><br><span class="line">                <span class="keyword">let</span> l = count_sub_tree_nodes(n.borrow().left.as_ref(), x, left, right);</span><br><span class="line">                <span class="keyword">let</span> r = count_sub_tree_nodes(n.borrow().right.as_ref(), x, left, right);</span><br><span class="line">                <span class="keyword">if</span> x == n.borrow().val &#123;</span><br><span class="line">                    *left = l; *right = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> l + r + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> count = count_sub_tree_nodes(root.as_ref(), x, &amp;<span class="keyword">mut</span> left, &amp;<span class="keyword">mut</span> right);</span><br><span class="line">        <span class="keyword">return</span> max(max(left, right), n - left - right - <span class="number">1</span>) &gt; n / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-coloring-game/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1123 Lowest Common Ancestor of Deepest Leaves</title>
    <link href="http://lianghan.org/2019/09/23/2019-09-23-LeetCode1123/"/>
    <id>http://lianghan.org/2019/09/23/2019-09-23-LeetCode1123/</id>
    <published>2019-09-23T17:39:31.000Z</published>
    <updated>2019-09-24T01:06:29.468Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::cmp::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">compute_depth</span></span>(node : <span class="built_in">Option</span>&lt;&amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; <span class="keyword">u32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(n) = node &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(Solution::compute_depth(n.borrow().left.as_ref()),</span><br><span class="line">                           Solution::compute_depth(n.borrow().right.as_ref()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">lca_deepest_leaves</span></span>(root: <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; <span class="built_in">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(node) = root.clone() &#123;</span><br><span class="line">            <span class="keyword">let</span> (l, r) = (Solution::compute_depth(node.borrow().left.as_ref()),</span><br><span class="line">                          Solution::compute_depth(node.borrow().right.as_ref()));</span><br><span class="line">            <span class="keyword">if</span> l == r &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Some</span>(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">                <span class="keyword">return</span> Solution::lca_deepest_leaves(node.borrow().right.clone());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Solution::lca_deepest_leaves(node.borrow().left.clone());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Stat
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 641 Design Circular Deque</title>
    <link href="http://lianghan.org/2019/09/19/2019-09-19-LeetCode641/"/>
    <id>http://lianghan.org/2019/09/19/2019-09-19-LeetCode641/</id>
    <published>2019-09-19T17:39:31.000Z</published>
    <updated>2019-09-20T04:37:22.338Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/design-circular-deque/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec::<span class="built_in">Vec</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCircularDeque</span></span> &#123;</span><br><span class="line">    v: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;,</span><br><span class="line">    head : <span class="keyword">usize</span>,</span><br><span class="line">    tail : <span class="keyword">usize</span>,</span><br><span class="line">    count : <span class="keyword">usize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> MyCircularDeque &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(k: <span class="keyword">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::with_capacity(k.clone() <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        vec.resize(k.clone() <span class="keyword">as</span> <span class="keyword">usize</span>, <span class="number">0</span>);</span><br><span class="line">        MyCircularDeque &#123;</span><br><span class="line">            v : vec,</span><br><span class="line">            head : k <span class="keyword">as</span> <span class="keyword">usize</span> - <span class="number">1</span>, tail : <span class="number">0</span>, count : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert_front</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_full() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.head.clone()] = value;</span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="keyword">self</span>.v.len() - <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert_last</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_full() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.tail.clone()] = value;</span><br><span class="line">        <span class="keyword">self</span>.tail = (<span class="keyword">self</span>.tail + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete_front</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete_last</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.tail = (<span class="keyword">self</span>.tail + <span class="keyword">self</span>.v.len() - <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_front</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[(<span class="keyword">self</span>.head.clone() + <span class="number">1</span>) % <span class="keyword">self</span>.v.len()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_rear</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[(<span class="keyword">self</span>.tail - <span class="number">1</span> + <span class="keyword">self</span>.v.len()) % <span class="keyword">self</span>.v.len()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_empty</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_full</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="keyword">self</span>.v.len();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/design-circular-deque/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 622 Design Circular Queue</title>
    <link href="http://lianghan.org/2019/09/15/2019-09-15-LeetCode622/"/>
    <id>http://lianghan.org/2019/09/15/2019-09-15-LeetCode622/</id>
    <published>2019-09-15T17:39:31.000Z</published>
    <updated>2019-09-16T05:14:34.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/design-circular-queue/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec::<span class="built_in">Vec</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCircularQueue</span></span> &#123;</span><br><span class="line">    v : <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;,</span><br><span class="line">    head : <span class="keyword">usize</span>,</span><br><span class="line">    tail : <span class="keyword">usize</span>,</span><br><span class="line">    count : <span class="keyword">usize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> MyCircularQueue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(k: <span class="keyword">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::with_capacity(k.clone() <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        vec.resize(k <span class="keyword">as</span> <span class="keyword">usize</span>, <span class="number">0</span>);</span><br><span class="line">        MyCircularQueue &#123;</span><br><span class="line">            v : vec,</span><br><span class="line">            head : <span class="number">0</span>, tail : <span class="number">0</span>, count : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">en_queue</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_full() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.tail.clone()] = value;</span><br><span class="line">        <span class="keyword">self</span>.tail = (<span class="keyword">self</span>.tail + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">de_queue</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.v[<span class="keyword">self</span>.head.clone()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.head = (<span class="keyword">self</span>.head + <span class="number">1</span>) % <span class="keyword">self</span>.v.len();</span><br><span class="line">        <span class="keyword">self</span>.count -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">front</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[<span class="keyword">self</span>.head.clone()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">rear</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.v[(<span class="keyword">self</span>.tail - <span class="number">1</span> + <span class="keyword">self</span>.v.len()) % <span class="keyword">self</span>.v.len()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_empty</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_full</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.count == <span class="keyword">self</span>.v.len();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/design-circular-queue/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 301 Remove Invalid Parentheses</title>
    <link href="http://lianghan.org/2019/09/11/2019-09-11-LeetCode301/"/>
    <id>http://lianghan.org/2019/09/11/2019-09-11-LeetCode301/</id>
    <published>2019-09-11T17:39:31.000Z</published>
    <updated>2019-09-11T22:49:52.925Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-invalid-parentheses/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>First attempt on implementing solutions for leetcode problems using Rust. For someone like me with a C++ background,<br>coding in Rust requires a paradigm change. Move semantics are everywhere, everything has to be explicit, and there are<br>really not so many similarities of standard libraries between Rust and C++. In any cases, it’s fun to code in Rust,<br>and I am sure this code can be more Rustified.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_invalid_parentheses</span></span>(s: <span class="built_in">String</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> result = <span class="built_in">Vec</span>::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> visited = HashSet::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> queue = VecDeque::new();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">isParenBalanced</span></span>(s : &amp;<span class="built_in">String</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (<span class="keyword">mut</span> left, <span class="keyword">mut</span> right) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">'('</span> &#123;</span><br><span class="line">                    left = left + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> c == <span class="string">')'</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> left == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left = left - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.insert(s.clone());</span><br><span class="line">        queue.push_back(s.clone());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> stop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> !queue.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">str</span> = queue.pop_front().unwrap();</span><br><span class="line">            <span class="keyword">if</span> isParenBalanced(&amp;<span class="keyword">str</span>) &#123;</span><br><span class="line">                result.push(<span class="keyword">str</span>.clone());</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> stop &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> it <span class="keyword">in</span> <span class="keyword">str</span>.char_indices() &#123;</span><br><span class="line">                <span class="keyword">if</span> it.<span class="number">1</span> != <span class="string">'('</span> &amp;&amp; it.<span class="number">1</span> != <span class="string">')'</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> next = <span class="keyword">str</span>.clone();</span><br><span class="line">                next.remove(it.<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> visited.contains(&amp;next) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.push_back(next.clone());</span><br><span class="line">                visited.insert(next.clone());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-invalid-parentheses/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>SRM 748 DIV II 500</title>
    <link href="http://lianghan.org/2019/01/27/2019-01-26-SRM748/"/>
    <id>http://lianghan.org/2019/01/27/2019-01-26-SRM748/</id>
    <published>2019-01-27T18:25:31.000Z</published>
    <updated>2019-01-27T18:28:47.809Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Yllion &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; getString(<span class="built_in">string</span> input) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(input)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">while</span>(s &gt;&gt; str) ans.push_back(str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPower</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; s2i;</span><br><span class="line">        s2i[<span class="string">"one"</span>] = <span class="number">0</span>; s2i[<span class="string">"ten"</span>] = <span class="number">1</span>;</span><br><span class="line">        s2i[<span class="string">"hundred"</span>] = <span class="number">2</span>;</span><br><span class="line">        s2i[<span class="string">"myriad"</span>] = <span class="number">4</span>; s2i[<span class="string">"myllion"</span>] = <span class="number">8</span>;</span><br><span class="line">        s2i[<span class="string">"byllion"</span>] = <span class="number">16</span>; s2i[<span class="string">"tryllion"</span>] = <span class="number">32</span>;</span><br><span class="line">        s2i[<span class="string">"quadryllion"</span>] = <span class="number">64</span>; s2i[<span class="string">"quintyllion"</span>] = <span class="number">128</span>;</span><br><span class="line">        s2i[<span class="string">"sextyllion"</span>] = <span class="number">256</span>; s2i[<span class="string">"septyllion"</span>] = <span class="number">512</span>;</span><br><span class="line">        s2i[<span class="string">"octyllion"</span>] = <span class="number">1024</span>; s2i[<span class="string">"nonyllion"</span>] = <span class="number">2048</span>;</span><br><span class="line">        s2i[<span class="string">"decyllion"</span>] = <span class="number">4096</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; i2s;</span><br><span class="line">        i2s[<span class="number">0</span>] = <span class="string">"one"</span>; i2s[<span class="number">1</span>] = <span class="string">"ten"</span>;</span><br><span class="line">        i2s[<span class="number">2</span>] = <span class="string">"hundred"</span>;</span><br><span class="line">        i2s[<span class="number">4</span>] = <span class="string">"myriad"</span>; i2s[<span class="number">8</span>] = <span class="string">"myllion"</span>;</span><br><span class="line">        i2s[<span class="number">16</span>] = <span class="string">"byllion"</span>; i2s[<span class="number">32</span>] = <span class="string">"tryllion"</span>;</span><br><span class="line">        i2s[<span class="number">64</span>] = <span class="string">"quadryllion"</span>; i2s[<span class="number">128</span>] = <span class="string">"quintyllion"</span>;</span><br><span class="line">        i2s[<span class="number">256</span>] = <span class="string">"sextyllion"</span>; i2s[<span class="number">512</span>] = <span class="string">"septyllion"</span>;</span><br><span class="line">        i2s[<span class="number">1024</span>] = <span class="string">"octyllion"</span>; i2s[<span class="number">2048</span>] = <span class="string">"nonyllion"</span>;</span><br><span class="line">        i2s[<span class="number">4096</span>] = <span class="string">"decyllion"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> va = getString(a), vb = getString(b);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : va) &#123;</span><br><span class="line">            c += s2i[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : vb) &#123;</span><br><span class="line">            c += s2i[s];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">12</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> base = <span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; base) <span class="keyword">continue</span>;</span><br><span class="line">            ans.push_back(i2s[base]);</span><br><span class="line">            <span class="keyword">if</span> (base == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            c = c % base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!c) ans.push_back(<span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i) &#123;</span><br><span class="line">            ret += ans[i];</span><br><span class="line">            <span class="keyword">if</span> (i != ans.size() - <span class="number">1</span>) ret += <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;
      
    
    </summary>
    
      <category term="TopCoder" scheme="http://lianghan.org/categories/TopCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>SRM 740 DIV II 500</title>
    <link href="http://lianghan.org/2018/10/20/2018-10-20-SRM740/"/>
    <id>http://lianghan.org/2018/10/20/2018-10-20-SRM740/</id>
    <published>2018-10-20T23:23:31.000Z</published>
    <updated>2018-10-20T23:41:05.314Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> LongJumpCompetition &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; recoverStandings(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; jumpLengths) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> N = jumpLengths.size() / <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; cur(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cur[i] = &#123; &#123;&#125; , i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> length = jumpLengths[i * N + j];</span><br><span class="line">                cur[N - <span class="number">1</span> - j].first.push_back(<span class="number">-1</span> * length);</span><br><span class="line">                sort(cur[N - <span class="number">1</span> - j].first.begin(),</span><br><span class="line">                     cur[N - <span class="number">1</span> - j].first.end());</span><br><span class="line">            &#125;</span><br><span class="line">            sort(cur.begin(), cur.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            ans.push_back(cur[i].second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;
      
    
    </summary>
    
      <category term="TopCoder" scheme="http://lianghan.org/categories/TopCoder/"/>
    
    
  </entry>
  
  <entry>
    <title>Paxos Retrospective</title>
    <link href="http://lianghan.org/2017/09/13/2017-09-13-Paxos/"/>
    <id>http://lianghan.org/2017/09/13/2017-09-13-Paxos/</id>
    <published>2017-09-14T05:03:31.000Z</published>
    <updated>2019-09-23T16:26:32.978Z</updated>
    
    <content type="html"><![CDATA[<p>Recently I looked through Lamport’s Paxos papers again and in retrospective, I feel Paxos as an algorithm is very elegant and easy to understand. In this post I’ll try to summary the core concepts and key steps of the single decree Paxos protocol. In future posts, I’ll write more about multi-paxos, and compare multi-paxos with similar protocols such as ZAB and Raft.</p><h1 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h1><p>This post will use the usual terminologies for the protocol entities from the Paxos Made Simple paper, such as Proposer, Acceptor, Learner, Leader, etc.</p><h1 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h1><p>Paxos is used to solve consensus problem. A consensus is about reaching agreement on a single value, among a set of values. Each value in the set is proposed by a proposer.</p><h1 id="Assumptions-Use-Case-Constraints"><a href="#Assumptions-Use-Case-Constraints" class="headerlink" title="Assumptions / Use Case Constraints"></a>Assumptions / Use Case Constraints</h1><p>Paxos can solve consensus problem under a set of constraints, and these constraints happen to reflect real world use case constraints for distributed systems, thus it’s very practical and applicable. In particular:</p><ul><li>Fail-Recovery: each participant can fail. Failed participants can recover.</li><li>Asynchronous: participants communicate with each other through async messages.</li><li>None Byzantine Faults: These messages can be delayed, or lost, but will never be forged.</li></ul><p>It’s also worth noting that to reach consensus, a set of additional protocol level constraints have to be exposed on participants. One example is each participant can’t just insist on the value from its own, because if everyone does that, it’s possible no consensus could ever be made. In other words, participants are more interested on reach consensus on something, but they are not interested on what exactly the value of that agreement is.</p><h1 id="Safety-and-Liveness"><a href="#Safety-and-Liveness" class="headerlink" title="Safety and Liveness"></a>Safety and Liveness</h1><p>Because of FLP impossibility, it’s not possible to reach consensus with the constraints Paxos protocol is exposed to, yet maintain both safety and liveness properties. Paxos chooses safety over liveness.</p><p>The safety properties Paxos guarantees:</p><ul><li>Only a value that has been proposed may be chosen,</li><li>Only a single value is chosen, and</li><li>A process never learns that a value has been chosen unless it actually has been.</li></ul><p>Paxos does not guarantee liveness, in other words it does not guarantee making progress, or terminate.<br>For making progress, it’s possible to have live lock (which can be fixed easily through backoffs and randomization).<br>For termination, it could never terminate if not enough number of participants (the quorum) are live.</p><h1 id="Protocol-Constraints"><a href="#Protocol-Constraints" class="headerlink" title="Protocol Constraints"></a>Protocol Constraints</h1><p>I feel it’s easier to understand the protocol by understanding the protocol constraints exposed to participants. There are two key constraints, one on the proposer, one on the acceptor.</p><p>Proposer: a proposer must be willing to change the value it proposes, by using the value it acquires from the prepare phase. A proposer can propose any value though, if in prepare phase the queries on a quorum of acceptors returns null value (meaning those acceptors haven’t accepted anything.).</p><p>Acceptor: an acceptor must be willing to reject the proposals it receives, unless the proposal it receives has a proposal number that’s equal or greater than the maximum of all proposal numbers that the acceptor ever see during the prepare phase. In other words, acceptor has to make a promise upon receiving a proposal with a bigger proposal number than it ever sees, and the promise is to not accept any future proposals with smaller proposal number.</p><h1 id="Phases"><a href="#Phases" class="headerlink" title="Phases"></a>Phases</h1><p>Paxos is a two phased protocol. There are prepare phase, and accept phase. Prepare phase is used for proposer to get an updated view of the quorum and decide what to propose (e.g. update the proposal value from the response of the acceptor in prepare request if the proposal was rejected due to a smaller proposer number). Accept phase is to finish the protocol by having acceptors record the consensus and responds to proposer.</p><p>To Be Continued…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Recently I looked through Lamport’s Paxos papers again and in retrospective, I feel Paxos as an algorithm is very elegant and easy to und
      
    
    </summary>
    
      <category term="Distributed System" scheme="http://lianghan.org/categories/Distributed-System/"/>
    
    
      <category term="Consensus Protocol" scheme="http://lianghan.org/tags/Consensus-Protocol/"/>
    
      <category term="Paxos" scheme="http://lianghan.org/tags/Paxos/"/>
    
  </entry>
  
  <entry>
    <title>USACO 5.4 Character Recognition</title>
    <link href="http://lianghan.org/2017/09/04/2017-09-03-USACO-CharacterRecognition/"/>
    <id>http://lianghan.org/2017/09/04/2017-09-03-USACO-CharacterRecognition/</id>
    <published>2017-09-05T00:26:31.000Z</published>
    <updated>2019-09-23T16:26:32.977Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ch[] = <span class="string">"* abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM_FONTS = <span class="number">28</span>, N = <span class="number">20</span>, MAX_LINES = <span class="number">1201</span>, INF = <span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">char</span> font[MAX_NUM_FONTS][N + <span class="number">1</span>][N + <span class="number">1</span>], line[MAX_LINES][N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// diff[i][j][k]: difference between the i-th line of the input image and</span></span><br><span class="line"><span class="comment">// the k-th line of the j-th font soure image.</span></span><br><span class="line"><span class="keyword">int</span> diff[MAX_LINES][MAX_NUM_FONTS][N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// cost[i][j]: minimum cost of match between the i-th line and the (j + 19)-th</span></span><br><span class="line"><span class="comment">// line of the input image.</span></span><br><span class="line"><span class="keyword">int</span> cost[MAX_LINES][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// index of the matching char.</span></span><br><span class="line"><span class="keyword">int</span> from[MAX_LINES][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_LINES], opt[MAX_LINES], ans[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fontin</span><span class="params">(<span class="string">"font.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"charrec.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"charrec.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFont</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    fontin &gt;&gt; tmp;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">27</span>;  ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            fontin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                font[i][j][k] = str[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readImages</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            line[i][j] = str[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= N; ++t) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(line[i][t] == font[j][k][t]) <span class="keyword">continue</span>;</span><br><span class="line">                    ++diff[i][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preprocess</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">18</span> &lt;= n; ++i) &#123;</span><br><span class="line">        cost[i][<span class="number">0</span>] = cost[i][<span class="number">1</span>] = cost[i][<span class="number">2</span>] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; N; ++k) &#123;</span><br><span class="line">                t += diff[i + k - <span class="number">1</span>][j][k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &lt; cost[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                cost[i][<span class="number">0</span>] = t;</span><br><span class="line">                from[i][<span class="number">0</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">19</span>; k; --k) &#123;</span><br><span class="line">                t -= diff[i + k - <span class="number">1</span>][j][k], t += diff[i + k - <span class="number">1</span>][j][k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(t &lt; cost[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    cost[i][<span class="number">0</span>] = t;</span><br><span class="line">                    from[i][<span class="number">0</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">19</span> &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                    t += diff[i+k<span class="number">-1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; cost[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    cost[i][<span class="number">1</span>] = t;</span><br><span class="line">                    from[i][<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">20</span> &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">27</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k &lt;= N; ++k) &#123;</span><br><span class="line">                    t += diff[i + k - <span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; cost[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                    cost[i][<span class="number">2</span>] = t,</span><br><span class="line">                    from[i][<span class="number">2</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = N; k; --k) &#123;</span><br><span class="line">                    t -= diff[i + k - <span class="number">1</span>][j][k];</span><br><span class="line">                    t += diff[i + k][j][k];</span><br><span class="line">                    <span class="keyword">if</span> (t &lt; cost[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                        cost[i][<span class="number">2</span>] = t;</span><br><span class="line">                        from[i][<span class="number">2</span>] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = dp[i - <span class="number">19</span>] + cost[i - <span class="number">18</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; val) &#123;</span><br><span class="line">            dp[i] = val;</span><br><span class="line">            opt[i] = <span class="number">19</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            val = dp[i - <span class="number">20</span>] + cost[i - <span class="number">19</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; val) &#123;</span><br><span class="line">                dp[i] = val;</span><br><span class="line">                opt[i] = <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            val = dp[i - <span class="number">21</span>] + cost[i - <span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; val) &#123;</span><br><span class="line">                dp[i] = val;</span><br><span class="line">                opt[i] = <span class="number">21</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readFont();</span><br><span class="line">    fin &gt;&gt; n;</span><br><span class="line">    readImages(n);</span><br><span class="line">    preprocess(n);</span><br><span class="line">    calculate(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i -= opt[i]) &#123;</span><br><span class="line">        ans[++t] = from[i - opt[i] + <span class="number">1</span>][opt[i] - <span class="number">19</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i; --i) &#123;</span><br><span class="line">        fout &lt;&lt; ch[ans[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span cl
      
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>USACO 5.4 Canada Tour</title>
    <link href="http://lianghan.org/2017/08/14/2017-08-14-USACO-CanadaTour/"/>
    <id>http://lianghan.org/2017/08/14/2017-08-14-USACO-CanadaTour/</id>
    <published>2017-08-14T18:15:31.000Z</published>
    <updated>2019-09-23T16:26:32.976Z</updated>
    
    <content type="html"><![CDATA[<p>For every pair of cities (i,j) find maximum total length of two paths. One path starts at city 1 and ends in city i, the other path starts from city 1 and ends in city j. Both path have no common cities except the start city 1 and the end city N. First path will reach city N, and the result will be the maximum value of the other path ending at j where 1 &lt;= j &lt;= N.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, V;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; flight;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; cities;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"tour.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"tour.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    fin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>));</span><br><span class="line">    flight = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> city;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; city;</span><br><span class="line">        cities[city] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> from, to;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; from &gt;&gt; to;</span><br><span class="line">        flight[cities[from]][cities[to]] = <span class="literal">true</span>;</span><br><span class="line">        flight[cities[to]][cities[from]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][k] &amp;&amp; flight[k][j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">std</span>::max(dp[i][k] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j][i] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flight[i][N]) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">std</span>::max(ans, dp[i][N]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;For every pair of cities (i,j) find maximum total length of two paths. One path starts at city 1 and ends in city i, the other path start
      
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>USACO 5.3 Big Barn</title>
    <link href="http://lianghan.org/2017/08/09/2017-08-09-USACO-BigBarn/"/>
    <id>http://lianghan.org/2017/08/09/2017-08-09-USACO-BigBarn/</id>
    <published>2017-08-10T04:20:31.000Z</published>
    <updated>2019-09-23T16:26:32.976Z</updated>
    
    <content type="html"><![CDATA[<p>Similar dynamic programming problem as the previous <a href="http://lianghan.org/2016/12/07/2016-12-07-USACO-HomeOnRange/">Home On The Range</a>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, T;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"bigbrn.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"bigbrn.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    fin &gt;&gt; N &gt;&gt; T;</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        dp[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]),</span><br><span class="line">                                dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(dp[i][j], ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Similar dynamic programming problem as the previous &lt;a href=&quot;http://lianghan.org/2016/12/07/2016-12-07-USACO-HomeOnRange/&quot;&gt;Home On The Ra
      
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>USACO 5.3 Network of Schools</title>
    <link href="http://lianghan.org/2017/08/04/2017-08-04-USACO-NetworkOfSchools/"/>
    <id>http://lianghan.org/2017/08/04/2017-08-04-USACO-NetworkOfSchools/</id>
    <published>2017-08-05T06:11:31.000Z</published>
    <updated>2019-09-23T16:26:32.975Z</updated>
    
    <content type="html"><![CDATA[<p>Compute the minimum number of edges to add to make a directed graph strongly connected. Use Kosaraju’s algorithm to find out strongly connected components and for each SCC count its in degree and out degree and the maximum one is the answer.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g, rg <span class="comment">/* reversed graph */</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vs; <span class="comment">// post order vertices</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cmp; <span class="comment">// topological order of strongly connected component.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    g[from].push_back(to);</span><br><span class="line">    rg[to].push_back(from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[g[v][i]]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(g[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vs.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    cmp[v] = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rg[v].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[rg[v][i]]) <span class="keyword">continue</span>;</span><br><span class="line">        rdfs(rg[v][i], k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">    vs.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)vs.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[vs[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        rdfs(vs[i], k++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"schlnet.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"schlnet.out"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N); rg = g;</span><br><span class="line">    vs = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N, <span class="literal">false</span>);</span><br><span class="line">    cmp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> ins = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> outs = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t; fin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (t) &#123;</span><br><span class="line">            add_edge(i, t - <span class="number">1</span>);</span><br><span class="line">            fin &gt;&gt; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numOfScc = scc();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cout &lt;&lt; numOfScc &lt;&lt; endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(numOfScc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[i][j];</span><br><span class="line">            <span class="keyword">int</span> ii = cmp[i], vv = cmp[v];</span><br><span class="line">            <span class="keyword">if</span>(ii != vv) &#123;</span><br><span class="line">                ins[vv]++; outs[ii]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans0 = <span class="number">0</span>, ans1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfScc; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ins[i])  ++ans0; <span class="keyword">if</span>(!outs[i]) ++ans1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; max(ans0, ans1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; ans0 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; max(ans0, ans1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Compute the minimum number of edges to add to make a directed graph strongly connected. Use Kosaraju’s algorithm to find out strongly con
      
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Graph Theory" scheme="http://lianghan.org/tags/Graph-Theory/"/>
    
      <category term="Strongly Connected Components" scheme="http://lianghan.org/tags/Strongly-Connected-Components/"/>
    
  </entry>
  
  <entry>
    <title>USACO 5.3 Window Area</title>
    <link href="http://lianghan.org/2017/07/22/2017-07-22-USACO-WindowArea/"/>
    <id>http://lianghan.org/2017/07/22/2017-07-22-USACO-WindowArea/</id>
    <published>2017-07-22T16:41:31.000Z</published>
    <updated>2019-09-23T16:26:32.974Z</updated>
    
    <content type="html"><![CDATA[<p>Maintain an array of windows and an array of levels maps to each window. Bring a window top / down is easy, just change the levels. Destroy a window is also easy. To draw the visible surface of window, consider the drawing process a series of culling with the windows with a higher level than it. At each step, there are several cases: not culling, partial culling, or completely culling. After each step we either get the end result or in case of partial culling, we repeat same step again until we hit the top level window. DFS is a natural fit here.</p><p>One note is the input data has to be normalized first (the corners of the window could be top-left/bottom-right or bottom-left/top-right).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">70</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> window &#123;</span><br><span class="line">    <span class="keyword">int</span> u, d, l, r;</span><br><span class="line">&#125; tWindow;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tWindow&gt; windows(M);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; order(N);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u <span class="comment">/*up*/</span>, <span class="keyword">int</span> l <span class="comment">/*left*/</span>, <span class="keyword">int</span> d <span class="comment">/*down*/</span>, <span class="keyword">int</span> r <span class="comment">/*right*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level &gt; total) &#123;</span><br><span class="line">        ans += (u - d) * (r - l);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = order[level];</span><br><span class="line">    tWindow w = windows[i];</span><br><span class="line">    <span class="keyword">if</span>(u &lt;= w.d || d &gt;= w.u || l &gt;= w.r || r &lt;= w.l ) &#123;</span><br><span class="line">        dfs(u, l, d , r, level + <span class="number">1</span>); <span class="comment">/* no intersection */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(u &lt;= w.u &amp;&amp; d &gt;= w.d &amp;&amp; l &gt;= w.l &amp;&amp; r &lt;= w.r ) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* absorbed */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; w.u &amp;&amp; w.u &lt; u) &#123;</span><br><span class="line">            dfs(u, l, w.u, r, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; w.d &amp;&amp; w.d &lt; u) &#123;</span><br><span class="line">            dfs(w.d, l, d, r, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// avoid duplicate compute</span></span><br><span class="line">        u = <span class="built_in">std</span>::min(u, w.u);</span><br><span class="line">        d = <span class="built_in">std</span>::max(d, w.d);</span><br><span class="line">        <span class="keyword">if</span>(w.l &gt; l &amp;&amp; w.l &lt; r) &#123;</span><br><span class="line">           dfs(u, l, d, w.l, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w.r &gt; l &amp;&amp; w.r &lt; r) &#123;</span><br><span class="line">           dfs(u, w.r, d, r, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"window.in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"window.out"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> op, id, s;</span><br><span class="line">    <span class="keyword">int</span> i, u, d, l, r;</span><br><span class="line">    <span class="keyword">while</span>(fin &gt;&gt; op) &#123;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">'w'</span>) &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s &gt;&gt; l &gt;&gt; s &gt;&gt; u &gt;&gt; s &gt;&gt; r &gt;&gt; s &gt;&gt; d &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(d &gt; u) swap(d,u);</span><br><span class="line">            <span class="keyword">if</span>(l &gt; r) swap(l,r);</span><br><span class="line">            windows[id].u = u; windows[id].d=d;</span><br><span class="line">            windows[id].l=l; windows[id].r=r;</span><br><span class="line">            total++;</span><br><span class="line">            order[total] = id;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'t'</span>|| op == <span class="string">'d'</span>) &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; total; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(order[i] == id) swap(order[i],order[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">'d'</span>) total--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'b'</span>) &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(i = total; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(order[i] == id) swap(order[i],order[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fin &gt;&gt; s &gt;&gt; id &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= total; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(order[i] == id) &#123;</span><br><span class="line">                    ans = <span class="number">0</span>;</span><br><span class="line">                    tWindow w = windows[id];</span><br><span class="line">                    u = (w.u - w.d) * (w.r - w.l);</span><br><span class="line">                    dfs(w.u, w.l, w.d, w.r, i + <span class="number">1</span>);</span><br><span class="line">                    fout &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">3</span>)</span><br><span class="line">                         &lt;&lt; <span class="number">100.0</span> * ans / u &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Maintain an array of windows and an array of levels maps to each window. Bring a window top / down is easy, just change the levels. Destr
      
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="DFS" scheme="http://lianghan.org/tags/DFS/"/>
    
      <category term="Simulation" scheme="http://lianghan.org/tags/Simulation/"/>
    
  </entry>
  
</feed>
