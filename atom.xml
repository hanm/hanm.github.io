<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quantum Field</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lianghan.org/"/>
  <updated>2017-01-13T23:24:44.000Z</updated>
  <id>http://lianghan.org/</id>
  
  <author>
    <name>hanm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>USACO 4.3 Buy Low</title>
    <link href="http://lianghan.org/2017/01/13/2017-01-13-USACO-BuyLow/"/>
    <id>http://lianghan.org/2017/01/13/2017-01-13-USACO-BuyLow/</id>
    <published>2017-01-13T23:19:31.000Z</published>
    <updated>2017-01-13T23:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Essentially a longest decreasing sequence problem that is easy to solve using typical DP approach. Counting the number of such sequences is also not hard, the real problem is that the counts could be too big to fit in 32 or 64 bit integers, so need to use big integers struct.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1000000000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> base_digits = <span class="number">9</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> BigInteger &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</div><div class="line">    <span class="keyword">int</span> sign;</div><div class="line"></div><div class="line">    BigInteger() : sign(<span class="number">1</span>) &#123;&#125;</div><div class="line">    BigInteger(<span class="keyword">long</span> <span class="keyword">long</span> v) &#123;</div><div class="line">        *<span class="keyword">this</span> = v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> BigInteger &amp;v) &#123;</div><div class="line">        sign = v.sign;</div><div class="line">        a = v.a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">long</span> <span class="keyword">long</span> v) &#123;</div><div class="line">        sign = <span class="number">1</span>;</div><div class="line">        a.clear();</div><div class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</div><div class="line">            sign = <span class="number">-1</span>, v = -v;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (; v &gt; <span class="number">0</span>; v = v / base) &#123;</div><div class="line">            a.push_back(v % base);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (sign != v.sign) <span class="keyword">return</span> *<span class="keyword">this</span> - (-v);</div><div class="line">        BigInteger res = v;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>;</div><div class="line">             i &lt; (<span class="keyword">int</span>) max(a.size(), v.a.size()) || carry; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (i == (<span class="keyword">int</span>) res.a.size())</div><div class="line">                res.a.push_back(<span class="number">0</span>);</div><div class="line">            res.a[i] += carry + (i &lt; (<span class="keyword">int</span>) a.size() ? a[i] : <span class="number">0</span>);</div><div class="line">            carry = res.a[i] &gt;= base;</div><div class="line">            <span class="keyword">if</span> (carry) res.a[i] -= base;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (sign != v.sign) <span class="keyword">return</span> *<span class="keyword">this</span> + (-v);</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>() &lt; v.<span class="built_in">abs</span>()) <span class="keyword">return</span> -(v - *<span class="keyword">this</span>);</div><div class="line">        BigInteger res = *<span class="keyword">this</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) v.a.size() || carry; ++i) &#123;</div><div class="line">            res.a[i] -= carry + (i &lt; (<span class="keyword">int</span>) v.a.size() ? v.a[i] : <span class="number">0</span>);</div><div class="line">            carry = res.a[i] &lt; <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (carry)</div><div class="line">                res.a[i] += base;</div><div class="line">        &#125;</div><div class="line">        res.trim();</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger &amp;v) &#123;</div><div class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> + v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger &amp;v) &#123;</div><div class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> - v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (sign != v.sign)</div><div class="line">            <span class="keyword">return</span> sign &lt; v.sign;</div><div class="line">        <span class="keyword">if</span> (a.size() != v.a.size())</div><div class="line">            <span class="keyword">return</span> a.size() * sign &lt; v.a.size() * v.sign;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">            <span class="keyword">if</span> (a[i] != v.a[i])</div><div class="line">                <span class="keyword">return</span> a[i] * sign &lt; v.a[i] * sign;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> v &lt; *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(v &lt; *<span class="keyword">this</span>); &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; v); &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; v) &amp;&amp; !(v &lt; *<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> BigInteger &amp;v) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> &lt; v || v &lt; *<span class="keyword">this</span>; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!a.empty() &amp;&amp; !a.back())</div><div class="line">            a.pop_back();</div><div class="line">        <span class="keyword">if</span> (a.empty())</div><div class="line">            sign = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BigInteger <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</div><div class="line">        BigInteger res = *<span class="keyword">this</span>;</div><div class="line">        res.sign = -sign;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">BigInteger <span class="title">abs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        BigInteger res = *<span class="keyword">this</span>;</div><div class="line">        res.sign *= res.sign;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream, <span class="keyword">const</span> BigInteger &amp;v) &#123;</div><div class="line">        <span class="keyword">if</span> (v.sign == <span class="number">-1</span>)</div><div class="line">            stream &lt;&lt; <span class="string">'-'</span>;</div><div class="line">        stream &lt;&lt; (v.a.empty() ? <span class="number">0</span> : v.a.back());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) v.a.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">            stream &lt;&lt; setw(base_digits) &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; v.a[i];</div><div class="line">        <span class="keyword">return</span> stream;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, dp;</div><div class="line"><span class="built_in">vector</span>&lt;BigInteger&gt; cnt;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"buylow.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"buylow.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; N;</div><div class="line">    num = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</div><div class="line">    dp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</div><div class="line">    cnt = <span class="built_in">vector</span>&lt;BigInteger&gt;(N, BigInteger(<span class="number">0</span>));</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        fin &gt;&gt; num[i];</div><div class="line">    &#125;</div><div class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; cnt[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        dp[i] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (num[j] &gt; num[i]) &#123;</div><div class="line">                dp[i] = <span class="built_in">std</span>::max(dp[i], dp[j] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (num[j] &gt; num[i] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>) &#123;</div><div class="line">                cnt[i] += cnt[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) cnt[i] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (num[j] == num[i] &amp;&amp; dp[j] == dp[i]) &#123;</div><div class="line">                cnt[i] -= cnt[j]; <span class="comment">// remove duplicates.</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> maxLen = *<span class="built_in">std</span>::minmax_element(dp.begin(), dp.end()).second;</div><div class="line">    BigInteger finalCnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (maxLen == dp[i]) &#123;</div><div class="line">            finalCnt += cnt[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; maxLen &lt;&lt; <span class="string">" "</span> &lt;&lt; finalCnt &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; maxLen &lt;&lt; <span class="string">" "</span> &lt;&lt; finalCnt &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Essentially a longest decreasing sequence problem that is easy to solve using typical DP approach. Counting the number of such sequences 
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
      <category term="Big Integer" scheme="http://lianghan.org/tags/Big-Integer/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.2 Job Processing</title>
    <link href="http://lianghan.org/2017/01/08/2017-01-08-USACO-JobProcessing/"/>
    <id>http://lianghan.org/2017/01/08/2017-01-08-USACO-JobProcessing/</id>
    <published>2017-01-09T06:26:31.000Z</published>
    <updated>2017-01-10T05:30:04.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N, M1, M2;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; va, vb, cost, ta, tb;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)vec.size();</div><div class="line">    cost = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        <span class="keyword">int</span> min = INT_MAX, index;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</div><div class="line">            <span class="keyword">int</span> delay = cost[j] + vec[j];</div><div class="line">            <span class="keyword">if</span> (min &lt;= delay) <span class="keyword">continue</span>;</div><div class="line">            min = delay; index = j;</div><div class="line">        &#125;</div><div class="line">        cost[index] = min;</div><div class="line">        table[i] = min;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"job.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"job.out"</span>)</span></span>;</div><div class="line">    <span class="keyword">int</span> ansA, ansB = INT_MIN;</div><div class="line">    fin &gt;&gt; N &gt;&gt; M1 &gt;&gt; M2;</div><div class="line">    va = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M1, <span class="number">0</span>), vb = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M2, <span class="number">0</span>);</div><div class="line">    ta = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>), tb = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M1; ++i) fin &gt;&gt; va[i];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M2; ++i) fin &gt;&gt; vb[i];</div><div class="line">    compute(va, ta); compute(vb, tb);</div><div class="line">    sort(ta.begin(), ta.end());</div><div class="line">    sort(tb.begin(), tb.end(), [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;);</div><div class="line">    ansA = ta[N - <span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        ansB = <span class="built_in">std</span>::max(ta[i] + tb[i], ansB);</div><div class="line">    &#125;</div><div class="line">    fout &lt;&lt; ansA &lt;&lt; <span class="string">" "</span> &lt;&lt; ansB &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ansA &lt;&lt; <span class="string">" "</span> &lt;&lt; ansB &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/spa
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Greedy" scheme="http://lianghan.org/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.2 The Pefect Stall</title>
    <link href="http://lianghan.org/2017/01/04/2017-01-04-USACO-ThePerfectStall/"/>
    <id>http://lianghan.org/2017/01/04/2017-01-04-USACO-ThePerfectStall/</id>
    <published>2017-01-05T05:39:31.000Z</published>
    <updated>2017-01-05T05:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Standard bipartite match with Hungarain Algorithm.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N <span class="comment">/* cows */</span>, M <span class="comment">/* stalls */</span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; match;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">    graph[u].emplace_back(v);</div><div class="line">    graph[v].emplace_back(u);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">    visited[v] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[v].size(); ++i) &#123;</div><div class="line">        <span class="keyword">int</span> u = graph[v][i], w = match[u];</div><div class="line">        <span class="keyword">if</span> (w &lt; <span class="number">0</span> || (!visited[w] &amp;&amp; dfs(w))) &#123;</div><div class="line">            match[v] = u; match[u] = v;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite_match</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="built_in">std</span>::fill(match.begin(), match.end(), <span class="number">-1</span>);</div><div class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (match[i] &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</div><div class="line">        <span class="keyword">if</span> (!dfs(i)) <span class="keyword">continue</span>;</div><div class="line">        ++ans;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"stall4.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"stall4.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; N &gt;&gt; M;</div><div class="line">    <span class="keyword">int</span> size = N + M + <span class="number">1</span>;</div><div class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">    match = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">-1</span>);</div><div class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(size, <span class="literal">false</span>);</div><div class="line">    <span class="keyword">int</span> n, k;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        fin &gt;&gt; n;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</div><div class="line">            fin &gt;&gt; k;</div><div class="line">            addEdge(i, k + N);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = bipartite_match();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Standard bipartite match with Hungarain Algorithm.&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Graph Theory" scheme="http://lianghan.org/tags/Graph-Theory/"/>
    
      <category term="Bipartite Match" scheme="http://lianghan.org/tags/Bipartite-Match/"/>
    
      <category term="Hungarian Algorithm" scheme="http://lianghan.org/tags/Hungarian-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.2 Drainage Ditches</title>
    <link href="http://lianghan.org/2017/01/04/2017-01-04-USACO-DrainageDitches.h/"/>
    <id>http://lianghan.org/2017/01/04/2017-01-04-USACO-DrainageDitches.h/</id>
    <published>2017-01-04T21:08:31.000Z</published>
    <updated>2017-01-04T21:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Simple Network Flow problem with (inefficient) DFS based Ford-Fulkerson algorithm.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N, M, Si, Ei, Ci;</div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">    <span class="keyword">int</span> to, cap, rev;</div><div class="line">    Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> rev) :</div><div class="line">    to(to), cap(cap), rev(rev) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; graph;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    graph[from].emplace_back(Edge(to, cap, (<span class="keyword">int</span>)graph[to].size()));</div><div class="line">    graph[to].emplace_back(Edge(from, <span class="number">0</span>, (<span class="keyword">int</span>)graph[from].size() - <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Fordâ€“Fulkerson</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (v == t)</div><div class="line">        <span class="keyword">return</span> f;</div><div class="line">    visited[v] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph[v].size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">        <span class="keyword">auto</span> &amp;e = graph[v][i];</div><div class="line">        <span class="keyword">if</span> (visited[e.to] || e.cap &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">int</span> d = dfs(e.to, t, <span class="built_in">std</span>::min(f, e.cap));</div><div class="line">        <span class="keyword">if</span> (d &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        e.cap -= d;</div><div class="line">        graph[e.to][e.rev].cap += d;</div><div class="line">        <span class="keyword">return</span> d;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</div><div class="line">        <span class="keyword">int</span> f = dfs(s, t, INT_MAX);</div><div class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">return</span> flow;</div><div class="line">        flow += f;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"ditch.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"ditch.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; N <span class="comment">/* edges */</span> &gt;&gt; M <span class="comment">/* vertices */</span>;</div><div class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt;(M + <span class="number">1</span>, <span class="built_in">vector</span>&lt;Edge&gt;());</div><div class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(M + <span class="number">1</span>, <span class="literal">false</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        fin &gt;&gt; Si &gt;&gt; Ei &gt;&gt; Ci;</div><div class="line">        addEdge(Si, Ei, Ci);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans = maxFlow(<span class="number">1</span>, M);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Simple Network Flow problem with (inefficient) DFS based Ford-Fulkerson algorithm.&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Graph Theory" scheme="http://lianghan.org/tags/Graph-Theory/"/>
    
      <category term="Ford-Fulkerson" scheme="http://lianghan.org/tags/Ford-Fulkerson/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.1 Fence Loops</title>
    <link href="http://lianghan.org/2016/12/27/2016-12-27-USACO-FenceLoops/"/>
    <id>http://lianghan.org/2016/12/27/2016-12-27-USACO-FenceLoops/</id>
    <published>2016-12-27T22:34:31.000Z</published>
    <updated>2016-12-27T22:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>The problem is to find smallest loops in a DAG. The idea is simple: each loop must have a start vertex and an end vertex. Since no loop connects to itself as the problem stated, the start and end vertex must be different. Also, the smallest perimeter of such a loop is the shortest path between the start vertex and end vertex, plus the length of the edge between two vertices. So to find the loop with smallest perimeter, we can iterate through each edge, calculate the shortest distance between two vertices that connect the edge (without considering the edge itself, of course, otherwise the shortest distance between two vertices would be the edge itself.), then add length of the edge. Do this for all possible edge and we get the result. The shortest distance between two vertices can be calculated using <a href="http://lianghan.org/2016/08/03/2016-08-03-DijKstra/">Dijkstra algorithm I posted earlier</a>.</p>
<p>The pain point here is to properly transfer the source data to the graph representation. Here the transformation is done through state encoding (each vertex can be uniquely identified by the edge id it connects to). The overall code is a little bit bloated due to this.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// [to node index, edge weight] pair.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge;</div><div class="line"><span class="comment">// [node index, distance to source] pair.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; element;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; vxts;</div><div class="line"><span class="keyword">int</span> vxtCnt = <span class="number">0</span>;</div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vs;</div><div class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fence6.in"</span>)</span></span>;</div><div class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fence6.out"</span>)</span></span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; graph;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N, s, Ls, N1s, N2s;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVertexId</span><span class="params">(<span class="keyword">int</span> Ns)</span> </span>&#123;</div><div class="line">    vs.clear(); vs.insert(s);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Ns; ++j) &#123;</div><div class="line">        <span class="keyword">int</span> sn; fin &gt;&gt; sn;</div><div class="line">        vs.insert(sn);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> iter = vxts.find(vs);</div><div class="line">    <span class="keyword">if</span> (iter == vxts.end()) &#123;</div><div class="line">        vxts[vs] = vxtCnt++;</div><div class="line">        <span class="keyword">return</span> vxts[vs];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> iter-&gt;second;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">genGraph</span><span class="params">()</span> </span>&#123;</div><div class="line">    fin &gt;&gt; N;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;edge&gt;&gt; g;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        fin &gt;&gt; s &gt;&gt; Ls &gt;&gt; N1s &gt;&gt; N2s;</div><div class="line">        <span class="keyword">int</span> vtx1 = getVertexId(N1s);</div><div class="line">        <span class="keyword">int</span> vtx2 = getVertexId(N2s);</div><div class="line">        g[vtx1].emplace_back(make_pair(vtx2, Ls));</div><div class="line">        g[vtx2].emplace_back(make_pair(vtx1, Ls));</div><div class="line">    &#125;</div><div class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt;(vxtCnt, <span class="built_in">vector</span>&lt;edge&gt;());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vxtCnt; ++i) &#123;</div><div class="line">        graph[i] = g[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> compare &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> element&amp;a, <span class="keyword">const</span> element &amp;b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a.second &gt; b.second;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; &amp;graph, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)graph.size();</div><div class="line">    <span class="keyword">if</span> (!size) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span> (source &lt; <span class="number">0</span> || source &gt;= size || target &lt; <span class="number">0</span> || target &gt;= size)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(size, <span class="literal">false</span>);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distance(size, INT_MAX);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(size, <span class="number">-1</span>);</div><div class="line">    distance[source] = <span class="number">0</span>;</div><div class="line">    priority_queue&lt;element, <span class="built_in">vector</span>&lt;element&gt;, compare&gt; pq;</div><div class="line">    pq.emplace(make_pair(source, <span class="number">0</span>));</div><div class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</div><div class="line">        <span class="keyword">int</span> v = pq.top().first;</div><div class="line">        pq.pop();</div><div class="line">        <span class="keyword">if</span> (v == target) <span class="keyword">return</span> distance[v];</div><div class="line">        <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph[v]) &#123;</div><div class="line">            <span class="keyword">int</span> u = edge.first; <span class="comment">// vertice u that connects to v.</span></div><div class="line">            <span class="keyword">int</span> w = edge.second; <span class="comment">// weight of edge that connects u and v.</span></div><div class="line">            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span> (distance[v] &lt; distance[u] - w) &#123;</div><div class="line">                distance[u] = distance[v] + w;</div><div class="line">                pq.emplace(make_pair(u, distance[u]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        visited[v] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    genGraph();</div><div class="line">    <span class="keyword">int</span> ans = INT_MAX;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vxtCnt; ++i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e1 : graph[i]) &#123;</div><div class="line">            <span class="keyword">int</span> w = e1.second;</div><div class="line">            <span class="keyword">int</span> to = e1.first;</div><div class="line">            edge *e2;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[to].size(); ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (graph[to][j].first == i) &#123;</div><div class="line">                    e2 = &amp;graph[to][j];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            e1.second = INT_MAX;</div><div class="line">            e2-&gt;second = INT_MAX;</div><div class="line">            <span class="keyword">int</span> p = dijkstra(graph, i, to);</div><div class="line">            <span class="keyword">if</span> (p != <span class="number">-1</span> &amp;&amp; p + w &lt; ans) &#123;</div><div class="line">                ans = p + w;</div><div class="line">            &#125;</div><div class="line">            e1.second = w;</div><div class="line">            e2-&gt;second = INT_MAX;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The problem is to find smallest loops in a DAG. The idea is simple: each loop must have a start vertex and an end vertex. Since no loop c
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Dijkstra" scheme="http://lianghan.org/tags/Dijkstra/"/>
    
      <category term="Graph Theory" scheme="http://lianghan.org/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.1 Beef McNuggests</title>
    <link href="http://lianghan.org/2016/12/23/2016-12-23-USACO-BeefMcNuggets/"/>
    <id>http://lianghan.org/2016/12/23/2016-12-23-USACO-BeefMcNuggets/</id>
    <published>2016-12-24T05:29:31.000Z</published>
    <updated>2016-12-26T18:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</div><div class="line">    <span class="keyword">return</span> gcd(b, a % b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"nuggets.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"nuggets.out"</span>)</span></span>;</div><div class="line"></div><div class="line">    fin &gt;&gt; N;</div><div class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        fout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    vals = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        fin &gt;&gt; vals[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> n = vals[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</div><div class="line">        n = gcd(n, vals[i]);</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        fout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sort(vals.begin(), vals.end());</div><div class="line">    <span class="keyword">int</span> max = vals[N - <span class="number">1</span>] * vals[N - <span class="number">2</span>] * gcd(vals[N - <span class="number">1</span>], vals[N - <span class="number">2</span>]);</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(max, <span class="literal">false</span>);</div><div class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = vals[i]; j &lt;= max; ++j) &#123;</div><div class="line">            <span class="keyword">if</span>(dp[j - vals[i]]) &#123;</div><div class="line">               dp[j] = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max; i &gt; <span class="number">0</span>; --i) &#123;</div><div class="line">        <span class="keyword">if</span> (!dp[i]) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            fout &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/spa
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Number Theory" scheme="http://lianghan.org/tags/Number-Theory/"/>
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.4 Raucous Rockers</title>
    <link href="http://lianghan.org/2016/12/16/2016-12-16-USACO-RaucousRockers/"/>
    <id>http://lianghan.org/2016/12/16/2016-12-16-USACO-RaucousRockers/</id>
    <published>2016-12-17T01:09:31.000Z</published>
    <updated>2016-12-18T16:44:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Typical BackPack problem but with the limited scale of test data, a straight forward brutal force search could do it. The search space is the permutation of subsets of all songs, for each song we have two choice - choose or not choose. Iterate the sequence under the constraint of ordering.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N <span class="comment">/* songs */</span>, M <span class="comment">/* disks */</span>, T <span class="comment">/* disk capacity */</span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; songs;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; disks;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"rockers.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"rockers.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; N &gt;&gt; T &gt;&gt; M;</div><div class="line">    songs = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        fin &gt;&gt; songs[i];</div><div class="line">    &#125;</div><div class="line">    disks = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M, <span class="number">0</span>);</div><div class="line">    <span class="keyword">int</span> ans = INT_MIN;</div><div class="line">    <span class="keyword">int</span> upper = <span class="number">1</span> &lt;&lt; N;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= upper; ++i) &#123;</div><div class="line">        <span class="built_in">std</span>::fill(disks.begin(), disks.end(), <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</div><div class="line">            <span class="keyword">bool</span> pick = (<span class="number">1</span> &lt;&lt; j) &amp; i;</div><div class="line">            <span class="keyword">if</span> (!pick) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = idx; k &lt; M; ++k, ++idx)&#123;</div><div class="line">                <span class="keyword">if</span>(disks[k] + songs[j] &lt;= T)&#123;</div><div class="line">                    disks[k] += songs[j];</div><div class="line">                    ++sum;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ans = <span class="built_in">std</span>::max(ans, sum);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Typical BackPack problem but with the limited scale of test data, a straight forward brutal force search could do it. The search space is
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Search" scheme="http://lianghan.org/tags/Search/"/>
    
      <category term="Brutal Force" scheme="http://lianghan.org/tags/Brutal-Force/"/>
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.4 Electric Fence</title>
    <link href="http://lianghan.org/2016/12/14/2016-12-14-USACO-ElectricFence/"/>
    <id>http://lianghan.org/2016/12/14/2016-12-14-USACO-ElectricFence/</id>
    <published>2016-12-15T05:34:31.000Z</published>
    <updated>2016-12-18T16:44:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.math.hmc.edu/funfacts/ffiles/10002.2.shtml" target="_blank" rel="external">Pickâ€™s Theorem</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</div><div class="line">    a %= b;</div><div class="line">    <span class="keyword">return</span> gcd(b, a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, p;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fence9.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fence9.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</div><div class="line">    <span class="keyword">int</span> ret = p * m / <span class="number">2.0</span> - (gcd(m, n) + gcd(m, <span class="built_in">abs</span>(p - n)) + p) / <span class="number">2.0</span> + <span class="number">1</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.math.hmc.edu/funfacts/ffiles/10002.2.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pickâ€™s Theorem&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;hig
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Math" scheme="http://lianghan.org/tags/Math/"/>
    
      <category term="Computation Geometry" scheme="http://lianghan.org/tags/Computation-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>SRM 703 GCDGraph</title>
    <link href="http://lianghan.org/2016/12/14/2016-12-13-TopCoder-SRM-703-GCDGraph/"/>
    <id>http://lianghan.org/2016/12/14/2016-12-13-TopCoder-SRM-703-GCDGraph/</id>
    <published>2016-12-14T19:42:31.000Z</published>
    <updated>2016-12-18T16:44:13.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> GCDGraph &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree(n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="built_in">std</span>::iota(tree.begin(), tree.end(), <span class="number">0</span>);</div><div class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; root = [&amp;] (<span class="keyword">int</span> i) &#123;</div><div class="line">            <span class="keyword">if</span> (tree[i] != i) &#123;</div><div class="line">                <span class="comment">// Tail recursion is surprisingly well optimized</span></div><div class="line">                <span class="comment">// here by compiler to pass large test data set.</span></div><div class="line">                tree[i] = root(tree[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> tree[i];</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> r = root(i);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) &#123;</div><div class="line">                tree[root(j)] = r;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> root(x) == root(y) ? <span class="string">"Possible"</span> : <span class="string">"Impossible"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; GCDGraph &amp;#123;&lt;/div&gt;&lt;di
    
    </summary>
    
      <category term="TopCoder" scheme="http://lianghan.org/categories/TopCoder/"/>
    
    
      <category term="UnionFind" scheme="http://lianghan.org/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.4 American Heritage</title>
    <link href="http://lianghan.org/2016/12/12/2016-12-12-USACO-AmericanHeritage/"/>
    <id>http://lianghan.org/2016/12/12/2016-12-12-USACO-AmericanHeritage/</id>
    <published>2016-12-13T00:17:31.000Z</published>
    <updated>2016-12-13T04:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probably the most easiest problem solved on USACO so far?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">string</span> preorder;</div><div class="line"><span class="built_in">string</span> inorder;</div><div class="line"><span class="built_in">string</span> postorder;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> TreeNode &#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">char</span> c) : left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>), c(c) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">TreeNode *<span class="title">construct</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (inorder[i] == preorder[preStart]) &#123;</div><div class="line">            index = i; <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    root-&gt;left = construct(preStart + <span class="number">1</span>, preStart + index - inStart,</div><div class="line">                           inStart, index - <span class="number">1</span>);</div><div class="line">    root-&gt;right = construct(preStart + index - inStart + <span class="number">1</span>, preEnd,</div><div class="line">                            index + <span class="number">1</span>, inEnd);</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postTraverse</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</div><div class="line">    postTraverse(root-&gt;left);</div><div class="line">    postTraverse(root-&gt;right);</div><div class="line">    postorder += root-&gt;c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"heritage.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"heritage.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; inorder &gt;&gt; preorder;</div><div class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)inorder.size();</div><div class="line">    postTraverse(construct(<span class="number">0</span>, size - <span class="number">1</span>, <span class="number">0</span>, size - <span class="number">1</span>));</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; postorder &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; postorder &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probably the most easiest problem solved on USACO so far?&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="DFS" scheme="http://lianghan.org/tags/DFS/"/>
    
      <category term="Tree" scheme="http://lianghan.org/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.3 Camelot</title>
    <link href="http://lianghan.org/2016/12/09/2016-12-09-USACO-Camelot/"/>
    <id>http://lianghan.org/2016/12/09/2016-12-09-USACO-Camelot/</id>
    <published>2016-12-10T05:15:31.000Z</published>
    <updated>2016-12-12T05:45:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Interesting problemâ€¦ thinking this way:</p>
<ul>
<li>What would be the final meeting point? Hard to tell so letâ€™s do a search for every point on the grid.</li>
<li>What if there is no king? Then itâ€™s much easier, we just need to find a point whose sum of steps to all the knights is minimum. This could be done by doing BFS starting from each knight, and ending at the desired point. Since we donâ€™t know what the desired point is, the target is the entire grid.</li>
<li>Now add king into the picture. King has interesting property that he does not cost any steps if with at least one knights. There are two cases here: first, the king might walk himself to the final meeting point; and second, there might be one or more knights that pick up the king <em>at certain point</em> and then head to meeting point together.</li>
<li>So how to find that <em>certain point</em> where a king might be picked up by a knight? Hard to tell again so letâ€™s do a search for every point on the gridâ€¦ err that is not good, and will timeout. Interestingly, it turns out that for the test data, this pick up location is within 2 or 3 steps at most from where the king initially was, so we can cut the search space. Not sure if this can be proved thoughâ€¦</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> R, C;</div><div class="line"><span class="keyword">int</span> sum[<span class="number">32</span>][<span class="number">32</span>];</div><div class="line"><span class="keyword">int</span> dist[<span class="number">32</span>][<span class="number">32</span>][<span class="number">32</span>][<span class="number">32</span>];</div><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">    <span class="keyword">int</span> x, y, d;</div><div class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d) : x(x), y(y), d(d) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;Node&gt; knights;</div><div class="line"><span class="function">Node <span class="title">king</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</div><div class="line"><span class="keyword">int</span> x, y;</div><div class="line"><span class="keyword">char</span> yc;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onGrid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; R || y &gt; C) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">knightBFS</span><span class="params">(Node k)</span> </span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</div><div class="line">    q.push(k);</div><div class="line">    <span class="keyword">int</span> sx = k.x, sy = k.y;</div><div class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</div><div class="line">    <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">        <span class="keyword">auto</span> node = q.front();</div><div class="line">        q.pop();</div><div class="line">        <span class="keyword">int</span> x = node.x, y = node.y;</div><div class="line">        dist[x][y][x][y] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> xx = x + dx[i];</div><div class="line">            <span class="keyword">int</span> yy = y + dy[i];</div><div class="line">            <span class="keyword">if</span> (!onGrid(xx, yy)) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span> (dist[sx][sy][xx][yy] != <span class="number">-1</span>) <span class="keyword">continue</span>;</div><div class="line">            q.emplace(Node(xx, yy, node.d + <span class="number">1</span>));</div><div class="line">            dist[sx][sy][xx][yy] = node.d + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"camelot.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"camelot.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; R &gt;&gt; C;</div><div class="line">    <span class="keyword">bool</span> kingFound = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (fin &gt;&gt; yc &gt;&gt; x) &#123;</div><div class="line">        y = yc - <span class="string">'A'</span> + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (!kingFound) &#123;</div><div class="line">            king = Node(x, y, <span class="number">0</span>);</div><div class="line">            kingFound = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            knights.emplace_back(Node(x, y, <span class="number">0</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist));</div><div class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; ++j) &#123;</div><div class="line">            knightBFS(Node(i, j, <span class="number">0</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;knight : knights) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; ++j) &#123;</div><div class="line">                sum[i][j] += dist[knight.x][knight.y][i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = INT_MAX;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_STEP = <span class="number">3</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; ++j) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dx = -MAX_STEP; dx &lt;= MAX_STEP; ++dx) &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> dy = -MAX_STEP; dy &lt;= MAX_STEP; ++dy) &#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;knight : knights) &#123;</div><div class="line">                        <span class="keyword">if</span> (!onGrid(king.x + dx, king.y + dy)) <span class="keyword">continue</span>;</div><div class="line">                        <span class="keyword">int</span> kx = knight.x, ky = knight.y;</div><div class="line">                        <span class="keyword">int</span> d1 = dist[king.x + dx][king.y + dy][i][j],</div><div class="line">                        d2 = dist[kx][ky][king.x + dx][king.y + dy];</div><div class="line">                        <span class="keyword">if</span> (d1 == <span class="number">-1</span> || d2 == <span class="number">-1</span>) <span class="keyword">continue</span>;</div><div class="line">                        </div><div class="line">                        <span class="keyword">int</span> distance = sum[i][j] -dist[kx][ky][i][j] + d1 + d2</div><div class="line">                        + <span class="built_in">std</span>::max(<span class="built_in">abs</span>(dx),<span class="built_in">abs</span>(dy));</div><div class="line">                        ans = <span class="built_in">std</span>::min(distance, ans);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;= C; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (sum[i][j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">            ans = min(sum[i][j] + max(<span class="built_in">abs</span>(i - king.x), <span class="built_in">abs</span>(j - king.y)),ans);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Interesting problemâ€¦ thinking this way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What would be the final meeting point? Hard to tell so letâ€™s do a search for every p
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="BFS" scheme="http://lianghan.org/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.3 Home On The Range</title>
    <link href="http://lianghan.org/2016/12/07/2016-12-07-USACO-HomeOnRange/"/>
    <id>http://lianghan.org/2016/12/07/2016-12-07-USACO-HomeOnRange/</id>
    <published>2016-12-07T18:44:31.000Z</published>
    <updated>2016-12-12T05:45:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Another relatively straightforward DP problem: the basic idea is to calculate the maximum possible squares (land segment that cows can graze on) that each land can expand to, if the given land is considered as the top-left most corner of the square land segment to be expanded. We calculate this information for each land, starting from the right-down most land (which is just itself), then iteratively repeat the calculation until we reach the top-left most corner. During the computation we can also calculate the final answer incrementally.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"range.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"range.out"</span>)</span></span>;</div><div class="line"></div><div class="line">    fin &gt;&gt; N;</div><div class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</div><div class="line">    ret = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</div><div class="line">            fin &gt;&gt; c;</div><div class="line">            dp[i][j] = c - <span class="string">'0'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</div><div class="line">            <span class="keyword">if</span> (!dp[i][j]) <span class="keyword">continue</span>;</div><div class="line">            dp[i][j] = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]),</div><div class="line">                                dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= dp[i][j]; ++k) &#123;</div><div class="line">                ret[k]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (!ret[i]) <span class="keyword">continue</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ret[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        fout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ret[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Another relatively straightforward DP problem: the basic idea is to calculate the maximum possible squares (land segment that cows can gr
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.3 A Game</title>
    <link href="http://lianghan.org/2016/11/29/2016-11-29-USACO-AGame/"/>
    <id>http://lianghan.org/2016/11/29/2016-11-29-USACO-AGame/</id>
    <published>2016-11-30T05:17:31.000Z</published>
    <updated>2016-11-30T22:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Typical dynamic programming problem. The search space is the optimal value player A could get at a given play step. A play step can be identified by the current state of the board - namely the unused board which is marked by the starting (left) and ending (right) indices. Letâ€™s denote the start index as a, end index as b, and denote dp[a][b] as the optimal value player A could get.</p>
<p>Next we need find out the state transfer function. Since player B will also play optimally (that is, player B is as smart as player A, and both players will try use same optimal strategy to win the game), we can have the transfer function like this:</p>
<p>$f(a, b) = \begin{cases}0 &amp; a &gt; b \\<br>max(f(a) + min(f(a + 2, b), f(a + 1, b - 1)), f(b) + min(f(a, b - 2), f(a + 1, b - 1) &amp; a \le b \\<br>\end{cases}$</p>
<p>And this could be calculated recursively (from two ends of board to middle).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; board;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (dp[a][b] == <span class="number">-1</span>) &#123;</div><div class="line">        dp[a][b] = <span class="built_in">std</span>::max(board[a] + <span class="built_in">std</span>::min(compute(a + <span class="number">2</span>, b),</div><div class="line">                                                compute(a + <span class="number">1</span>, b - <span class="number">1</span>)),</div><div class="line">                            board[b] + <span class="built_in">std</span>::min(compute(a, b - <span class="number">2</span>),</div><div class="line">                                                compute(a + <span class="number">1</span>, b - <span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[a][b];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"game1.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"game1.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; N;</div><div class="line">    board = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</div><div class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">-1</span>));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        fin &gt;&gt; board[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(board.begin(), board.end(), <span class="number">0</span>);</div><div class="line">    <span class="keyword">int</span> p1 = compute(<span class="number">0</span>, N - <span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> p2 = sum - p1;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Typical dynamic programming problem. The search space is the optimal value player A could get at a given play step. A play step can be id
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.3 Shopping Offers</title>
    <link href="http://lianghan.org/2016/11/28/2016-11-28-USACO-ShoppingOffers/"/>
    <id>http://lianghan.org/2016/11/28/2016-11-28-USACO-ShoppingOffers/</id>
    <published>2016-11-28T17:21:31.000Z</published>
    <updated>2016-11-29T02:58:35.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> dp[<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>];</div><div class="line"><span class="comment">// 2nd dimension stores the offer price as element 0, (normalized) product</span></div><div class="line"><span class="comment">// code as element 1, 2, 3, 4, 5.</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; offer(<span class="number">106</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">0</span>));</div><div class="line"><span class="comment">// Normalize product code to the range of 1-5 inclusive.</span></div><div class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line"><span class="keyword">int</span> s;</div><div class="line"><span class="keyword">int</span> totalOffers;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buy(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">0</span>));</div><div class="line"><span class="keyword">int</span> sentinel;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a1,<span class="keyword">int</span> a2, <span class="keyword">int</span> a3,<span class="keyword">int</span> a4,<span class="keyword">int</span> a5)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(dp[a1][a2][a3][a4][a5] != sentinel)</div><div class="line">        <span class="keyword">return</span> dp[a1][a2][a3][a4][a5];</div><div class="line">    <span class="keyword">int</span> w1,w2,w3,w4,w5, ret = sentinel;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalOffers; ++i)&#123;</div><div class="line">        w1 = a1 - offer[i][<span class="number">1</span>];w2 = a2 - offer[i][<span class="number">2</span>];</div><div class="line">        w3 = a3 - offer[i][<span class="number">3</span>];w4 = a4 - offer[i][<span class="number">4</span>];</div><div class="line">        w5 = a5 - offer[i][<span class="number">5</span>];</div><div class="line">        <span class="keyword">if</span>(w1 &lt; <span class="number">0</span> || w2 &lt; <span class="number">0</span> || w3 &lt; <span class="number">0</span> || w4 &lt; <span class="number">0</span> || w5 &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(dp[w1][w2][w3][w4][w5] == sentinel) &#123;</div><div class="line">            dp[w1][w2][w3][w4][w5] = compute(w1,w2,w3,w4,w5);</div><div class="line">        &#125;</div><div class="line">        ret = <span class="built_in">std</span>::min(ret, dp[w1][w2][w3][w4][w5] + offer[i][<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"shopping.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"shopping.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; s;</div><div class="line">    <span class="keyword">int</span> n, c, k, b, code = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</div><div class="line">        fin &gt;&gt; n;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</div><div class="line">            fin &gt;&gt; c &gt;&gt; k;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(c) == <span class="built_in">map</span>.end()) &#123;</div><div class="line">                <span class="built_in">map</span>[c] = ++code;</div><div class="line">            &#125;</div><div class="line">            offer[i][<span class="built_in">map</span>[c]] = k;</div><div class="line">        &#125;</div><div class="line">        fin &gt;&gt; offer[i][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fin &gt;&gt; b;</div><div class="line">    totalOffers = s + b;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; ++i)&#123;</div><div class="line">        fin &gt;&gt; c &gt;&gt; k;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.find(c) == <span class="built_in">map</span>.end()) &#123;</div><div class="line">            <span class="built_in">map</span>[c] = ++code;</div><div class="line">        &#125;</div><div class="line">        offer[s + i][<span class="built_in">map</span>[c]] = <span class="number">1</span>;</div><div class="line">        buy[<span class="built_in">map</span>[c]] = k;</div><div class="line">        fin &gt;&gt; offer[s + i][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">memset</span>(dp, <span class="number">0xf</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">    sentinel = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ret = compute(buy[<span class="number">1</span>], buy[<span class="number">2</span>], buy[<span class="number">3</span>], buy[<span class="number">4</span>], buy[<span class="number">5</span>]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/spa
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Graph" scheme="http://lianghan.org/tags/Graph/"/>
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>UASCO 3.3 Riding The Fence</title>
    <link href="http://lianghan.org/2016/11/25/2016-11-25-USACO-RidingTheFence/"/>
    <id>http://lianghan.org/2016/11/25/2016-11-25-USACO-RidingTheFence/</id>
    <published>2016-11-26T07:04:31.000Z</published>
    <updated>2016-11-27T16:26:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is a problem to find Euler Path of the graph. As this is an undirected graph, the Euler Path exists iff:</p>
<ul>
<li>All graph vertices have even degree. Or,</li>
<li>All graph vertices have even degree, except two vertices have odd degree. And these two vertices will be start / end of the Euler Path.</li>
</ul>
<p>This problem explicitly stated that the Euler Path existing, so no need to do the test to find out if the path exists or not. Instead, the job is to find out the exact path with the constraint that vertices should be sequenced in ascending order. There are a couple of well studied algorithm can solve the Euler Path finding problem, however for this test data set I find that we can just use DFS - which is not strictly a Euler Path finding solution because the DFS solution here alone canâ€™t decide if an edge we are going to remove is a â€˜bridge edgeâ€™ (which, if removed will never makes us traverse back to the graph). I think the solution here is not sound to cover any type of Euler Path, but is just lucky enough to pass the existing test data set.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIMIT = <span class="number">501</span>;</div><div class="line"><span class="keyword">int</span> F;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(LIMIT, <span class="number">0</span>);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(LIMIT, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(LIMIT, <span class="number">0</span>));</div><div class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!degree[idx]) &#123;</div><div class="line">        path.push(idx);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LIMIT; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (adj[idx][i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        --adj[idx][i]; --adj[i][idx]; --degree[idx]; --degree[i];</div><div class="line">        dfs(i);</div><div class="line">    &#125;</div><div class="line">    path.push(idx);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"fence.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"fence.out"</span>)</span></span>;</div><div class="line">    fin &gt;&gt; F;</div><div class="line">    <span class="keyword">int</span> v1, v2;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F; ++i) &#123;</div><div class="line">        fin &gt;&gt; v1 &gt;&gt; v2;</div><div class="line">        adj[v1][v2]++; adj[v2][v1]++;</div><div class="line">        degree[v1]++; degree[v2]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LIMIT; ++i)&#123;</div><div class="line">        <span class="keyword">if</span>(degree[i] % <span class="number">2</span>)&#123;</div><div class="line">            start = i;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dfs(start);</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (!path.empty()) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; path.top() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        fout &lt;&lt; path.top() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        path.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is a problem to find Euler Path of the graph. As this is an undirected graph, the Euler Path exists iff:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All graph vert
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Graph" scheme="http://lianghan.org/tags/Graph/"/>
    
      <category term="DFS" scheme="http://lianghan.org/tags/DFS/"/>
    
      <category term="Euler Path" scheme="http://lianghan.org/tags/Euler-Path/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.2 Sweet Butter</title>
    <link href="http://lianghan.org/2016/11/23/2016-11-23-USACO-SweetButter/"/>
    <id>http://lianghan.org/2016/11/23/2016-11-23-USACO-SweetButter/</id>
    <published>2016-11-24T01:44:31.000Z</published>
    <updated>2016-11-24T01:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>This problem is essentially a shortest path problem: given a graph, find a single node in the graph (where we will put the butter) such that the combined distances from this graph node (the butter) to a set of graph nodes (the graph nodes where the cows are placed) is minimized.<br>The basic idea is for every node (pasture) in the graph, we calculate the shortest distances between this node and the rest of the nodes. Then for every node (pasture), we sum up the distances between itself and the pastures where cows are placed. The calculation of shortest paths between current pasture and the rest of pasture could be further optimized, as we only care about pasture with cows, so we can skip the pastures pairs where both pastures donâ€™t have cows. But even without this optimization the code pass the test data set. The code use a slightly modified version of <a href="http://lianghan.org/2016/08/03/2016-08-03-DijKstra/">Dijkstra algorithm I posted earlier</a>, otherwise there would be too much redundant computations that leads to timeout errors for large test data set.</p>
<p>I suspect this problem can also be solved using Bellmen-Ford or SFPA, and that would be a good exercise at some point in futureâ€¦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N <span class="comment">/* cows */</span>, P <span class="comment">/* pastures */</span>, C <span class="comment">/* paths */</span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c2p;<span class="comment">// [to node index, edge weight] pair.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge;</div><div class="line"><span class="comment">// [node index, distance to source] pair.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; element;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; graph;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</div><div class="line"></div><div class="line"><span class="keyword">class</span> compare &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> element&amp;a, <span class="keyword">const</span> element &amp;b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a.second &gt; b.second;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; &amp;graph, <span class="keyword">int</span> source)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::fill(visited.begin(), visited.end(), <span class="literal">false</span>);</div><div class="line">    <span class="built_in">std</span>::fill(dist.begin(), dist.end(), INT_MAX);</div><div class="line">    dist[source] = <span class="number">0</span>;</div><div class="line">    priority_queue&lt;element, <span class="built_in">vector</span>&lt;element&gt;, compare&gt; pq;</div><div class="line">    pq.emplace(make_pair(source, <span class="number">0</span>));</div><div class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</div><div class="line">        <span class="keyword">int</span> v = pq.top().first;</div><div class="line">        pq.pop();</div><div class="line">        <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : graph[v]) &#123;</div><div class="line">            <span class="keyword">int</span> u = edge.first; <span class="comment">// vertice u that connects to v.</span></div><div class="line">            <span class="keyword">int</span> w = edge.second; <span class="comment">// weight of edge that connects u and v.</span></div><div class="line">            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span> (dist[v] + w &lt; dist[u]) &#123;</div><div class="line">                dist[u] = dist[v] + w;</div><div class="line">                pq.emplace(make_pair(u, dist[u]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        visited[v] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"butter.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"butter.out"</span>)</span></span>;</div><div class="line"></div><div class="line">    fin &gt;&gt; N &gt;&gt; P &gt;&gt; C;</div><div class="line">    c2p = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt;(C + <span class="number">1</span>, <span class="built_in">vector</span>&lt;edge&gt;());</div><div class="line">    dist = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C + <span class="number">1</span>, INT_MAX);</div><div class="line">    visited = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(C + <span class="number">1</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</div><div class="line">        fin &gt;&gt; c2p[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; ++i) &#123;</div><div class="line">        <span class="keyword">int</span> s, d, w;</div><div class="line">        fin &gt;&gt; s &gt;&gt; d &gt;&gt; w;</div><div class="line">        graph[s].emplace_back(make_pair(d, w));</div><div class="line">        graph[d].emplace_back(make_pair(s, w));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = INT_MAX;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P; ++i) &#123;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</div><div class="line">        dijkstra(graph, i);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</div><div class="line">            ans += dist[c2p[j]];</div><div class="line">        &#125;</div><div class="line">        ret = <span class="built_in">std</span>::min(ret, ans);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fout &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This problem is essentially a shortest path problem: given a graph, find a single node in the graph (where we will put the butter) such t
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Search" scheme="http://lianghan.org/tags/Search/"/>
    
      <category term="Dijkstra" scheme="http://lianghan.org/tags/Dijkstra/"/>
    
      <category term="Graph" scheme="http://lianghan.org/tags/Graph/"/>
    
      <category term="Shortest Path" scheme="http://lianghan.org/tags/Shortest-Path/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.2 Magic Squares</title>
    <link href="http://lianghan.org/2016/11/19/2016-11-19-USACO-MagicSquares/"/>
    <id>http://lianghan.org/2016/11/19/2016-11-19-USACO-MagicSquares/</id>
    <published>2016-11-19T23:10:31.000Z</published>
    <updated>2016-11-19T23:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Typical solution for â€˜minimumâ€™ or â€˜maximumâ€™ problems:</p>
<ul>
<li>Greedy</li>
<li>Dynamic Programming</li>
<li>BFS</li>
</ul>
<p>For this problem, it is not obvious about overlapping sub-problems so BFS is an obvious solution.<br>The tricky parts are:</p>
<ul>
<li>How to encode the transforms (the A, B, and C).</li>
<li>How to test if a state has been explored.</li>
<li>How to perform backtracking once we have hit desired states.</li>
</ul>
<p>I think this problem is very good on testing implementation skills, as the algorithm itself is not very complicated.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tx = &#123;</div><div class="line">    &#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;, <span class="comment">// A</span></div><div class="line">    &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>&#125;, <span class="comment">// B</span></div><div class="line">    &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>&#125;, <span class="comment">// C</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> state &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</div><div class="line">    state() &#123;</div><div class="line">        val = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>);</div><div class="line">        <span class="built_in">std</span>::iota(val.begin(), val.end(), <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">queue</span>&lt;state&gt; q;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_STATES = <span class="number">40500</span>;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(MAX_STATES, <span class="literal">false</span>);</div><div class="line"><span class="comment">// Stores state_hash:(previous state hash : transform index)</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; trace(MAX_STATES, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>));</div><div class="line"><span class="comment">// Stores state_hash:transform index</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; transforms(MAX_STATES, <span class="number">0</span>);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factorial = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>&#125;;</div><div class="line"><span class="comment">// Expected state (read from input.).</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; target(<span class="number">8</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">int</span> steps;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>, t = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</div><div class="line">        t = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">8</span>; ++j) &#123;</div><div class="line">            <span class="keyword">if</span>(state[j] &lt; state[i]) ++t;</div><div class="line">        &#125;</div><div class="line">        sum += t * factorial[<span class="number">7</span> - i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</div><div class="line">    trace[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">    q.emplace(state());</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</div><div class="line">        <span class="keyword">auto</span> cur = q.front();q.pop();</div><div class="line">        hash = hashing(cur.val);</div><div class="line">        <span class="keyword">if</span>(cur.val == target)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">            state next;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</div><div class="line">                next.val[j] = cur.val[tx[i][j] - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> next_state_hash = hashing(next.val);</div><div class="line">            <span class="keyword">if</span> (visited[next_state_hash]) <span class="keyword">continue</span>;</div><div class="line">            q.push(next);</div><div class="line">            visited[next_state_hash] = <span class="literal">true</span>;</div><div class="line">            trace[next_state_hash][<span class="number">0</span>] = hash;</div><div class="line">            trace[next_state_hash][<span class="number">1</span>] = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (trace[hash][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</div><div class="line">        transforms[steps]= trace[hash][<span class="number">1</span>];</div><div class="line">        hash = trace[hash][<span class="number">0</span>];</div><div class="line">        ++steps;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(ofstream &amp;fout)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; steps &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; steps &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = steps - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">        <span class="keyword">char</span> c = transforms[i] + <span class="string">'A'</span>;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; c; fout &lt;&lt; c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fout &lt;&lt; <span class="built_in">endl</span>; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"msquare.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"msquare.out"</span>)</span></span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</div><div class="line">        fin &gt;&gt; target[i];</div><div class="line">    &#125;</div><div class="line">    bfs();</div><div class="line">    output(fout);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Typical solution for â€˜minimumâ€™ or â€˜maximumâ€™ problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Greedy&lt;/li&gt;
&lt;li&gt;Dynamic Programming&lt;/li&gt;
&lt;li&gt;BFS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For thi
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Search" scheme="http://lianghan.org/tags/Search/"/>
    
      <category term="BFS" scheme="http://lianghan.org/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.2 Feed Ratios</title>
    <link href="http://lianghan.org/2016/11/08/2016-11-08-USACO-FeedRatios/"/>
    <id>http://lianghan.org/2016/11/08/2016-11-08-USACO-FeedRatios/</id>
    <published>2016-11-08T18:45:31.000Z</published>
    <updated>2016-11-09T03:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Could be solved using Gauss Elimination, but there is a constraint on the mixture upper bound (less than 100), so a brutal force search could do it.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goal(<span class="number">3</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; source(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anws(<span class="number">4</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">int</span> total = INT_MAX;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sum)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (sum[<span class="number">0</span>] &lt; goal[<span class="number">0</span>] || sum[<span class="number">1</span>] &lt; goal[<span class="number">1</span>] || sum[<span class="number">2</span>] &lt; goal[<span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">if</span> (sum[<span class="number">0</span>] * goal[<span class="number">1</span>] != sum[<span class="number">1</span>] * goal[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">if</span> (sum[<span class="number">1</span>] * goal[<span class="number">2</span>] != sum[<span class="number">2</span>] * goal[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sum, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">3</span>; ++idx) &#123;</div><div class="line">    sum[idx] = source[<span class="number">0</span>][idx] * i + source[<span class="number">1</span>][idx] * j + source[<span class="number">2</span>][idx] * k;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"ratios.in"</span>)</span></span>;</div><div class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"ratios.out"</span>)</span></span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">    fin &gt;&gt; goal[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</div><div class="line">      fin &gt;&gt; source[i][j];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">auto</span> gSum = <span class="built_in">std</span>::accumulate(goal.begin(), goal.end(), <span class="number">0</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; ++j) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; ++k) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(<span class="number">3</span>, <span class="number">0</span>);</div><div class="line">        fillSum(sum, i, j, k);</div><div class="line">        <span class="keyword">if</span> (!judge(sum)) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span> (i + j + k &gt; total) <span class="keyword">continue</span>;</div><div class="line">        total = i + j + k;</div><div class="line">        anws[<span class="number">0</span>] = i; anws[<span class="number">1</span>] = j; anws[<span class="number">2</span>] = k;</div><div class="line">        anws[<span class="number">3</span>] = <span class="built_in">std</span>::accumulate(sum.begin(), sum.end(), <span class="number">0</span>) / gSum;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (anws[<span class="number">3</span>] == INT_MAX || (anws[<span class="number">3</span>] == <span class="number">0</span> &amp;&amp; gSum != <span class="number">0</span>)) &#123;</div><div class="line">    fout &lt;&lt; <span class="string">"NONE"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">      fout &lt;&lt; anws[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    fout &lt;&lt; anws[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Could be solved using Gauss Elimination, but there is a constraint on the mixture upper bound (less than 100), so a brutal force search c
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Search" scheme="http://lianghan.org/tags/Search/"/>
    
      <category term="Gauss Elimination" scheme="http://lianghan.org/tags/Gauss-Elimination/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.2 Spinning Wheels</title>
    <link href="http://lianghan.org/2016/11/06/2016-11-06-USACO-SpinningWheels/"/>
    <id>http://lianghan.org/2016/11/06/2016-11-06-USACO-SpinningWheels/</id>
    <published>2016-11-06T22:59:31.000Z</published>
    <updated>2016-11-06T23:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>This problem can be treated as a search problem. The search space is the set of states of all wedges of all wheels. The match criteria is at any give second, each wheel out of five wheels should have at least one wedge whose angle and â€˜coversâ€™ (the extent) that overlaps with (again, at least one) wedges from other wheels.<br>The catch is we only need to examine the first 360 second and bail out as soon as we have a match, because the state of the wheel and wedges will be reset to the same original state after 360 sec (a cycle).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> wheel &#123;</div><div class="line">    <span class="keyword">int</span> speed;</div><div class="line">    <span class="keyword">int</span> wedgeCnt;</div><div class="line">    <span class="keyword">int</span> start[<span class="number">5</span>];</div><div class="line">    <span class="keyword">int</span> angle[<span class="number">5</span>];</div><div class="line">&#125; tWheel;</div><div class="line"></div><div class="line">tWheel wheels[<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"spin.in"</span>)</span></span>;</div><div class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"spin.out"</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</div><div class="line">        fin &gt;&gt; wheels[i].speed &gt;&gt; wheels[i].wedgeCnt;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wheels[i].wedgeCnt; ++j) &#123;</div><div class="line">            fin &gt;&gt; wheels[i].start[j] &gt;&gt; wheels[i].angle[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= <span class="number">360</span>; ++m) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; align(<span class="number">360</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</div><div class="line">            tWheel wheel = wheels[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wheel.wedgeCnt; ++j) &#123;</div><div class="line">                <span class="keyword">int</span> start = (wheel.start[j] + wheel.speed * m) % <span class="number">360</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = start; k &lt;= start + wheel.angle[j]; ++k) &#123;</div><div class="line">                    align[k % <span class="number">360</span>]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (align[i] == <span class="number">5</span>) &#123;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                fout &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"none"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    fout &lt;&lt; <span class="string">"none"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This problem can be treated as a search problem. The search space is the set of states of all wedges of all wheels. The match criteria is
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Search" scheme="http://lianghan.org/tags/Search/"/>
    
      <category term="Simulation" scheme="http://lianghan.org/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.2 Stringsorbits</title>
    <link href="http://lianghan.org/2016/11/01/2016-11-01-USACO-StringsOrbits.h/"/>
    <id>http://lianghan.org/2016/11/01/2016-11-01-USACO-StringsOrbits.h/</id>
    <published>2016-11-01T22:21:31.000Z</published>
    <updated>2016-11-06T23:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> N<span class="comment">/* length of string*/</span>, L<span class="comment">/* max number of bits per string */</span>;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> I <span class="comment">/* the order */</span>;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">32</span>][<span class="number">32</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    dp[i][j] = compute(i - <span class="number">1</span>, j) + compute(i - <span class="number">1</span>, j - <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> dp[i][j];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"kimbits.in"</span>)</span></span>;</div><div class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"kimbits.out"</span>)</span></span>;</div><div class="line">  </div><div class="line">  fin &gt;&gt; N &gt;&gt; L &gt;&gt; I;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)&#123;</div><div class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= L; j++)&#123;</div><div class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = N - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;</div><div class="line">    <span class="keyword">if</span>(compute(k, L) &lt; I)&#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</div><div class="line">      fout &lt;&lt; <span class="number">1</span>;</div><div class="line">      I -= compute(k,L);</div><div class="line">      L--;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</div><div class="line">      fout &lt;&lt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  fout &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/spa
    
    </summary>
    
      <category term="USACO" scheme="http://lianghan.org/categories/USACO/"/>
    
    
      <category term="Combination" scheme="http://lianghan.org/tags/Combination/"/>
    
      <category term="Dynamic Programming" scheme="http://lianghan.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
