<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quantum Field</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lianghan.org/"/>
  <updated>2019-11-25T04:56:15.522Z</updated>
  <id>http://lianghan.org/</id>
  
  <author>
    <name>Michael Han</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 1136. Parallel Courses</title>
    <link href="http://lianghan.org/2019/11/22/2019-11-22-LeetCode1136/"/>
    <id>http://lianghan.org/2019/11/22/2019-11-22-LeetCode1136/</id>
    <published>2019-11-22T19:11:11.000Z</published>
    <updated>2019-11-25T04:56:15.522Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/parallel-courses/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, HashSet&#125;;</span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">minimum_semesters</span></span>(n: <span class="keyword">i32</span>, relations: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> in_degrees = <span class="built_in">vec!</span>[<span class="number">0</span>; n <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map: HashMap&lt;<span class="keyword">i32</span>, HashSet&lt;<span class="keyword">i32</span>&gt;&gt; = HashMap::new();</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> &amp;relations &#123;</span><br><span class="line">            map.entry(r[<span class="number">0</span>]).or_insert(HashSet::new());</span><br><span class="line">            map.get_mut(&amp;r[<span class="number">0</span>]).unwrap().insert(r[<span class="number">1</span>]);</span><br><span class="line">            in_degrees[r[<span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">usize</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> sum) = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..n + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> in_degrees[i <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">0</span> &#123;</span><br><span class="line">                q.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> size = q.len();</span><br><span class="line">            sum += size;</span><br><span class="line">            <span class="keyword">for</span> _i <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">                <span class="keyword">let</span> cur = q.front().unwrap().clone();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                <span class="keyword">if</span> !map.contains_key(&amp;cur) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> next <span class="keyword">in</span> map.get(&amp;cur).unwrap() &#123;</span><br><span class="line">                    in_degrees[*next <span class="keyword">as</span> <span class="keyword">usize</span>] -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> in_degrees[*next <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">0</span> &#123;</span><br><span class="line">                        q.push_back(*next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum == n <span class="keyword">as</span> <span class="keyword">usize</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/parallel-courses/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1213. Intersection of Three Sorted Arrays</title>
    <link href="http://lianghan.org/2019/11/22/2019-11-22-LeetCode1213/"/>
    <id>http://lianghan.org/2019/11/22/2019-11-22-LeetCode1213/</id>
    <published>2019-11-22T19:11:11.000Z</published>
    <updated>2019-11-25T04:57:19.895Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/intersection-of-three-sorted-arrays/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">arrays_intersection</span></span>(arr1: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, arr2: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, arr3: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> i, <span class="keyword">mut</span> j, <span class="keyword">mut</span> k) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; arr1.len() &amp;&amp; j &lt; arr2.len() &amp;&amp; k &lt; arr3.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> arr1[i] == arr2[j] &amp;&amp; arr2[j] == arr3[k] &#123;</span><br><span class="line">                ans.push(arr1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> min_val = cmp::min(arr1[i], cmp::min(arr2[j], arr3[k]));</span><br><span class="line">            <span class="keyword">if</span> arr1[i] == min_val &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> arr2[j] == min_val &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> arr3[k] == min_val &#123;</span><br><span class="line">                k += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/intersection-of-three-sorted-arrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 895. Maximum Frequency Stack</title>
    <link href="http://lianghan.org/2019/11/22/2019-11-22-LeetCode895/"/>
    <id>http://lianghan.org/2019/11/22/2019-11-22-LeetCode895/</id>
    <published>2019-11-22T19:11:11.000Z</published>
    <updated>2019-11-23T17:07:09.835Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-frequency-stack/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FreqStack</span></span> &#123;</span><br><span class="line">    mx_freq: <span class="keyword">i32</span>,</span><br><span class="line">    freq: HashMap&lt;<span class="keyword">i32</span>, <span class="keyword">i32</span>&gt;,</span><br><span class="line">    m: HashMap&lt;<span class="keyword">i32</span>, <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FreqStack &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        FreqStack &#123;</span><br><span class="line">            mx_freq: <span class="number">0</span>,</span><br><span class="line">            freq: HashMap::new(),</span><br><span class="line">            m: HashMap::new()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="keyword">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.freq.entry(x).or_insert(<span class="number">0</span>);</span><br><span class="line">        *<span class="keyword">self</span>.freq.get_mut(&amp;x).unwrap() += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> val = *<span class="keyword">self</span>.freq.get(&amp;x).unwrap();</span><br><span class="line">        <span class="keyword">self</span>.mx_freq = cmp::max(<span class="keyword">self</span>.mx_freq, val);</span><br><span class="line">        <span class="keyword">self</span>.m.entry(val).or_insert(<span class="built_in">vec!</span>[]);</span><br><span class="line">        <span class="keyword">self</span>.m.get_mut(&amp;val).unwrap().push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;        </span><br><span class="line">        <span class="keyword">let</span> x = <span class="keyword">self</span>.m.get(&amp;<span class="keyword">self</span>.mx_freq).unwrap().last().unwrap().clone();</span><br><span class="line">        <span class="keyword">self</span>.m.get_mut(&amp;<span class="keyword">self</span>.mx_freq).unwrap().pop();</span><br><span class="line">        <span class="keyword">let</span> val = <span class="keyword">self</span>.freq.get(&amp;x).unwrap();</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.m.contains_key(val) || <span class="keyword">self</span>.m.get(val).unwrap().is_empty() &#123;</span><br><span class="line">            <span class="keyword">self</span>.mx_freq -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *<span class="keyword">self</span>.freq.get_mut(&amp;x).unwrap() -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-frequency-stack/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 934. Shortest Bridge</title>
    <link href="http://lianghan.org/2019/11/22/2019-11-22-LeetCode934/"/>
    <id>http://lianghan.org/2019/11/22/2019-11-22-LeetCode934/</id>
    <published>2019-11-22T19:11:11.000Z</published>
    <updated>2019-11-23T17:05:09.428Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/shortest-bridge/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(grid: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, x: <span class="keyword">i32</span>, y:<span class="keyword">i32</span>, q: &amp;<span class="keyword">mut</span> VecDeque&lt;(<span class="keyword">i32</span>, <span class="keyword">i32</span>)&gt;) &#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].len() <span class="keyword">as</span> <span class="keyword">i32</span> ||</span><br><span class="line">            x &gt;= grid.len() <span class="keyword">as</span> <span class="keyword">i32</span> || grid[x <span class="keyword">as</span> <span class="keyword">usize</span>][y <span class="keyword">as</span> <span class="keyword">usize</span>] != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x <span class="keyword">as</span> <span class="keyword">usize</span>][y <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">2</span>;</span><br><span class="line">        q.push_back((x, y));</span><br><span class="line">        Self::dfs(grid, x - <span class="number">1</span>, y, q);</span><br><span class="line">        Self::dfs(grid, x, y - <span class="number">1</span>, q);</span><br><span class="line">        Self::dfs(grid, x + <span class="number">1</span>, y, q);</span><br><span class="line">        Self::dfs(grid, x, y + <span class="number">1</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">shortest_bridge</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> grid = a.clone();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..a.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> find &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..grid[<span class="number">0</span>].len() &#123;</span><br><span class="line">                <span class="keyword">if</span> find &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Self::dfs(&amp;<span class="keyword">mut</span> grid, i <span class="keyword">as</span> <span class="keyword">i32</span>, j <span class="keyword">as</span> <span class="keyword">i32</span>, &amp;<span class="keyword">mut</span> q);</span><br><span class="line">                find = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> size = q.len();</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">                size -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> item = q.front().unwrap().clone();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                <span class="keyword">let</span> (x, y) = (item.<span class="number">0</span>, item.<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> (tx, ty) = (x + dx[i], y + dy[i]);</span><br><span class="line">                    <span class="keyword">if</span> tx &lt; <span class="number">0</span> || ty &lt; <span class="number">0</span> || ty &gt;= grid[<span class="number">0</span>].len() <span class="keyword">as</span> <span class="keyword">i32</span> ||</span><br><span class="line">                        tx &gt;= grid.len() <span class="keyword">as</span> <span class="keyword">i32</span> || grid[tx <span class="keyword">as</span> <span class="keyword">usize</span>][ty <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">2</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> grid[tx <span class="keyword">as</span> <span class="keyword">usize</span>][ty <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">1</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    &#125;</span><br><span class="line">                    grid[tx <span class="keyword">as</span> <span class="keyword">usize</span>][ty <span class="keyword">as</span> <span class="keyword">usize</span>] = <span class="number">2</span>;</span><br><span class="line">                    q.push_back((tx, ty));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/shortest-bridge/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 980. Unique Paths III</title>
    <link href="http://lianghan.org/2019/11/22/2019-11-22-LeetCode980/"/>
    <id>http://lianghan.org/2019/11/22/2019-11-22-LeetCode980/</id>
    <published>2019-11-22T19:11:11.000Z</published>
    <updated>2019-11-25T04:55:26.661Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/unique-paths-iii/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(grid: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>, n: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || x == grid[<span class="number">0</span>].len() <span class="keyword">as</span> <span class="keyword">i32</span> || y &lt; <span class="number">0</span> || y == grid.len() <span class="keyword">as</span> <span class="keyword">i32</span> ||</span><br><span class="line">            grid[y <span class="keyword">as</span> <span class="keyword">usize</span>][x <span class="keyword">as</span> <span class="keyword">usize</span>] == -<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> (yy, xx) = (y <span class="keyword">as</span> <span class="keyword">usize</span>, x <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        <span class="keyword">if</span> grid[yy][xx] == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[yy][xx] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> ans = Self::dfs(grid, x + <span class="number">1</span>, y, n - <span class="number">1</span>) +</span><br><span class="line">            Self::dfs(grid, x - <span class="number">1</span>, y, n - <span class="number">1</span>) +</span><br><span class="line">            Self::dfs(grid, x, y + <span class="number">1</span>, n - <span class="number">1</span>) +</span><br><span class="line">            Self::dfs(grid, x, y - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        grid[yy][xx] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unique_paths_iii</span></span>(grid: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> sx, <span class="keyword">mut</span> sy, <span class="keyword">mut</span> n) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> g = grid.clone();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..g.len() &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..g[<span class="number">0</span>].len() &#123;</span><br><span class="line">                <span class="keyword">if</span> g[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                    n += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                    sx = j; sy = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Self::dfs(&amp;<span class="keyword">mut</span> g, sx <span class="keyword">as</span> <span class="keyword">i32</span>, sy <span class="keyword">as</span> <span class="keyword">i32</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths-iii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1015. Smallest Integer Divisible by K</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1015/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1015/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T22:39:16.735Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/smallest-integer-divisible-by-k/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">smallest_repunit_div_by_k</span></span>(k: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> cur, <span class="keyword">mut</span> ans) = (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span> || k  % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ans &lt;= k &#123;</span><br><span class="line">            <span class="keyword">if</span> cur % k == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = (cur * <span class="number">10</span> + <span class="number">1</span>) % k;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/smallest-integer-divisible-by-k/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1016. Binary String With Substrings Representing 1 To N</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1016/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1016/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T23:43:09.354Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Typical BFS.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">query_string</span></span>(s: <span class="built_in">String</span>, n: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> set = HashSet::new();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..s.len() &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i..s.len() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">str</span> = <span class="built_in">String</span>::from(&amp;s[i..j + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">let</span> num = i32::from_str_radix(&amp;<span class="keyword">str</span>, <span class="number">2</span>).unwrap();</span><br><span class="line">                <span class="keyword">if</span> num &gt; n &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..n + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !set.contains(&amp;i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pro
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1020. Number of Enclaves</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1020/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1020/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-14T20:45:08.623Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-enclaves/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Typical DFS. Similar to <a href="https://leetcode.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">1254. Number of Closed Islands</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(a : &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, x : <span class="keyword">usize</span>, y : <span class="keyword">usize</span>) -&gt; () &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n) = (a.len(), a[<span class="number">0</span>].len());</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (xx, yy) : (<span class="keyword">i32</span>, <span class="keyword">i32</span>) = (x <span class="keyword">as</span> <span class="keyword">i32</span> + dx[i], y <span class="keyword">as</span> <span class="keyword">i32</span> + dy[i]);</span><br><span class="line">            <span class="keyword">if</span> xx &gt;= m <span class="keyword">as</span> <span class="keyword">i32</span> || xx &lt; <span class="number">0</span> || yy &gt;= n <span class="keyword">as</span> <span class="keyword">i32</span> || yy &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">            <span class="keyword">if</span> a[nx][ny] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">            Self::dfs(a, nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">num_enclaves</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> A = a;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> ans) = (A.len(), A[<span class="number">0</span>].len(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> A[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">                        A[i][j] = <span class="number">0</span>;</span><br><span class="line">                        Self::dfs(&amp;<span class="keyword">mut</span> A, i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> A[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-enclaves/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Typic
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1031 Maximum Sum of Two Non-Overlapping Subarrays</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1031/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1031/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-14T04:59:58.317Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Maintain a sliding window of two sub arrays with length L and M and slide through. For each slide check two cases:<br>L first, or M first. Use prefix sum to speed up calculation of sum of a given sub array.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">max_sum_two_no_overlap</span></span>(a: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, l: <span class="keyword">i32</span>, m: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> A = a.iter().scan(<span class="number">0</span>, |sum, i| &#123;*sum += *i; <span class="literal">Some</span>(*sum)&#125;).collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">        <span class="keyword">let</span> (L, M) = (l <span class="keyword">as</span> <span class="keyword">usize</span>, m <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> lmax, <span class="keyword">mut</span> rmax) = (A[L + M - <span class="number">1</span>], A[L - <span class="number">1</span>], A[M - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> L + M..A.len() <span class="keyword">as</span> <span class="keyword">usize</span> &#123;</span><br><span class="line">            lmax = cmp::max(lmax, A[i - M] - A[i - M - L]);</span><br><span class="line">            rmax = cmp::max(rmax, A[i - L] - A[i - L - M]);</span><br><span class="line">            ans = cmp::max(ans, cmp::max(A[i] - A[i - L] + rmax, A[i] - A[i - M] + lmax));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem 
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1066. Campus Bikes II</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1066/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1066/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T17:07:28.735Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/campus-bikes-ii/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>DFS with memorization.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dist</span></span>(worker: &amp;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, bike: &amp;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;) -&gt; <span class="keyword">usize</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((worker[<span class="number">0</span>] - bike[<span class="number">0</span>]).abs() + (worker[<span class="number">1</span>] - bike[<span class="number">1</span>]).abs()) <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>(workers: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, bikes: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, index: <span class="keyword">usize</span>, used: <span class="keyword">usize</span>,</span><br><span class="line">           memo: &amp;<span class="keyword">mut</span> HashMap&lt;<span class="built_in">String</span>, <span class="keyword">usize</span>&gt;) -&gt; <span class="keyword">usize</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == workers.len() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> key = [index.to_string(), <span class="built_in">String</span>::from(<span class="string">"."</span>), used.to_string()].concat();</span><br><span class="line">        <span class="keyword">if</span> memo.contains_key(&amp;key) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(&amp;key).unwrap().clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> min_dist = std::usize::MAX;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> next_used = used;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..bikes.len() &#123;</span><br><span class="line">            <span class="keyword">if</span> next_used &amp; (<span class="number">1</span> &lt;&lt; i) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next_used = used | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            min_dist = cmp::min(min_dist,</span><br><span class="line">                                Self::dfs(workers, bikes, index + <span class="number">1</span>, next_used, memo) + Self::dist(&amp;workers[index], &amp;bikes[i]));</span><br><span class="line">            next_used ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.insert(key, min_dist);</span><br><span class="line">        <span class="keyword">return</span> min_dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">assign_bikes</span></span>(workers: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;, bikes: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> memo = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> w, <span class="keyword">mut</span> b) = (workers.clone(), bikes.clone());</span><br><span class="line">        <span class="keyword">return</span> Self::dfs(&amp;<span class="keyword">mut</span> w, &amp;<span class="keyword">mut</span> b, <span class="number">0</span>, <span class="number">0</span>, &amp;<span class="keyword">mut</span> memo) <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/campus-bikes-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DFS with
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1121. Divide Array Into Increasing Sequences</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1121/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1121/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-18T05:42:38.772Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divide-array-into-increasing-sequences/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">can_divide_into_subsequences</span></span>(nums: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, k: <span class="keyword">i32</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> max, <span class="keyword">mut</span> cur) = (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..nums.len() - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>] &#123;</span><br><span class="line">                cur += <span class="number">1</span>;</span><br><span class="line">                max = std::cmp::max(max, cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.len() &gt;= (k * max) <span class="keyword">as</span> <span class="keyword">usize</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/divide-array-into-increasing-sequences/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statem
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1153. String Transforms Into Another String</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1153/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1153/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T22:18:01.684Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/string-transforms-into-another-string/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, HashSet&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">can_convert</span></span>(str1: <span class="built_in">String</span>, str2: <span class="built_in">String</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> str1.len() != str2.len() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> str1 == str2 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> have = HashSet::new();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..str1.len() &#123;</span><br><span class="line">            <span class="keyword">let</span> (key, val) = (str1.chars().nth(i).unwrap(), str2.chars().nth(i).unwrap());</span><br><span class="line">            have.insert(val);</span><br><span class="line">            <span class="keyword">if</span> !map.contains_key(&amp;key) &#123;</span><br><span class="line">                map.insert(key, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> *map.get(&amp;key).unwrap() != val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.len() &gt;= have.len() &amp;&amp; (have.len() &lt; <span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/string-transforms-into-another-string/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Stateme
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1146. Snapshot Array</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1146/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1146/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-23T16:58:24.873Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/snapshot-array/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::&#123;HashMap, BTreeMap&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnapshotArray</span></span> &#123;</span><br><span class="line">    map : HashMap&lt;<span class="keyword">i32</span>, BTreeMap&lt;<span class="keyword">i32</span>, <span class="keyword">i32</span>&gt;&gt;,</span><br><span class="line">    version: <span class="keyword">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> SnapshotArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(length: <span class="keyword">i32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        SnapshotArray &#123;</span><br><span class="line">            map: HashMap::new(),</span><br><span class="line">            version: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="keyword">i32</span>, val: <span class="keyword">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.map.entry(index).or_insert(BTreeMap::new());</span><br><span class="line">        <span class="keyword">self</span>.map.get_mut(&amp;index).unwrap().insert(<span class="keyword">self</span>.version, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">snap</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="keyword">self</span>.version;</span><br><span class="line">        <span class="keyword">self</span>.version += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(&amp;<span class="keyword">self</span>, index: <span class="keyword">i32</span>, snap_id: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.map.contains_key(&amp;index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="keyword">self</span>.map.get(&amp;index).unwrap();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> vals &#123;</span><br><span class="line">            <span class="keyword">if</span> snap_id &gt;= *entry.<span class="number">0</span> &#123;</span><br><span class="line">                ans = *entry.<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/snapshot-array/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1147. Longest Chunked Palindrome Decomposition</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1147/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1147/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T22:03:09.797Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">longest_decomposition</span></span>(text: <span class="built_in">String</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, n) = (<span class="number">0</span>, text.len());</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> l, <span class="keyword">mut</span> r) = (<span class="built_in">String</span>::from(<span class="string">""</span>), <span class="built_in">String</span>::from(<span class="string">""</span>));</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            l.push(text.chars().nth(i).unwrap());</span><br><span class="line">            r.insert(<span class="number">0</span>, text.chars().nth(n - i - <span class="number">1</span>).unwrap());</span><br><span class="line">            <span class="keyword">if</span> l == r &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                l.clear(); r.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Stat
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>1197. Minimum Knight Moves</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1197/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1197/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-15T17:53:27.135Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-knight-moves/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">min_knight_moves</span></span>(x: <span class="keyword">i32</span>, y: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">8</span>], [<span class="keyword">i32</span>; <span class="number">8</span>]) = (</span><br><span class="line">            [-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">            [-<span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> grid = [[-<span class="number">1</span>; <span class="number">888</span>] ; <span class="number">888</span>];</span><br><span class="line">        <span class="keyword">let</span> (ax, ay) = (x.abs() <span class="keyword">as</span> <span class="keyword">usize</span>, y.abs() <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">        grid[<span class="number">400</span>][<span class="number">400</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q : VecDeque&lt;(<span class="keyword">usize</span>, <span class="keyword">usize</span>)&gt; = VecDeque::new();</span><br><span class="line">        q.push_back((<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> (cx, cy) = q.pop_front().unwrap();</span><br><span class="line">            <span class="keyword">if</span> cx == ax &amp;&amp; cy == ay &#123;</span><br><span class="line">                <span class="keyword">return</span> grid[cx + <span class="number">400</span>][cy + <span class="number">400</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (xx, yy) = (cx <span class="keyword">as</span> <span class="keyword">i32</span> + dx[k] , cy <span class="keyword">as</span> <span class="keyword">i32</span> + dy[k]);</span><br><span class="line">                <span class="keyword">let</span> (nx, ny) = ((xx + <span class="number">400</span>) <span class="keyword">as</span> <span class="keyword">usize</span>, (yy + <span class="number">400</span>) <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                <span class="keyword">if</span> grid[nx][ny] != -<span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[nx][ny] = grid[cx + <span class="number">400</span>][cy + <span class="number">400</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> xx <span class="keyword">as</span> <span class="keyword">usize</span> == ax &amp;&amp; yy <span class="keyword">as</span> <span class="keyword">usize</span> == ay &#123;</span><br><span class="line">                    <span class="keyword">return</span> grid[nx][ny];</span><br><span class="line">                &#125;</span><br><span class="line">                q.push_back((xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-knight-moves/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1155. Number of Dice Rolls With Target Sum</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1155/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1155/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T18:03:58.312Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">num_rolls_to_target</span></span>(d: <span class="keyword">i32</span>, f: <span class="keyword">i32</span>, target: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> MOD : <span class="keyword">u64</span> = <span class="number">1e9</span> <span class="keyword">as</span> <span class="keyword">u64</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> dp = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span>; target <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span>]; d <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..d <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..f <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> j..target <span class="keyword">as</span> <span class="keyword">usize</span> + <span class="number">1</span> &#123;</span><br><span class="line">                    dp[i][k] = (dp[i][k] + dp[i - <span class="number">1</span>][k - j]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[d <span class="keyword">as</span> <span class="keyword">usize</span>][target <span class="keyword">as</span> <span class="keyword">usize</span>] <span class="keyword">as</span> <span class="keyword">i32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statemen
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>1218. Longest Arithmetic Subsequence of Given Difference</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1218/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1218/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-16T22:25:15.404Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">longest_subsequence</span></span>(arr: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, difference: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> ans, <span class="keyword">mut</span> map) = (<span class="number">0</span>, HashMap::new());</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr &#123;</span><br><span class="line">            <span class="keyword">let</span> val = cmp::max(*map.entry(i).or_insert(<span class="number">0</span>),</span><br><span class="line">                               *map.entry(i - difference).or_insert(<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            map.insert(i, val);</span><br><span class="line">            ans = cmp::max(ans, *map.entry(i).or_insert(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pr
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1219. Path with Maximum Gold</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1219/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1219/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-16T23:04:06.482Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/path-with-maximum-gold/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>BFS.</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">use</span> std::cmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_maximum_gold</span></span>(grid: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;&gt;) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (m, n, <span class="keyword">mut</span> ans, <span class="keyword">mut</span> id) = (grid.len(), grid[<span class="number">0</span>].len(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> (dx, dy) : ([<span class="keyword">i32</span>; <span class="number">4</span>], [<span class="keyword">i32</span>; <span class="number">4</span>]) = ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> visited = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span>; n]; m];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                id += <span class="number">1</span>;</span><br><span class="line">                visited[i][j] = <span class="number">1</span> &lt;&lt; id;</span><br><span class="line">                q.push_back((i, j, grid[i][j], visited[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> cur = q.pop_front().unwrap();</span><br><span class="line">            <span class="keyword">let</span> (x, y, sum, state) = (cur.<span class="number">0</span> <span class="keyword">as</span> <span class="keyword">i32</span>, cur.<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">i32</span>, cur.<span class="number">2</span>, cur.<span class="number">3</span>);</span><br><span class="line">            ans = cmp::max(ans, sum);</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (xx, yy) = (x + dx[i], y + dy[i]);</span><br><span class="line">                <span class="keyword">if</span> xx &lt; <span class="number">0</span> || xx == m <span class="keyword">as</span> <span class="keyword">i32</span> || yy &lt; <span class="number">0</span> || yy == n <span class="keyword">as</span> <span class="keyword">i32</span> ||</span><br><span class="line">                    grid[xx <span class="keyword">as</span> <span class="keyword">usize</span>][yy <span class="keyword">as</span> <span class="keyword">usize</span>] == <span class="number">0</span> || (state &amp; visited[xx <span class="keyword">as</span> <span class="keyword">usize</span>][yy <span class="keyword">as</span> <span class="keyword">usize</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> (nx, ny) = (xx <span class="keyword">as</span> <span class="keyword">usize</span>, yy <span class="keyword">as</span> <span class="keyword">usize</span>);</span><br><span class="line">                q.push_back((nx, ny, sum + grid[nx][ny], state | visited[nx][ny]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/path-with-maximum-gold/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1231. Divide Chocolate</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1231/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1231/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T05:13:46.569Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/divide-chocolate/description/" target="_blank" rel="noopener">Problem Statement</a></p><p>Binary Search</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">maximize_sweetness</span></span>(sweetness: <span class="built_in">Vec</span>&lt;<span class="keyword">i32</span>&gt;, k: <span class="keyword">i32</span>) -&gt; <span class="keyword">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> l = sweetness.clone().into_iter().fold(<span class="literal">None</span>, |min, x| <span class="keyword">match</span> min &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">Some</span>(x),</span><br><span class="line">            <span class="literal">Some</span>(y) =&gt; <span class="literal">Some</span>(<span class="keyword">if</span> x &lt; y &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;),</span><br><span class="line">        &#125;).unwrap();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> r = sweetness.clone().iter().fold(<span class="number">0</span>, |<span class="keyword">mut</span> r, &amp;val| &#123;r += val; r&#125;);</span><br><span class="line">        <span class="keyword">while</span> l &lt; r &#123;</span><br><span class="line">            <span class="keyword">let</span> (mid, <span class="keyword">mut</span> sum, <span class="keyword">mut</span> cut) = ((l + r + <span class="number">1</span>) / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> sweetness.clone() &#123;</span><br><span class="line">                sum += val;</span><br><span class="line">                <span class="keyword">if</span> sum &gt;= mid &#123;</span><br><span class="line">                    sum = <span class="number">0</span>; cut += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> cut &gt; k &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cut &gt; k &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/divide-chocolate/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Binary 
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1233. Remove Sub-Folders from the Filesystem</title>
    <link href="http://lianghan.org/2019/11/11/2019-11-11-LeetCode1233/"/>
    <id>http://lianghan.org/2019/11/11/2019-11-11-LeetCode1233/</id>
    <published>2019-11-11T19:11:11.000Z</published>
    <updated>2019-11-17T04:21:58.868Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/description/" target="_blank" rel="noopener">Problem Statement</a></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove_subfolders</span></span>(folder: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> f, <span class="keyword">mut</span> ans) = (folder, <span class="built_in">vec!</span>[]);</span><br><span class="line">        <span class="keyword">if</span> f.is_empty() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vec!</span>[];</span><br><span class="line">        &#125;</span><br><span class="line">        f.sort();</span><br><span class="line">        ans.push(f[<span class="number">0</span>].clone());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..f.len() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> prefix = ans.last().unwrap().clone();</span><br><span class="line">            prefix.push(<span class="string">'/'</span>);</span><br><span class="line">            <span class="keyword">let</span> cur = f[i].clone();</span><br><span class="line">            <span class="keyword">if</span> cur.len() &lt; prefix.len() || cur[..prefix.len()].to_string() != prefix  &#123;</span><br><span class="line">                ans.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem Statem
      
    
    </summary>
    
      <category term="LeetCode in Rust" scheme="http://lianghan.org/categories/LeetCode-in-Rust/"/>
    
    
      <category term="Algorithm" scheme="http://lianghan.org/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://lianghan.org/tags/LeetCode/"/>
    
      <category term="Rust" scheme="http://lianghan.org/tags/Rust/"/>
    
  </entry>
  
</feed>
